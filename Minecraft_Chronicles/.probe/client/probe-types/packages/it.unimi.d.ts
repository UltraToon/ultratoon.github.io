declare module "packages/it/unimi/dsi/fastutil/floats/$FloatConsumer" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/java/util/function/$DoubleConsumer"

export interface $FloatConsumer extends $Consumer<(float)>, $DoubleConsumer {

/**
 * 
 * @deprecated
 */
 "accept"(arg0: float): void
/**
 * 
 * @deprecated
 */
 "accept"(arg0: double): void
 "accept"(arg0: float): void
/**
 * 
 * @deprecated
 */
 "andThen"(arg0: $Consumer$Type<(any)>): $Consumer<(float)>
 "andThen"(arg0: $FloatConsumer$Type): $FloatConsumer

(arg0: float): void
}

export namespace $FloatConsumer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatConsumer$Type = ($FloatConsumer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatConsumer_ = $FloatConsumer$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ObjectCollection" {
import {$ObjectIterable, $ObjectIterable$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectIterable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ObjectSpliterator, $ObjectSpliterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSpliterator"

export interface $ObjectCollection<K> extends $Collection<(K)>, $ObjectIterable<(K)> {

 "spliterator"(): $ObjectSpliterator<(K)>
 "add"(arg0: K): boolean
 "remove"(arg0: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "stream"(): $Stream<(K)>
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $ObjectCollection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectCollection$Type<K> = ($ObjectCollection<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectCollection_<K> = $ObjectCollection$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortBidirectionalIterator" {
import {$ShortIterator, $ShortIterator$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$ShortConsumer, $ShortConsumer$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortConsumer"
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterator"

export interface $ShortBidirectionalIterator extends $ShortIterator, $ObjectBidirectionalIterator<(short)> {

 "skip"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "previous"(): short
 "back"(arg0: integer): integer
 "previousShort"(): short
 "forEachRemaining"(arg0: $IntConsumer$Type): void
 "forEachRemaining"(arg0: $ShortConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "nextShort"(): short
 "hasPrevious"(): boolean
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $ShortBidirectionalIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortBidirectionalIterator$Type = ($ShortBidirectionalIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortBidirectionalIterator_ = $ShortBidirectionalIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Object2DoubleFunction<K> extends $Function$0<(K), (double)>, $ToDoubleFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): double
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): double
 "put"(arg0: K, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: double): double
 "getDouble"(arg0: any): double
 "getOrDefault"(arg0: any, arg1: double): double
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeDouble"(arg0: any): double
 "andThenDouble"(arg0: $Double2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2DoubleFunction
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2DoubleFunction
 "andThenFloat"(arg0: $Double2FloatFunction$Type): $Object2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2DoubleFunction
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2DoubleFunction
 "andThenInt"(arg0: $Double2IntFunction$Type): $Object2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$Type): $Object2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2DoubleFunction<(T)>
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2DoubleFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Double2ByteFunction$Type): $Object2ByteFunction<(K)>
 "defaultReturnValue"(): double
 "defaultReturnValue"(arg0: double): void
 "andThenShort"(arg0: $Double2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2DoubleFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): double
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (double)>

(arg0: any): double
}

export namespace $Object2DoubleFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2DoubleFunction$Type<K> = ($Object2DoubleFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2DoubleFunction_<K> = $Object2DoubleFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"

export interface $Boolean2FloatFunction extends $Function$0<(boolean), (float)> {

 "remove"(arg0: boolean): float
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): float
 "get"(arg0: boolean): float
 "put"(arg0: boolean, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: float): float
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: boolean, arg1: float): float
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(boolean), (T)>
 "andThenDouble"(arg0: $Float2DoubleFunction$Type): $Boolean2DoubleFunction
 "composeChar"(arg0: $Char2BooleanFunction$Type): $Char2FloatFunction
 "composeShort"(arg0: $Short2BooleanFunction$Type): $Short2FloatFunction
 "andThenFloat"(arg0: $Float2FloatFunction$Type): $Boolean2FloatFunction
 "composeFloat"(arg0: $Float2BooleanFunction$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$Type): $Boolean2LongFunction
 "composeLong"(arg0: $Long2BooleanFunction$Type): $Long2FloatFunction
 "composeInt"(arg0: $Int2BooleanFunction$Type): $Int2FloatFunction
 "andThenInt"(arg0: $Float2IntFunction$Type): $Boolean2IntFunction
 "composeDouble"(arg0: $Double2BooleanFunction$Type): $Double2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$Type): $Boolean2CharFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$Type<(any)>): $Object2FloatFunction<(T)>
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$Type<(any)>): $Boolean2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2BooleanFunction$Type<(any)>): $Reference2FloatFunction<(T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$Type<(any)>): $Boolean2ObjectFunction<(T)>
 "andThenByte"(arg0: $Float2ByteFunction$Type): $Boolean2ByteFunction
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "andThenShort"(arg0: $Float2ShortFunction$Type): $Boolean2ShortFunction
 "composeByte"(arg0: $Byte2BooleanFunction$Type): $Byte2FloatFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: boolean): float

(arg0: boolean): float
}

export namespace $Boolean2FloatFunction {
function identity<T>(): $Function<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2FloatFunction$Type = ($Boolean2FloatFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2FloatFunction_ = $Boolean2FloatFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Function, $Function$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$DoubleUnaryOperator, $DoubleUnaryOperator$Type} from "packages/java/util/function/$DoubleUnaryOperator"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/java/util/function/$Function"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"

export interface $Float2FloatFunction extends $Function<(float), (float)>, $DoubleUnaryOperator {

 "remove"(arg0: float): float
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): float
 "get"(arg0: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: float): float
 "put"(arg0: float, arg1: float): float
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: float, arg1: float): float
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(float), (T)>
 "andThenDouble"(arg0: $Float2DoubleFunction$Type): $Float2DoubleFunction
 "composeChar"(arg0: $Char2FloatFunction$Type): $Char2FloatFunction
 "composeShort"(arg0: $Short2FloatFunction$Type): $Short2FloatFunction
 "andThenFloat"(arg0: $Float2FloatFunction$Type): $Float2FloatFunction
 "composeFloat"(arg0: $Float2FloatFunction$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$Type): $Float2LongFunction
 "composeLong"(arg0: $Long2FloatFunction$Type): $Long2FloatFunction
 "composeInt"(arg0: $Int2FloatFunction$Type): $Int2FloatFunction
 "andThenInt"(arg0: $Float2IntFunction$Type): $Float2IntFunction
 "composeDouble"(arg0: $Double2FloatFunction$Type): $Double2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$Type): $Float2CharFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$Type<(any)>): $Object2FloatFunction<(T)>
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$Type<(any)>): $Float2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2FloatFunction$Type<(any)>): $Reference2FloatFunction<(T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$Type<(any)>): $Float2ObjectFunction<(T)>
 "andThenByte"(arg0: $Float2ByteFunction$Type): $Float2ByteFunction
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "andThenShort"(arg0: $Float2ShortFunction$Type): $Float2ShortFunction
 "composeByte"(arg0: $Byte2FloatFunction$Type): $Byte2FloatFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: float): float
 "compose"(arg0: $DoubleUnaryOperator$Type): $DoubleUnaryOperator
 "andThen"(arg0: $DoubleUnaryOperator$Type): $DoubleUnaryOperator

(arg0: float): float
}

export namespace $Float2FloatFunction {
function identity(): $Float2FloatFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2FloatFunction$Type = ($Float2FloatFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2FloatFunction_ = $Float2FloatFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Object2CharFunction<K> extends $Function$0<(K), (character)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): character
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): character
 "put"(arg0: K, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: character): character
 "getChar"(arg0: any): character
 "getOrDefault"(arg0: any, arg1: character): character
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeChar"(arg0: any): character
 "andThenDouble"(arg0: $Char2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2CharFunction
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2CharFunction
 "andThenFloat"(arg0: $Char2FloatFunction$Type): $Object2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2CharFunction
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2CharFunction
 "andThenInt"(arg0: $Char2IntFunction$Type): $Object2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$Type): $Object2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2CharFunction<(T)>
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2CharFunction<(T)>
 "andThenObject"<T>(arg0: $Char2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Char2ByteFunction$Type): $Object2ByteFunction<(K)>
 "defaultReturnValue"(): character
 "defaultReturnValue"(arg0: character): void
 "andThenShort"(arg0: $Char2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2CharFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): character
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (character)>

(arg0: any): character
}

export namespace $Object2CharFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2CharFunction$Type<K> = ($Object2CharFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2CharFunction_<K> = $Object2CharFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction" {
import {$Function, $Function$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/java/util/function/$Function"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Byte2ByteFunction extends $Function<(byte), (byte)>, $IntUnaryOperator {

 "remove"(arg0: byte): byte
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): byte
 "get"(arg0: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: byte): byte
 "put"(arg0: byte, arg1: byte): byte
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: byte, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(byte), (T)>
 "andThenDouble"(arg0: $Byte2DoubleFunction$Type): $Byte2DoubleFunction
 "composeChar"(arg0: $Char2ByteFunction$Type): $Char2ByteFunction
 "composeShort"(arg0: $Short2ByteFunction$Type): $Short2ByteFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$Type): $Byte2FloatFunction
 "composeFloat"(arg0: $Float2ByteFunction$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$Type): $Byte2LongFunction
 "composeLong"(arg0: $Long2ByteFunction$Type): $Long2ByteFunction
 "composeInt"(arg0: $Int2ByteFunction$Type): $Int2ByteFunction
 "andThenInt"(arg0: $Byte2IntFunction$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2ByteFunction$Type): $Double2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$Type): $Byte2CharFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$Type<(any)>): $Object2ByteFunction<(T)>
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$Type<(any)>): $Byte2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ByteFunction$Type<(any)>): $Reference2ByteFunction<(T)>
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$Type<(any)>): $Byte2ObjectFunction<(T)>
 "andThenByte"(arg0: $Byte2ByteFunction$Type): $Byte2ByteFunction
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "andThenShort"(arg0: $Byte2ShortFunction$Type): $Byte2ShortFunction
 "composeByte"(arg0: $Byte2ByteFunction$Type): $Byte2ByteFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: byte): byte
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: byte): byte
}

export namespace $Byte2ByteFunction {
function identity(): $Byte2ByteFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2ByteFunction$Type = ($Byte2ByteFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2ByteFunction_ = $Byte2ByteFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectMap" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Int2ObjectMap$Entry, $Int2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectMap$Entry"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Int2ObjectMap<V> extends $Int2ObjectFunction<(V)>, $Map<(integer), (V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: integer, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: V): V
 "clear"(): void
 "replace"(arg0: integer, arg1: V, arg2: V): boolean
 "replace"(arg0: integer, arg1: V): V
 "size"(): integer
 "merge"(arg0: integer, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(integer), (V)>)>
 "putIfAbsent"(arg0: integer, arg1: V): V
 "compute"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: integer, arg1: $Int2ObjectFunction$Type<(any)>): V
 "computeIfAbsent"(arg0: integer, arg1: $IntFunction$Type<(any)>): V
 "getOrDefault"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): V
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: integer, arg1: $Int2ObjectFunction$Type<(any)>): V
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "int2ObjectEntrySet"(): $ObjectSet<($Int2ObjectMap$Entry<(V)>)>
 "remove"(arg0: integer): V
 "get"(arg0: integer): V
 "put"(arg0: integer, arg1: V): V
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Int2DoubleFunction
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2ObjectFunction<(V)>
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Int2FloatFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2ObjectFunction<(V)>
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Int2IntFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Int2CharFunction
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Int2ObjectFunction<(T)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Int2ByteFunction
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Int2ShortFunction
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2ObjectFunction<(V)>
 "remove"(arg0: any, arg1: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replace"(arg0: integer, arg1: V): V
 "replace"(arg0: integer, arg1: V, arg2: V): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "merge"(arg0: integer, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "putIfAbsent"(arg0: integer, arg1: V): V
 "compute"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "computeIfAbsent"(arg0: integer, arg1: $Function$Type<(any), (any)>): V
 "containsValue"(arg0: any): boolean
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "apply"(arg0: integer): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (V)>
}

export namespace $Int2ObjectMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V): $Map<(integer), (V)>
function of<K, V>(): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V, arg16: integer, arg17: V, arg18: integer, arg19: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V, arg16: integer, arg17: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V): $Map<(integer), (V)>
function of<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V): $Map<(integer), (V)>
function entry<K, V>(arg0: integer, arg1: V): $Map$Entry<(integer), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(integer), (V)>
function identity<T>(): $Function<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2ObjectMap$Type<V> = ($Int2ObjectMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2ObjectMap_<V> = $Int2ObjectMap$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/$BidirectionalIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export interface $BidirectionalIterator<K> extends $Iterator<(K)> {

 "hasPrevious"(): boolean
 "previous"(): K
 "remove"(): void
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "hasNext"(): boolean
 "next"(): K
}

export namespace $BidirectionalIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $BidirectionalIterator$Type<K> = ($BidirectionalIterator<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $BidirectionalIterator_<K> = $BidirectionalIterator$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Object2IntFunction<K> extends $Function$0<(K), (integer)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): integer
 "put"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: integer): integer
 "getInt"(arg0: any): integer
 "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2IntFunction
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Object2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2IntFunction
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Object2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$Type): $Object2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2IntFunction<(T)>
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Object2ByteFunction<(K)>
 "defaultReturnValue"(): integer
 "defaultReturnValue"(arg0: integer): void
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2IntFunction
 "removeInt"(arg0: any): integer
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): integer
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (integer)>

(arg0: any): integer
}

export namespace $Object2IntFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2IntFunction$Type<K> = ($Object2IntFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2IntFunction_<K> = $Object2IntFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$Type} from "packages/java/util/function/$IntToDoubleFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Short2FloatFunction extends $Function$0<(short), (float)>, $IntToDoubleFunction {

 "remove"(arg0: short): float
 "get"(arg0: short): float
 "put"(arg0: short, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: float): float
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: short, arg1: float): float
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(short), (T)>
 "andThenDouble"(arg0: $Float2DoubleFunction$Type): $Short2DoubleFunction
 "composeChar"(arg0: $Char2ShortFunction$Type): $Char2FloatFunction
 "composeShort"(arg0: $Short2ShortFunction$Type): $Short2FloatFunction
 "andThenFloat"(arg0: $Float2FloatFunction$Type): $Short2FloatFunction
 "composeFloat"(arg0: $Float2ShortFunction$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$Type): $Short2LongFunction
 "composeLong"(arg0: $Long2ShortFunction$Type): $Long2FloatFunction
 "composeInt"(arg0: $Int2ShortFunction$Type): $Int2FloatFunction
 "andThenInt"(arg0: $Float2IntFunction$Type): $Short2IntFunction
 "composeDouble"(arg0: $Double2ShortFunction$Type): $Double2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$Type): $Short2CharFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$Type<(any)>): $Object2FloatFunction<(T)>
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$Type<(any)>): $Short2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ShortFunction$Type<(any)>): $Reference2FloatFunction<(T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$Type<(any)>): $Short2ObjectFunction<(T)>
 "andThenByte"(arg0: $Float2ByteFunction$Type): $Short2ByteFunction
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "andThenShort"(arg0: $Float2ShortFunction$Type): $Short2ShortFunction
 "composeByte"(arg0: $Byte2ShortFunction$Type): $Byte2FloatFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: short): float

(arg0: short): float
}

export namespace $Short2FloatFunction {
function identity<T>(): $Function<(short), (short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2FloatFunction$Type = ($Short2FloatFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2FloatFunction_ = $Short2FloatFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$LongToIntFunction, $LongToIntFunction$Type} from "packages/java/util/function/$LongToIntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Long2ByteFunction extends $Function$0<(long), (byte)>, $LongToIntFunction {

 "remove"(arg0: long): byte
 "get"(arg0: long): byte
 "put"(arg0: long, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: byte): byte
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: long, arg1: byte): byte
 "applyAsInt"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(long), (T)>
 "andThenDouble"(arg0: $Byte2DoubleFunction$Type): $Long2DoubleFunction
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2ByteFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2ByteFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$Type): $Long2FloatFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$Type): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2ByteFunction
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2ByteFunction
 "andThenInt"(arg0: $Byte2IntFunction$Type): $Long2IntFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$Type): $Long2CharFunction
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2ByteFunction<(T)>
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$Type<(any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2ByteFunction<(T)>
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$Type<(any)>): $Long2ObjectFunction<(T)>
 "andThenByte"(arg0: $Byte2ByteFunction$Type): $Long2ByteFunction
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "andThenShort"(arg0: $Byte2ShortFunction$Type): $Long2ShortFunction
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2ByteFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: long): byte

(arg0: long): byte
}

export namespace $Long2ByteFunction {
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ByteFunction$Type = ($Long2ByteFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ByteFunction_ = $Long2ByteFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$DoubleFunction, $DoubleFunction$Type} from "packages/java/util/function/$DoubleFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Double2ObjectFunction<V> extends $Function$0<(double), (V)>, $DoubleFunction<(V)> {

 "remove"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: V): V
 "put"(arg0: double, arg1: V): V
 "apply"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: double, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Double2DoubleFunction
 "composeChar"(arg0: $Char2DoubleFunction$Type): $Char2ObjectFunction<(V)>
 "composeShort"(arg0: $Short2DoubleFunction$Type): $Short2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Double2FloatFunction
 "composeFloat"(arg0: $Float2DoubleFunction$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Double2LongFunction
 "composeLong"(arg0: $Long2DoubleFunction$Type): $Long2ObjectFunction<(V)>
 "composeInt"(arg0: $Int2DoubleFunction$Type): $Int2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Double2IntFunction
 "composeDouble"(arg0: $Double2DoubleFunction$Type): $Double2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Double2CharFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Double2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2DoubleFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Double2ObjectFunction<(T)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Double2ByteFunction
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Double2ShortFunction
 "composeByte"(arg0: $Byte2DoubleFunction$Type): $Byte2ObjectFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: double): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(double), (V)>

(arg0: double): V
}

export namespace $Double2ObjectFunction {
function identity<T>(): $Function<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2ObjectFunction$Type<V> = ($Double2ObjectFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2ObjectFunction_<V> = $Double2ObjectFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ReferenceCollection" {
import {$ObjectIterable, $ObjectIterable$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectIterable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ObjectSpliterator, $ObjectSpliterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSpliterator"

export interface $ReferenceCollection<K> extends $Collection<(K)>, $ObjectIterable<(K)> {

 "spliterator"(): $ObjectSpliterator<(K)>
 "add"(arg0: K): boolean
 "remove"(arg0: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "stream"(): $Stream<(K)>
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $ReferenceCollection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReferenceCollection$Type<K> = ($ReferenceCollection<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReferenceCollection_<K> = $ReferenceCollection$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$AbstractObjectCollection" {
import {$ObjectCollection, $ObjectCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectCollection"
import {$ObjectIterator, $ObjectIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectIterator"
import {$AbstractCollection, $AbstractCollection$Type} from "packages/java/util/$AbstractCollection"
import {$ObjectSpliterator, $ObjectSpliterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSpliterator"

export class $AbstractObjectCollection<K> extends $AbstractCollection<(K)> implements $ObjectCollection<(K)> {


public "toString"(): string
public "iterator"(): $ObjectIterator<(K)>
public "spliterator"(): $ObjectSpliterator<(K)>
public "equals"(arg0: any): boolean
public "hashCode"(): integer
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractObjectCollection$Type<K> = ($AbstractObjectCollection<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractObjectCollection_<K> = $AbstractObjectCollection$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectIterator, $ObjectIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectIterator"
import {$BidirectionalIterator, $BidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/$BidirectionalIterator"

export interface $ObjectBidirectionalIterator<K> extends $ObjectIterator<(K)>, $BidirectionalIterator<(K)> {

 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "hasPrevious"(): boolean
 "previous"(): K
 "remove"(): void
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "hasNext"(): boolean
 "next"(): K
}

export namespace $ObjectBidirectionalIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectBidirectionalIterator$Type<K> = ($ObjectBidirectionalIterator<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectBidirectionalIterator_<K> = $ObjectBidirectionalIterator$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Short2BooleanFunction extends $Function$0<(short), (boolean)>, $IntPredicate {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "remove"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: boolean): boolean
 "put"(arg0: short, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
 "getOrDefault"(arg0: short, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(short), (T)>
 "andThenDouble"(arg0: $Boolean2DoubleFunction$Type): $Short2DoubleFunction
 "composeChar"(arg0: $Char2ShortFunction$Type): $Char2BooleanFunction
 "composeShort"(arg0: $Short2ShortFunction$Type): $Short2BooleanFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$Type): $Short2FloatFunction
 "composeFloat"(arg0: $Float2ShortFunction$Type): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$Type): $Short2LongFunction
 "composeLong"(arg0: $Long2ShortFunction$Type): $Long2BooleanFunction
 "composeInt"(arg0: $Int2ShortFunction$Type): $Int2BooleanFunction
 "andThenInt"(arg0: $Boolean2IntFunction$Type): $Short2IntFunction
 "composeDouble"(arg0: $Double2ShortFunction$Type): $Double2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$Type): $Short2CharFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$Type<(any)>): $Object2BooleanFunction<(T)>
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$Type<(any)>): $Short2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ShortFunction$Type<(any)>): $Reference2BooleanFunction<(T)>
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$Type<(any)>): $Short2ObjectFunction<(T)>
 "andThenByte"(arg0: $Boolean2ByteFunction$Type): $Short2ByteFunction
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "andThenShort"(arg0: $Boolean2ShortFunction$Type): $Short2ShortFunction
 "composeByte"(arg0: $Byte2ShortFunction$Type): $Byte2BooleanFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: short): boolean
 "or"(arg0: $IntPredicate$Type): $IntPredicate
 "and"(arg0: $IntPredicate$Type): $IntPredicate
 "negate"(): $IntPredicate

(arg0: any): boolean
}

export namespace $Short2BooleanFunction {
function identity<T>(): $Function<(short), (short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2BooleanFunction$Type = ($Short2BooleanFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2BooleanFunction_ = $Short2BooleanFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Function, $Function$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$DoubleUnaryOperator, $DoubleUnaryOperator$Type} from "packages/java/util/function/$DoubleUnaryOperator"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/java/util/function/$Function"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"

export interface $Double2DoubleFunction extends $Function<(double), (double)>, $DoubleUnaryOperator {

 "remove"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): double
 "get"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: double): double
 "put"(arg0: double, arg1: double): double
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: double, arg1: double): double
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "applyAsDouble"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(double), (T)>
 "andThenDouble"(arg0: $Double2DoubleFunction$Type): $Double2DoubleFunction
 "composeChar"(arg0: $Char2DoubleFunction$Type): $Char2DoubleFunction
 "composeShort"(arg0: $Short2DoubleFunction$Type): $Short2DoubleFunction
 "andThenFloat"(arg0: $Double2FloatFunction$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2DoubleFunction$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$Type): $Double2LongFunction
 "composeLong"(arg0: $Long2DoubleFunction$Type): $Long2DoubleFunction
 "composeInt"(arg0: $Int2DoubleFunction$Type): $Int2DoubleFunction
 "andThenInt"(arg0: $Double2IntFunction$Type): $Double2IntFunction
 "composeDouble"(arg0: $Double2DoubleFunction$Type): $Double2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$Type): $Double2CharFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$Type<(any)>): $Object2DoubleFunction<(T)>
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$Type<(any)>): $Double2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2DoubleFunction$Type<(any)>): $Reference2DoubleFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$Type<(any)>): $Double2ObjectFunction<(T)>
 "andThenByte"(arg0: $Double2ByteFunction$Type): $Double2ByteFunction
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenShort"(arg0: $Double2ShortFunction$Type): $Double2ShortFunction
 "composeByte"(arg0: $Byte2DoubleFunction$Type): $Byte2DoubleFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: double): double
 "compose"(arg0: $DoubleUnaryOperator$Type): $DoubleUnaryOperator
 "andThen"(arg0: $DoubleUnaryOperator$Type): $DoubleUnaryOperator

(arg0: double): double
}

export namespace $Double2DoubleFunction {
function identity(): $Double2DoubleFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2DoubleFunction$Type = ($Double2DoubleFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2DoubleFunction_ = $Double2DoubleFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2IntMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Object2IntMap$Entry<K> extends $Map$Entry<(K), (integer)> {

/**
 * 
 * @deprecated
 */
 "getValue"(): integer
/**
 * 
 * @deprecated
 */
 "setValue"(arg0: integer): integer
 "setValue"(arg0: integer): integer
 "getIntValue"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "getKey"(): K
}

export namespace $Object2IntMap$Entry {
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(K), (integer)>)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (integer)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(K), (integer)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (integer)>)>
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(K), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2IntMap$Entry$Type<K> = ($Object2IntMap$Entry<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2IntMap$Entry_<K> = $Object2IntMap$Entry$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"

export interface $Int2BooleanFunction extends $Function$0<(integer), (boolean)>, $IntPredicate {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "remove"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: boolean): boolean
 "put"(arg0: integer, arg1: boolean): boolean
 "test"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
 "getOrDefault"(arg0: integer, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (T)>
 "andThenDouble"(arg0: $Boolean2DoubleFunction$Type): $Int2DoubleFunction
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2BooleanFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2BooleanFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$Type): $Int2FloatFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$Type): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2BooleanFunction
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2BooleanFunction
 "andThenInt"(arg0: $Boolean2IntFunction$Type): $Int2IntFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$Type): $Int2CharFunction
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2BooleanFunction<(T)>
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$Type<(any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2BooleanFunction<(T)>
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$Type<(any)>): $Int2ObjectFunction<(T)>
 "andThenByte"(arg0: $Boolean2ByteFunction$Type): $Int2ByteFunction
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "andThenShort"(arg0: $Boolean2ShortFunction$Type): $Int2ShortFunction
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2BooleanFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: integer): boolean
 "or"(arg0: $IntPredicate$Type): $IntPredicate
 "and"(arg0: $IntPredicate$Type): $IntPredicate
 "negate"(): $IntPredicate

(arg0: any): boolean
}

export namespace $Int2BooleanFunction {
function identity<T>(): $Function<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2BooleanFunction$Type = ($Int2BooleanFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2BooleanFunction_ = $Int2BooleanFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$FloatPredicate" {
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$DoublePredicate, $DoublePredicate$Type} from "packages/java/util/function/$DoublePredicate"

export interface $FloatPredicate extends $Predicate<(float)>, $DoublePredicate {

/**
 * 
 * @deprecated
 */
 "test"(arg0: float): boolean
 "test"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: double): boolean
 "or"(arg0: $FloatPredicate$Type): $FloatPredicate
 "or"(arg0: $DoublePredicate$Type): $FloatPredicate
/**
 * 
 * @deprecated
 */
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(float)>
 "and"(arg0: $FloatPredicate$Type): $FloatPredicate
/**
 * 
 * @deprecated
 */
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(float)>
 "negate"(): $FloatPredicate

(arg0: float): boolean
}

export namespace $FloatPredicate {
function isEqual<T>(arg0: any): $Predicate<(float)>
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatPredicate$Type = ($FloatPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatPredicate_ = $FloatPredicate$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$DoubleFunction, $DoubleFunction$Type} from "packages/java/util/function/$DoubleFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Float2ObjectFunction<V> extends $Function$0<(float), (V)>, $DoubleFunction<(V)> {

 "remove"(arg0: float): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: float): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: V): V
 "put"(arg0: float, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: float, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Float2DoubleFunction
 "composeChar"(arg0: $Char2FloatFunction$Type): $Char2ObjectFunction<(V)>
 "composeShort"(arg0: $Short2FloatFunction$Type): $Short2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Float2FloatFunction
 "composeFloat"(arg0: $Float2FloatFunction$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Float2LongFunction
 "composeLong"(arg0: $Long2FloatFunction$Type): $Long2ObjectFunction<(V)>
 "composeInt"(arg0: $Int2FloatFunction$Type): $Int2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Float2IntFunction
 "composeDouble"(arg0: $Double2FloatFunction$Type): $Double2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Float2CharFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Float2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2FloatFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Float2ObjectFunction<(T)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Float2ByteFunction
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Float2ShortFunction
 "composeByte"(arg0: $Byte2FloatFunction$Type): $Byte2ObjectFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: float): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(float), (V)>

(arg0: float): V
}

export namespace $Float2ObjectFunction {
function identity<T>(): $Function<(float), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2ObjectFunction$Type<V> = ($Float2ObjectFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2ObjectFunction_<V> = $Float2ObjectFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$DoubleToIntFunction, $DoubleToIntFunction$Type} from "packages/java/util/function/$DoubleToIntFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"

export interface $Double2IntFunction extends $Function$0<(double), (integer)>, $DoubleToIntFunction {

 "remove"(arg0: double): integer
 "get"(arg0: double): integer
 "put"(arg0: double, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: integer): integer
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: double, arg1: integer): integer
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(double), (T)>
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Double2DoubleFunction
 "composeChar"(arg0: $Char2DoubleFunction$Type): $Char2IntFunction
 "composeShort"(arg0: $Short2DoubleFunction$Type): $Short2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2DoubleFunction$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$Type): $Double2LongFunction
 "composeLong"(arg0: $Long2DoubleFunction$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2DoubleFunction$Type): $Int2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Double2IntFunction
 "composeDouble"(arg0: $Double2DoubleFunction$Type): $Double2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$Type): $Double2CharFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$Type<(any)>): $Object2IntFunction<(T)>
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Double2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2DoubleFunction$Type<(any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Double2ObjectFunction<(T)>
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Double2ByteFunction
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Double2ShortFunction
 "composeByte"(arg0: $Byte2DoubleFunction$Type): $Byte2IntFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: double): integer

(arg0: double): integer
}

export namespace $Double2IntFunction {
function identity<T>(): $Function<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2IntFunction$Type = ($Double2IntFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2IntFunction_ = $Double2IntFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleMap" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$DoubleBinaryOperator, $DoubleBinaryOperator$Type} from "packages/java/util/function/$DoubleBinaryOperator"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$DoubleBinaryOperator as $DoubleBinaryOperator$0, $DoubleBinaryOperator$Type as $DoubleBinaryOperator$0$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleBinaryOperator"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$IntToDoubleFunction, $IntToDoubleFunction$Type} from "packages/java/util/function/$IntToDoubleFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Int2DoubleMap$Entry, $Int2DoubleMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleMap$Entry"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Int2DoubleMap extends $Int2DoubleFunction, $Map<(integer), (double)> {

 "remove"(arg0: integer, arg1: double): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: double): double
 "clear"(): void
 "replace"(arg0: integer, arg1: double, arg2: double): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: integer, arg1: double, arg2: double): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: integer, arg1: double): double
 "replace"(arg0: integer, arg1: double): double
 "size"(): integer
 "merge"(arg0: integer, arg1: double, arg2: $BiFunction$Type<(any), (any), (any)>): double
/**
 * 
 * @deprecated
 */
 "merge"(arg0: integer, arg1: double, arg2: $BiFunction$Type<(any), (any), (any)>): double
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(integer), (double)>)>
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: integer, arg1: double): double
 "putIfAbsent"(arg0: integer, arg1: double): double
/**
 * 
 * @deprecated
 */
 "compute"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): double
 "compute"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): double
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: integer, arg1: $IntToDoubleFunction$Type): double
/**
 * 
 * @deprecated
 */
 "computeIfAbsent"(arg0: integer, arg1: $Function$Type<(any), (any)>): double
 "computeIfAbsent"(arg0: integer, arg1: $Int2DoubleFunction$Type): double
 "containsValue"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "getOrDefault"(arg0: integer, arg1: double): double
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): double
/**
 * 
 * @deprecated
 */
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): double
 "computeIfAbsentNullable"(arg0: integer, arg1: $IntFunction$Type<(any)>): double
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: integer, arg1: $Int2DoubleFunction$Type): double
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "mergeDouble"(arg0: integer, arg1: double, arg2: $DoubleBinaryOperator$Type): double
 "mergeDouble"(arg0: integer, arg1: double, arg2: $DoubleBinaryOperator$0$Type): double
 "int2DoubleEntrySet"(): $ObjectSet<($Int2DoubleMap$Entry)>
 "remove"(arg0: integer): double
 "get"(arg0: integer): double
 "put"(arg0: integer, arg1: double): double
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (T)>
 "andThenDouble"(arg0: $Double2DoubleFunction$Type): $Int2DoubleFunction
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2DoubleFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2DoubleFunction
 "andThenFloat"(arg0: $Double2FloatFunction$Type): $Int2FloatFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$Type): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2DoubleFunction
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2DoubleFunction
 "andThenInt"(arg0: $Double2IntFunction$Type): $Int2IntFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$Type): $Int2CharFunction
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2DoubleFunction<(T)>
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$Type<(any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2DoubleFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$Type<(any)>): $Int2ObjectFunction<(T)>
 "andThenByte"(arg0: $Double2ByteFunction$Type): $Int2ByteFunction
 "andThenShort"(arg0: $Double2ShortFunction$Type): $Int2ShortFunction
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2DoubleFunction
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "apply"(arg0: integer): double
}

export namespace $Int2DoubleMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double): $Map<(integer), (double)>
function of<K, V>(): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double, arg10: integer, arg11: double, arg12: integer, arg13: double, arg14: integer, arg15: double, arg16: integer, arg17: double, arg18: integer, arg19: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double, arg10: integer, arg11: double, arg12: integer, arg13: double, arg14: integer, arg15: double, arg16: integer, arg17: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double, arg10: integer, arg11: double, arg12: integer, arg13: double, arg14: integer, arg15: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double, arg10: integer, arg11: double, arg12: integer, arg13: double): $Map<(integer), (double)>
function of<K, V>(arg0: integer, arg1: double, arg2: integer, arg3: double, arg4: integer, arg5: double, arg6: integer, arg7: double, arg8: integer, arg9: double, arg10: integer, arg11: double): $Map<(integer), (double)>
function entry<K, V>(arg0: integer, arg1: double): $Map$Entry<(integer), (double)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(integer), (double)>
function identity<T>(): $Function<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2DoubleMap$Type = ($Int2DoubleMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2DoubleMap_ = $Int2DoubleMap$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$DoubleUnaryOperator, $DoubleUnaryOperator$Type} from "packages/java/util/function/$DoubleUnaryOperator"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"

export interface $Double2FloatFunction extends $Function$0<(double), (float)>, $DoubleUnaryOperator {

 "remove"(arg0: double): float
 "get"(arg0: double): float
 "put"(arg0: double, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: float): float
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: double, arg1: float): float
 "applyAsDouble"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(double), (T)>
 "andThenDouble"(arg0: $Float2DoubleFunction$Type): $Double2DoubleFunction
 "composeChar"(arg0: $Char2DoubleFunction$Type): $Char2FloatFunction
 "composeShort"(arg0: $Short2DoubleFunction$Type): $Short2FloatFunction
 "andThenFloat"(arg0: $Float2FloatFunction$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2DoubleFunction$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$Type): $Double2LongFunction
 "composeLong"(arg0: $Long2DoubleFunction$Type): $Long2FloatFunction
 "composeInt"(arg0: $Int2DoubleFunction$Type): $Int2FloatFunction
 "andThenInt"(arg0: $Float2IntFunction$Type): $Double2IntFunction
 "composeDouble"(arg0: $Double2DoubleFunction$Type): $Double2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$Type): $Double2CharFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$Type<(any)>): $Object2FloatFunction<(T)>
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$Type<(any)>): $Double2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2DoubleFunction$Type<(any)>): $Reference2FloatFunction<(T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$Type<(any)>): $Double2ObjectFunction<(T)>
 "andThenByte"(arg0: $Float2ByteFunction$Type): $Double2ByteFunction
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "andThenShort"(arg0: $Float2ShortFunction$Type): $Double2ShortFunction
 "composeByte"(arg0: $Byte2DoubleFunction$Type): $Byte2FloatFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: double): float
 "compose"(arg0: $DoubleUnaryOperator$Type): $DoubleUnaryOperator
 "andThen"(arg0: $DoubleUnaryOperator$Type): $DoubleUnaryOperator

(arg0: double): float
}

export namespace $Double2FloatFunction {
function identity(): $DoubleUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2FloatFunction$Type = ($Double2FloatFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2FloatFunction_ = $Double2FloatFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Object2ReferenceMap$Entry<K, V> extends $Map$Entry<(K), (V)> {

 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "getValue"(): V
 "getKey"(): K
 "setValue"(arg0: V): V
}

export namespace $Object2ReferenceMap$Entry {
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(K), (V)>)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (V)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(K), (V)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (V)>)>
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ReferenceMap$Entry$Type<K, V> = ($Object2ReferenceMap$Entry<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ReferenceMap$Entry_<K, V> = $Object2ReferenceMap$Entry$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortComparator" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$ToLongFunction, $ToLongFunction$Type} from "packages/java/util/function/$ToLongFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"

export interface $ShortComparator extends $Comparator<(short)> {

/**
 * 
 * @deprecated
 */
 "compare"(arg0: short, arg1: short): integer
 "compare"(arg0: short, arg1: short): integer
 "thenComparing"(arg0: $Comparator$Type<(any)>): $Comparator<(short)>
 "thenComparing"(arg0: $ShortComparator$Type): $ShortComparator
 "reversed"(): $ShortComparator
 "equals"(arg0: any): boolean
 "thenComparing"<U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(short)>
 "thenComparing"<U extends $Comparable<(any)>>(arg0: $Function$Type<(any), (any)>): $Comparator<(short)>
 "thenComparingInt"(arg0: $ToIntFunction$Type<(any)>): $Comparator<(short)>
 "thenComparingLong"(arg0: $ToLongFunction$Type<(any)>): $Comparator<(short)>
 "thenComparingDouble"(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(short)>
}

export namespace $ShortComparator {
function reverseOrder<T>(): $Comparator<(short)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>): $Comparator<(short)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(short)>
function comparingInt<T>(arg0: $ToIntFunction$Type<(any)>): $Comparator<(short)>
function comparingLong<T>(arg0: $ToLongFunction$Type<(any)>): $Comparator<(short)>
function comparingDouble<T>(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(short)>
function naturalOrder<T>(): $Comparator<(short)>
function nullsFirst<T>(arg0: $Comparator$Type<(any)>): $Comparator<(short)>
function nullsLast<T>(arg0: $Comparator$Type<(any)>): $Comparator<(short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortComparator$Type = ($ShortComparator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortComparator_ = $ShortComparator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortConsumer" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"

export interface $ShortConsumer extends $Consumer<(short)>, $IntConsumer {

/**
 * 
 * @deprecated
 */
 "accept"(arg0: short): void
/**
 * 
 * @deprecated
 */
 "accept"(arg0: integer): void
 "accept"(arg0: short): void
/**
 * 
 * @deprecated
 */
 "andThen"(arg0: $Consumer$Type<(any)>): $Consumer<(short)>
 "andThen"(arg0: $ShortConsumer$Type): $ShortConsumer

(arg0: short): void
}

export namespace $ShortConsumer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortConsumer$Type = ($ShortConsumer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortConsumer_ = $ShortConsumer$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectOpenHashMap" {
import {$AbstractLong2ObjectMap, $AbstractLong2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/longs/$AbstractLong2ObjectMap"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$LongFunction, $LongFunction$Type} from "packages/java/util/function/$LongFunction"
import {$Hash, $Hash$Type} from "packages/it/unimi/dsi/fastutil/$Hash"
import {$LongSet, $LongSet$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSet"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Long2ObjectMap, $Long2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap"
import {$Long2ObjectMap$FastEntrySet, $Long2ObjectMap$FastEntrySet$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap$FastEntrySet"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $Long2ObjectOpenHashMap<V> extends $AbstractLong2ObjectMap<(V)> implements $Serializable, $Cloneable, $Hash {

constructor(arg0: $Map$Type<(any), (any)>)
constructor(arg0: $Long2ObjectMap$Type<(V)>, arg1: float)
constructor(arg0: $Long2ObjectMap$Type<(V)>)
constructor(arg0: (long)[], arg1: (V)[], arg2: float)
constructor(arg0: (long)[], arg1: (V)[])
constructor(arg0: integer, arg1: float)
constructor(arg0: integer)
constructor()
constructor(arg0: $Map$Type<(any), (any)>, arg1: float)

public "remove"(arg0: long, arg1: any): boolean
public "remove"(arg0: long): V
public "get"(arg0: long): V
public "put"(arg0: long, arg1: V): V
public "hashCode"(): integer
public "clear"(): void
public "isEmpty"(): boolean
public "replace"(arg0: long, arg1: V, arg2: V): boolean
public "replace"(arg0: long, arg1: V): V
public "size"(): integer
public "trim"(): boolean
public "trim"(arg0: integer): boolean
public "merge"(arg0: long, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "putIfAbsent"(arg0: long, arg1: V): V
public "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "containsKey"(arg0: long): boolean
public "computeIfAbsent"(arg0: long, arg1: $LongFunction$Type<(any)>): V
public "computeIfAbsent"(arg0: long, arg1: $Long2ObjectFunction$Type<(any)>): V
public "keySet"(): $LongSet
public "containsValue"(arg0: any): boolean
public "getOrDefault"(arg0: long, arg1: V): V
public "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "long2ObjectEntrySet"(): $Long2ObjectMap$FastEntrySet<(V)>
public "defaultReturnValue"(): V
public "defaultReturnValue"(arg0: V): void
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ObjectOpenHashMap$Type<V> = ($Long2ObjectOpenHashMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ObjectOpenHashMap_<V> = $Long2ObjectOpenHashMap$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Long2ObjectMap$Entry<V> extends $Map$Entry<(long), (V)> {

/**
 * 
 * @deprecated
 */
 "getKey"(): long
 "getLongKey"(): long
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "getValue"(): V
 "setValue"(arg0: V): V
}

export namespace $Long2ObjectMap$Entry {
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(long), (V)>)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(long), (V)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(long), (V)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(long), (V)>)>
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(long), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ObjectMap$Entry$Type<V> = ($Long2ObjectMap$Entry<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ObjectMap$Entry_<V> = $Long2ObjectMap$Entry$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectLinkedOpenHashMap" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$LongFunction, $LongFunction$Type} from "packages/java/util/function/$LongFunction"
import {$Hash, $Hash$Type} from "packages/it/unimi/dsi/fastutil/$Hash"
import {$Long2ObjectSortedMap, $Long2ObjectSortedMap$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectSortedMap"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$AbstractLong2ObjectSortedMap, $AbstractLong2ObjectSortedMap$Type} from "packages/it/unimi/dsi/fastutil/longs/$AbstractLong2ObjectSortedMap"
import {$Long2ObjectMap, $Long2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap"
import {$LongSortedSet, $LongSortedSet$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSortedSet"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $Long2ObjectLinkedOpenHashMap<V> extends $AbstractLong2ObjectSortedMap<(V)> implements $Serializable, $Cloneable, $Hash {

constructor(arg0: $Map$Type<(any), (any)>)
constructor(arg0: $Long2ObjectMap$Type<(V)>, arg1: float)
constructor(arg0: $Long2ObjectMap$Type<(V)>)
constructor(arg0: (long)[], arg1: (V)[], arg2: float)
constructor(arg0: (long)[], arg1: (V)[])
constructor(arg0: integer, arg1: float)
constructor(arg0: integer)
constructor()
constructor(arg0: $Map$Type<(any), (any)>, arg1: float)

public "remove"(arg0: long): V
public "remove"(arg0: long, arg1: any): boolean
public "get"(arg0: long): V
public "put"(arg0: long, arg1: V): V
public "hashCode"(): integer
public "clone"(): $Long2ObjectLinkedOpenHashMap<(V)>
public "clear"(): void
public "isEmpty"(): boolean
public "replace"(arg0: long, arg1: V, arg2: V): boolean
public "replace"(arg0: long, arg1: V): V
public "size"(): integer
public "trim"(): boolean
public "trim"(arg0: integer): boolean
public "merge"(arg0: long, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "putIfAbsent"(arg0: long, arg1: V): V
public "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "containsKey"(arg0: long): boolean
public "computeIfAbsent"(arg0: long, arg1: $Long2ObjectFunction$Type<(any)>): V
public "computeIfAbsent"(arg0: long, arg1: $LongFunction$Type<(any)>): V
public "keySet"(): $LongSortedSet
public "containsValue"(arg0: any): boolean
public "getOrDefault"(arg0: long, arg1: V): V
public "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "removeFirst"(): V
public "removeLast"(): V
public "subMap"(arg0: long, arg1: long): $Long2ObjectSortedMap<(V)>
public "headMap"(arg0: long): $Long2ObjectSortedMap<(V)>
public "tailMap"(arg0: long): $Long2ObjectSortedMap<(V)>
public "firstLongKey"(): long
public "lastLongKey"(): long
public "getAndMoveToFirst"(arg0: long): V
public "getAndMoveToLast"(arg0: long): V
public "putAndMoveToLast"(arg0: long, arg1: V): V
public "putAndMoveToFirst"(arg0: long, arg1: V): V
public "defaultReturnValue"(): V
public "defaultReturnValue"(arg0: V): void
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ObjectLinkedOpenHashMap$Type<V> = ($Long2ObjectLinkedOpenHashMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ObjectLinkedOpenHashMap_<V> = $Long2ObjectLinkedOpenHashMap$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"

export interface $Boolean2IntFunction extends $Function$0<(boolean), (integer)> {

 "remove"(arg0: boolean): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): integer
 "get"(arg0: boolean): integer
 "put"(arg0: boolean, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: integer): integer
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: boolean, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(boolean), (T)>
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Boolean2DoubleFunction
 "composeChar"(arg0: $Char2BooleanFunction$Type): $Char2IntFunction
 "composeShort"(arg0: $Short2BooleanFunction$Type): $Short2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Boolean2FloatFunction
 "composeFloat"(arg0: $Float2BooleanFunction$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$Type): $Boolean2LongFunction
 "composeLong"(arg0: $Long2BooleanFunction$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2BooleanFunction$Type): $Int2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Boolean2IntFunction
 "composeDouble"(arg0: $Double2BooleanFunction$Type): $Double2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$Type): $Boolean2CharFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$Type<(any)>): $Object2IntFunction<(T)>
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Boolean2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2BooleanFunction$Type<(any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Boolean2ObjectFunction<(T)>
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Boolean2ByteFunction
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Boolean2ShortFunction
 "composeByte"(arg0: $Byte2BooleanFunction$Type): $Byte2IntFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: boolean): integer

(arg0: boolean): integer
}

export namespace $Boolean2IntFunction {
function identity<T>(): $Function<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2IntFunction$Type = ($Boolean2IntFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2IntFunction_ = $Boolean2IntFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoubleSpliterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleConsumer"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$Type as $DoubleConsumer$0$Type} from "packages/java/util/function/$DoubleConsumer"
import {$Spliterator$OfDouble, $Spliterator$OfDouble$Type} from "packages/java/util/$Spliterator$OfDouble"

export interface $DoubleSpliterator extends $Spliterator$OfDouble {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $DoubleConsumer$Type): void
 "skip"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "tryAdvance"(arg0: $Consumer$Type<(any)>): boolean
 "tryAdvance"(arg0: $DoubleConsumer$Type): boolean
 "forEachRemaining"(arg0: $DoubleConsumer$0$Type): void
 "tryAdvance"(arg0: $DoubleConsumer$0$Type): boolean
 "characteristics"(): integer
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
}

export namespace $DoubleSpliterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleSpliterator$Type = ($DoubleSpliterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleSpliterator_ = $DoubleSpliterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Byte2CharFunction extends $Function$0<(byte), (character)>, $IntUnaryOperator {

 "remove"(arg0: byte): character
 "get"(arg0: byte): character
 "put"(arg0: byte, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: character): character
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: byte, arg1: character): character
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(byte), (T)>
 "andThenDouble"(arg0: $Char2DoubleFunction$Type): $Byte2DoubleFunction
 "composeChar"(arg0: $Char2ByteFunction$Type): $Char2CharFunction
 "composeShort"(arg0: $Short2ByteFunction$Type): $Short2CharFunction
 "andThenFloat"(arg0: $Char2FloatFunction$Type): $Byte2FloatFunction
 "composeFloat"(arg0: $Float2ByteFunction$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$Type): $Byte2LongFunction
 "composeLong"(arg0: $Long2ByteFunction$Type): $Long2CharFunction
 "composeInt"(arg0: $Int2ByteFunction$Type): $Int2CharFunction
 "andThenInt"(arg0: $Char2IntFunction$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2ByteFunction$Type): $Double2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$Type): $Byte2CharFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$Type<(any)>): $Object2CharFunction<(T)>
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$Type<(any)>): $Byte2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ByteFunction$Type<(any)>): $Reference2CharFunction<(T)>
 "andThenObject"<T>(arg0: $Char2ObjectFunction$Type<(any)>): $Byte2ObjectFunction<(T)>
 "andThenByte"(arg0: $Char2ByteFunction$Type): $Byte2ByteFunction
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "andThenShort"(arg0: $Char2ShortFunction$Type): $Byte2ShortFunction
 "composeByte"(arg0: $Byte2ByteFunction$Type): $Byte2CharFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: byte): character
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: byte): character
}

export namespace $Byte2CharFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2CharFunction$Type = ($Byte2CharFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2CharFunction_ = $Byte2CharFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2FloatOpenHashMap" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Object2FloatMap$FastEntrySet, $Object2FloatMap$FastEntrySet$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatMap$FastEntrySet"
import {$Hash, $Hash$Type} from "packages/it/unimi/dsi/fastutil/$Hash"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Object2FloatMap, $Object2FloatMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatMap"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$AbstractObject2FloatMap, $AbstractObject2FloatMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2FloatMap"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $Object2FloatOpenHashMap<K> extends $AbstractObject2FloatMap<(K)> implements $Serializable, $Cloneable, $Hash {

constructor(arg0: $Map$Type<(any), (any)>)
constructor(arg0: $Object2FloatMap$Type<(K)>, arg1: float)
constructor(arg0: $Object2FloatMap$Type<(K)>)
constructor(arg0: (K)[], arg1: (float)[], arg2: float)
constructor(arg0: (K)[], arg1: (float)[])
constructor(arg0: integer, arg1: float)
constructor(arg0: integer)
constructor()
constructor(arg0: $Map$Type<(any), (any)>, arg1: float)

public "remove"(arg0: any, arg1: float): boolean
public "put"(arg0: K, arg1: float): float
public "hashCode"(): integer
public "getFloat"(arg0: any): float
public "clear"(): void
public "isEmpty"(): boolean
public "replace"(arg0: K, arg1: float, arg2: float): boolean
public "replace"(arg0: K, arg1: float): float
public "size"(): integer
public "trim"(arg0: integer): boolean
public "trim"(): boolean
public "merge"(arg0: K, arg1: float, arg2: $BiFunction$Type<(any), (any), (any)>): float
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "putIfAbsent"(arg0: K, arg1: float): float
public "containsKey"(arg0: any): boolean
public "computeIfAbsent"(arg0: K, arg1: $Object2FloatFunction$Type<(any)>): float
public "computeIfAbsent"(arg0: K, arg1: $ToDoubleFunction$Type<(any)>): float
public "keySet"(): $ObjectSet<(K)>
public "containsValue"(arg0: float): boolean
public "getOrDefault"(arg0: any, arg1: float): float
public "addTo"(arg0: K, arg1: float): float
public "removeFloat"(arg0: any): float
public "computeFloatIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): float
public "object2FloatEntrySet"(): $Object2FloatMap$FastEntrySet<(K)>
public "computeFloat"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): float
public "defaultReturnValue"(arg0: float): void
public "defaultReturnValue"(): float
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2FloatOpenHashMap$Type<K> = ($Object2FloatOpenHashMap<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2FloatOpenHashMap_<K> = $Object2FloatOpenHashMap$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoubleConsumer" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$Type as $DoubleConsumer$0$Type} from "packages/java/util/function/$DoubleConsumer"

export interface $DoubleConsumer extends $Consumer<(double)>, $DoubleConsumer$0 {

/**
 * 
 * @deprecated
 */
 "accept"(arg0: double): void
/**
 * 
 * @deprecated
 */
 "andThen"(arg0: $Consumer$Type<(any)>): $Consumer<(double)>
 "andThen"(arg0: $DoubleConsumer$Type): $DoubleConsumer
 "accept"(arg0: double): void

(arg0: double): void
}

export namespace $DoubleConsumer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleConsumer$Type = ($DoubleConsumer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleConsumer_ = $DoubleConsumer$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$FloatIterator" {
import {$FloatConsumer, $FloatConsumer$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatConsumer"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/java/util/function/$DoubleConsumer"
import {$PrimitiveIterator, $PrimitiveIterator$Type} from "packages/java/util/$PrimitiveIterator"

export interface $FloatIterator extends $PrimitiveIterator<(float), ($FloatConsumer)> {

 "forEachRemaining"(arg0: $DoubleConsumer$Type): void
 "forEachRemaining"(arg0: $FloatConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "skip"(arg0: integer): integer
 "nextFloat"(): float
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $FloatIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatIterator$Type = ($FloatIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatIterator_ = $FloatIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2ObjectSortedMap" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Object2ObjectMap$Entry, $Object2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap$Entry"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ObjectSortedSet, $ObjectSortedSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSortedSet"
import {$Object2ObjectSortedMap, $Object2ObjectSortedMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectSortedMap"
import {$AbstractObject2ObjectMap, $AbstractObject2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2ObjectMap"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $AbstractObject2ObjectSortedMap<K, V> extends $AbstractObject2ObjectMap<(K), (V)> implements $Object2ObjectSortedMap<(K), (V)> {


public "comparator"(): $Comparator<(any)>
public "object2ObjectEntrySet"(): $ObjectSortedSet<($Object2ObjectMap$Entry<(K), (V)>)>
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public "firstKey"(): K
public "lastKey"(): K
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractObject2ObjectSortedMap$Type<K, V> = ($AbstractObject2ObjectSortedMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractObject2ObjectSortedMap_<K, V> = $AbstractObject2ObjectSortedMap$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$ShortPredicate, $ShortPredicate$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortPredicate"
import {$ShortComparator, $ShortComparator$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortComparator"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ShortSpliterator, $ShortSpliterator$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortSpliterator"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ShortConsumer, $ShortConsumer$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortConsumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$ShortListIterator, $ShortListIterator$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortListIterator"
import {$ShortUnaryOperator, $ShortUnaryOperator$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortUnaryOperator"
import {$ShortCollection, $ShortCollection$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortCollection"

export interface $ShortList extends $List<(short)>, $Comparable<($List<(any)>)>, $ShortCollection {

 "add"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: short): void
 "add"(arg0: integer, arg1: short): void
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: integer): short
 "indexOf"(arg0: short): integer
/**
 * 
 * @deprecated
 */
 "indexOf"(arg0: any): integer
 "getShort"(arg0: integer): short
/**
 * 
 * @deprecated
 */
 "lastIndexOf"(arg0: any): integer
 "lastIndexOf"(arg0: short): integer
 "replaceAll"(arg0: $IntUnaryOperator$Type): void
 "replaceAll"(arg0: $ShortUnaryOperator$Type): void
/**
 * 
 * @deprecated
 */
 "replaceAll"(arg0: $UnaryOperator$Type<(short)>): void
 "size"(arg0: integer): void
 "iterator"(): $ShortListIterator
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $ShortSpliterator
 "addAll"(arg0: $ShortList$Type): boolean
 "addAll"(arg0: integer, arg1: $ShortCollection$Type): boolean
 "addAll"(arg0: integer, arg1: $ShortList$Type): boolean
 "set"(arg0: integer, arg1: short): short
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: short): short
/**
 * 
 * @deprecated
 */
 "sort"(arg0: $Comparator$Type<(any)>): void
 "sort"(arg0: $ShortComparator$Type): void
/**
 * 
 * @deprecated
 */
 "unstableSort"(arg0: $Comparator$Type<(any)>): void
 "unstableSort"(arg0: $ShortComparator$Type): void
 "addElements"(arg0: integer, arg1: (short)[]): void
 "addElements"(arg0: integer, arg1: (short)[], arg2: integer, arg3: integer): void
 "removeElements"(arg0: integer, arg1: integer): void
 "getElements"(arg0: integer, arg1: (short)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: (short)[]): void
 "setElements"(arg0: integer, arg1: (short)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (short)[]): void
 "removeShort"(arg0: integer): short
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "compareTo"(arg0: $List$Type<(any)>): integer
 "toArray"(arg0: (short)[]): (short)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(short)>
 "intStream"(): $IntStream
 "contains"(arg0: short): boolean
 "addAll"(arg0: $ShortCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $ShortPredicate$Type): boolean
 "removeIf"(arg0: $IntPredicate$Type): boolean
 "removeAll"(arg0: $ShortCollection$Type): boolean
 "retainAll"(arg0: $ShortCollection$Type): boolean
 "containsAll"(arg0: $ShortCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(short)>
 "rem"(arg0: short): boolean
 "intParallelStream"(): $IntStream
 "intSpliterator"(): $IntSpliterator
 "intIterator"(): $IntIterator
/**
 * 
 * @deprecated
 */
 "toShortArray"(arg0: (short)[]): (short)[]
 "toShortArray"(): (short)[]
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "forEach"(arg0: $ShortConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $IntConsumer$Type): void
}

export namespace $ShortList {
function of(): $ShortList
function of(arg0: short): $ShortList
function of(arg0: short, arg1: short): $ShortList
function of(arg0: short, arg1: short, arg2: short): $ShortList
function of(...arg0: (short)[]): $ShortList
function copyOf<E>(arg0: $Collection$Type<(any)>): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short): $List<(short)>
function of<E>(arg0: short, arg1: short): $List<(short)>
function of<E>(arg0: short): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short, arg8: short, arg9: short): $List<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short, arg8: short): $List<(short)>
function of<E>(...arg0: (short)[]): $List<(short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortList$Type = ($ShortList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortList_ = $ShortList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Short2ByteFunction extends $Function$0<(short), (byte)>, $IntUnaryOperator {

 "remove"(arg0: short): byte
 "get"(arg0: short): byte
 "put"(arg0: short, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: byte): byte
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: short, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(short), (T)>
 "andThenDouble"(arg0: $Byte2DoubleFunction$Type): $Short2DoubleFunction
 "composeChar"(arg0: $Char2ShortFunction$Type): $Char2ByteFunction
 "composeShort"(arg0: $Short2ShortFunction$Type): $Short2ByteFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$Type): $Short2FloatFunction
 "composeFloat"(arg0: $Float2ShortFunction$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$Type): $Short2LongFunction
 "composeLong"(arg0: $Long2ShortFunction$Type): $Long2ByteFunction
 "composeInt"(arg0: $Int2ShortFunction$Type): $Int2ByteFunction
 "andThenInt"(arg0: $Byte2IntFunction$Type): $Short2IntFunction
 "composeDouble"(arg0: $Double2ShortFunction$Type): $Double2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$Type): $Short2CharFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$Type<(any)>): $Object2ByteFunction<(T)>
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$Type<(any)>): $Short2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ShortFunction$Type<(any)>): $Reference2ByteFunction<(T)>
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$Type<(any)>): $Short2ObjectFunction<(T)>
 "andThenByte"(arg0: $Byte2ByteFunction$Type): $Short2ByteFunction
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "andThenShort"(arg0: $Byte2ShortFunction$Type): $Short2ShortFunction
 "composeByte"(arg0: $Byte2ShortFunction$Type): $Byte2ByteFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: short): byte
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: short): byte
}

export namespace $Short2ByteFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2ByteFunction$Type = ($Short2ByteFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2ByteFunction_ = $Short2ByteFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterable" {
import {$ObjectIterable, $ObjectIterable$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectIterable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterator"
import {$ObjectSpliterator, $ObjectSpliterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSpliterator"

export interface $ObjectBidirectionalIterable<K> extends $ObjectIterable<(K)> {

 "iterator"(): $ObjectBidirectionalIterator<(K)>
 "spliterator"(): $ObjectSpliterator<(K)>
 "forEach"(arg0: $Consumer$Type<(any)>): void

(): $ObjectBidirectionalIterator<(K)>
}

export namespace $ObjectBidirectionalIterable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectBidirectionalIterable$Type<K> = ($ObjectBidirectionalIterable<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectBidirectionalIterable_<K> = $ObjectBidirectionalIterable$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$LongToDoubleFunction, $LongToDoubleFunction$Type} from "packages/java/util/function/$LongToDoubleFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"

export interface $Long2DoubleFunction extends $Function$0<(long), (double)>, $LongToDoubleFunction {

 "remove"(arg0: long): double
 "get"(arg0: long): double
 "put"(arg0: long, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: double): double
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: long, arg1: double): double
 "applyAsDouble"(arg0: long): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(long), (T)>
 "andThenDouble"(arg0: $Double2DoubleFunction$Type): $Long2DoubleFunction
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2DoubleFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2DoubleFunction
 "andThenFloat"(arg0: $Double2FloatFunction$Type): $Long2FloatFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$Type): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2DoubleFunction
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2DoubleFunction
 "andThenInt"(arg0: $Double2IntFunction$Type): $Long2IntFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$Type): $Long2CharFunction
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2DoubleFunction<(T)>
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$Type<(any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2DoubleFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$Type<(any)>): $Long2ObjectFunction<(T)>
 "andThenByte"(arg0: $Double2ByteFunction$Type): $Long2ByteFunction
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenShort"(arg0: $Double2ShortFunction$Type): $Long2ShortFunction
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2DoubleFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: long): double

(arg0: long): double
}

export namespace $Long2DoubleFunction {
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2DoubleFunction$Type = ($Long2DoubleFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2DoubleFunction_ = $Long2DoubleFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ObjectSet" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectCollection, $ObjectCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectCollection"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"

export interface $ObjectSet<K> extends $ObjectCollection<(K)>, $Set<(K)> {

 "add"(arg0: K): boolean
 "remove"(arg0: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(K)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $ObjectSet {
function of<K>(arg0: K, arg1: K): $ObjectSet<(K)>
function of<K>(...arg0: (K)[]): $ObjectSet<(K)>
function of<K>(arg0: K, arg1: K, arg2: K): $ObjectSet<(K)>
function of<K>(): $ObjectSet<(K)>
function of<K>(arg0: K): $ObjectSet<(K)>
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K, arg9: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K): $Set<(K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectSet$Type<K> = ($ObjectSet<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectSet_<K> = $ObjectSet$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Short2IntFunction extends $Function$0<(short), (integer)>, $IntUnaryOperator {

 "remove"(arg0: short): integer
 "get"(arg0: short): integer
 "put"(arg0: short, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: integer): integer
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: short, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(short), (T)>
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Short2DoubleFunction
 "composeChar"(arg0: $Char2ShortFunction$Type): $Char2IntFunction
 "composeShort"(arg0: $Short2ShortFunction$Type): $Short2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Short2FloatFunction
 "composeFloat"(arg0: $Float2ShortFunction$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$Type): $Short2LongFunction
 "composeLong"(arg0: $Long2ShortFunction$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2ShortFunction$Type): $Int2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Short2IntFunction
 "composeDouble"(arg0: $Double2ShortFunction$Type): $Double2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$Type): $Short2CharFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$Type<(any)>): $Object2IntFunction<(T)>
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Short2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ShortFunction$Type<(any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Short2ObjectFunction<(T)>
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Short2ByteFunction
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Short2ShortFunction
 "composeByte"(arg0: $Byte2ShortFunction$Type): $Byte2IntFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: short): integer
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: short): integer
}

export namespace $Short2IntFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2IntFunction$Type = ($Short2IntFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2IntFunction_ = $Short2IntFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoubleCollection" {
import {$DoublePredicate, $DoublePredicate$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoublePredicate"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleConsumer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$DoubleSpliterator, $DoubleSpliterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleSpliterator"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$Type as $DoubleConsumer$0$Type} from "packages/java/util/function/$DoubleConsumer"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$DoubleIterable, $DoubleIterable$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleIterable"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$DoubleIterator, $DoubleIterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleIterator"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$DoublePredicate as $DoublePredicate$0, $DoublePredicate$Type as $DoublePredicate$0$Type} from "packages/java/util/function/$DoublePredicate"

export interface $DoubleCollection extends $Collection<(double)>, $DoubleIterable {

 "add"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "toArray"(arg0: (double)[]): (double)[]
 "iterator"(): $DoubleIterator
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(double)>
 "contains"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "addAll"(arg0: $DoubleCollection$Type): boolean
 "removeIf"(arg0: $DoublePredicate$0$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $DoublePredicate$Type): boolean
 "removeAll"(arg0: $DoubleCollection$Type): boolean
 "retainAll"(arg0: $DoubleCollection$Type): boolean
 "containsAll"(arg0: $DoubleCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(double)>
 "rem"(arg0: double): boolean
 "doubleStream"(): $DoubleStream
 "doubleSpliterator"(): $DoubleSpliterator
 "doubleIterator"(): $DoubleIterator
/**
 * 
 * @deprecated
 */
 "toDoubleArray"(arg0: (double)[]): (double)[]
 "toDoubleArray"(): (double)[]
 "doubleParallelStream"(): $DoubleStream
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "forEach"(arg0: $DoubleConsumer$0$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $DoubleConsumer$Type): void
}

export namespace $DoubleCollection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleCollection$Type = ($DoubleCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleCollection_ = $DoubleCollection$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongListIterator" {
import {$LongBidirectionalIterator, $LongBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongBidirectionalIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$Type as $LongConsumer$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongConsumer"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"

export interface $LongListIterator extends $LongBidirectionalIterator, $ListIterator<(long)> {

/**
 * 
 * @deprecated
 */
 "add"(arg0: long): void
 "add"(arg0: long): void
 "remove"(): void
/**
 * 
 * @deprecated
 */
 "set"(arg0: long): void
 "set"(arg0: long): void
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "previousLong"(): long
 "hasNext"(): boolean
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $LongConsumer$0$Type): void
 "nextLong"(): long
 "forEachRemaining"(arg0: $LongConsumer$Type): void
}

export namespace $LongListIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongListIterator$Type = ($LongListIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongListIterator_ = $LongListIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoubleIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleConsumer"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$Type as $DoubleConsumer$0$Type} from "packages/java/util/function/$DoubleConsumer"
import {$PrimitiveIterator$OfDouble, $PrimitiveIterator$OfDouble$Type} from "packages/java/util/$PrimitiveIterator$OfDouble"

export interface $DoubleIterator extends $PrimitiveIterator$OfDouble {

 "nextDouble"(): double
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $DoubleConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "next"(): double
 "skip"(arg0: integer): integer
 "forEachRemaining"(arg0: $DoubleConsumer$0$Type): void
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $DoubleIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleIterator$Type = ($DoubleIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleIterator_ = $DoubleIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$DoubleFunction, $DoubleFunction$Type} from "packages/java/util/function/$DoubleFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Double2ReferenceFunction<V> extends $Function$0<(double), (V)>, $DoubleFunction<(V)> {

 "remove"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: V): V
 "put"(arg0: double, arg1: V): V
 "apply"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: double, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Double2DoubleFunction
 "composeChar"(arg0: $Char2DoubleFunction$Type): $Char2ReferenceFunction<(V)>
 "composeShort"(arg0: $Short2DoubleFunction$Type): $Short2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Double2FloatFunction
 "composeFloat"(arg0: $Float2DoubleFunction$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Double2LongFunction
 "composeLong"(arg0: $Long2DoubleFunction$Type): $Long2ReferenceFunction<(V)>
 "composeInt"(arg0: $Int2DoubleFunction$Type): $Int2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Double2IntFunction
 "composeDouble"(arg0: $Double2DoubleFunction$Type): $Double2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Double2CharFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$Type<(any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Double2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2DoubleFunction$Type<(any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Double2ObjectFunction<(T)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Double2ByteFunction
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Double2ShortFunction
 "composeByte"(arg0: $Byte2DoubleFunction$Type): $Byte2ReferenceFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: double): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(double), (V)>

(arg0: double): V
}

export namespace $Double2ReferenceFunction {
function identity<T>(): $Function<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2ReferenceFunction$Type<V> = ($Double2ReferenceFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2ReferenceFunction_<V> = $Double2ReferenceFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ObjectList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectCollection, $ObjectCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectCollection"
import {$ObjectListIterator, $ObjectListIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectListIterator"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"

export interface $ObjectList<K> extends $List<(K)>, $Comparable<($List<(any)>)>, $ObjectCollection<(K)> {

 "size"(arg0: integer): void
 "subList"(arg0: integer, arg1: integer): $ObjectList<(K)>
 "addAll"(arg0: $ObjectList$Type<(any)>): boolean
 "addAll"(arg0: integer, arg1: $ObjectList$Type<(any)>): boolean
 "sort"(arg0: $Comparator$Type<(any)>): void
 "listIterator"(arg0: integer): $ObjectListIterator<(K)>
 "unstableSort"(arg0: $Comparator$Type<(any)>): void
 "addElements"(arg0: integer, arg1: (K)[]): void
 "addElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
 "removeElements"(arg0: integer, arg1: integer): void
 "getElements"(arg0: integer, arg1: (any)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (K)[]): void
 "setElements"(arg0: (K)[]): void
 "setElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
 "add"(arg0: integer, arg1: K): void
 "add"(arg0: K): boolean
 "remove"(arg0: any): boolean
 "remove"(arg0: integer): K
 "get"(arg0: integer): K
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "indexOf"(arg0: any): integer
 "clear"(): void
 "lastIndexOf"(arg0: any): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $UnaryOperator$Type<(K)>): void
 "size"(): integer
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "contains"(arg0: any): boolean
 "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "set"(arg0: integer, arg1: K): K
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "compareTo"(arg0: $List$Type<(any)>): integer
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(K)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $ObjectList {
function of<K>(...arg0: (K)[]): $ObjectList<(K)>
function of<K>(arg0: K, arg1: K, arg2: K): $ObjectList<(K)>
function of<K>(arg0: K, arg1: K): $ObjectList<(K)>
function of<K>(): $ObjectList<(K)>
function of<K>(arg0: K): $ObjectList<(K)>
function copyOf<E>(arg0: $Collection$Type<(any)>): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K, arg9: K): $List<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K): $List<(K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectList$Type<K> = ($ObjectList<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectList_<K> = $ObjectList$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$LongFunction, $LongFunction$Type} from "packages/java/util/function/$LongFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Long2ReferenceFunction<V> extends $Function$0<(long), (V)>, $LongFunction<(V)> {

 "remove"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: V): V
 "put"(arg0: long, arg1: V): V
 "apply"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Long2DoubleFunction
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2ReferenceFunction<(V)>
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Long2FloatFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2ReferenceFunction<(V)>
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Long2IntFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Long2CharFunction
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Long2ObjectFunction<(T)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Long2ByteFunction
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Long2ShortFunction
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2ReferenceFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: long): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(long), (V)>

(arg0: long): V
}

export namespace $Long2ReferenceFunction {
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ReferenceFunction$Type<V> = ($Long2ReferenceFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ReferenceFunction_<V> = $Long2ReferenceFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2IntMap" {
import {$Object2IntMap$Entry, $Object2IntMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntMap$Entry"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$AbstractObject2IntFunction, $AbstractObject2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2IntFunction"
import {$IntBinaryOperator, $IntBinaryOperator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntBinaryOperator"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$IntBinaryOperator as $IntBinaryOperator$0, $IntBinaryOperator$Type as $IntBinaryOperator$0$Type} from "packages/java/util/function/$IntBinaryOperator"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Object2IntMap, $Object2IntMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntMap"

export class $AbstractObject2IntMap<K> extends $AbstractObject2IntFunction<(K)> implements $Object2IntMap<(K)>, $Serializable {


public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "isEmpty"(): boolean
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "containsKey"(arg0: any): boolean
public "containsValue"(arg0: integer): boolean
public "mergeInt"(arg0: K, arg1: integer, arg2: $IntBinaryOperator$Type): integer
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any, arg1: any): boolean
public "remove"(arg0: any, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
public "get"(arg0: any): integer
/**
 * 
 * @deprecated
 */
public "put"(arg0: K, arg1: integer): integer
public "clear"(): void
/**
 * 
 * @deprecated
 */
public "replace"(arg0: K, arg1: integer, arg2: integer): boolean
public "replace"(arg0: K, arg1: integer, arg2: integer): boolean
public "replace"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public "replace"(arg0: K, arg1: integer): integer
public "size"(): integer
public "merge"(arg0: K, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
public "merge"(arg0: K, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
public "entrySet"(): $ObjectSet<($Map$Entry<(K), (integer)>)>
/**
 * 
 * @deprecated
 */
public "putIfAbsent"(arg0: K, arg1: integer): integer
public "putIfAbsent"(arg0: K, arg1: integer): integer
public "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
public "computeIfAbsent"(arg0: K, arg1: $ToIntFunction$Type<(any)>): integer
public "computeIfAbsent"(arg0: K, arg1: $Object2IntFunction$Type<(any)>): integer
/**
 * 
 * @deprecated
 */
public "containsValue"(arg0: any): boolean
public "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public "getOrDefault"(arg0: any, arg1: integer): integer
public "object2IntEntrySet"(): $ObjectSet<($Object2IntMap$Entry<(K)>)>
/**
 * 
 * @deprecated
 */
public "mergeInt"(arg0: K, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
public "mergeInt"(arg0: K, arg1: integer, arg2: $IntBinaryOperator$0$Type): integer
public "computeInt"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
public "computeIntIfAbsent"(arg0: K, arg1: $ToIntFunction$Type<(any)>): integer
public "defaultReturnValue"(arg0: integer): void
public "defaultReturnValue"(): integer
public "computeIntIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
public "computeIntIfAbsentPartial"(arg0: K, arg1: $Object2IntFunction$Type<(any)>): integer
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (integer)>
public "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer): $Map<(K), (integer)>
public static "of"<K, V>(): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer, arg18: K, arg19: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer): $Map<(K), (integer)>
public "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
public static "entry"<K, V>(arg0: K, arg1: integer): $Map$Entry<(K), (integer)>
public "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): integer
public "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (integer)>
public static "identity"<T>(): $Function<(K), (K)>
[index: string | number]: integer
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractObject2IntMap$Type<K> = ($AbstractObject2IntMap<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractObject2IntMap_<K> = $AbstractObject2IntMap$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$Type} from "packages/java/util/function/$IntToDoubleFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Char2FloatFunction extends $Function$0<(character), (float)>, $IntToDoubleFunction {

 "remove"(arg0: character): float
 "get"(arg0: character): float
 "put"(arg0: character, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: float): float
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: character, arg1: float): float
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(character), (T)>
 "andThenDouble"(arg0: $Float2DoubleFunction$Type): $Char2DoubleFunction
 "composeChar"(arg0: $Char2CharFunction$Type): $Char2FloatFunction
 "composeShort"(arg0: $Short2CharFunction$Type): $Short2FloatFunction
 "andThenFloat"(arg0: $Float2FloatFunction$Type): $Char2FloatFunction
 "composeFloat"(arg0: $Float2CharFunction$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$Type): $Char2LongFunction
 "composeLong"(arg0: $Long2CharFunction$Type): $Long2FloatFunction
 "composeInt"(arg0: $Int2CharFunction$Type): $Int2FloatFunction
 "andThenInt"(arg0: $Float2IntFunction$Type): $Char2IntFunction
 "composeDouble"(arg0: $Double2CharFunction$Type): $Double2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$Type): $Char2CharFunction
 "composeObject"<T>(arg0: $Object2CharFunction$Type<(any)>): $Object2FloatFunction<(T)>
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$Type<(any)>): $Char2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2CharFunction$Type<(any)>): $Reference2FloatFunction<(T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$Type<(any)>): $Char2ObjectFunction<(T)>
 "andThenByte"(arg0: $Float2ByteFunction$Type): $Char2ByteFunction
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "andThenShort"(arg0: $Float2ShortFunction$Type): $Char2ShortFunction
 "composeByte"(arg0: $Byte2CharFunction$Type): $Byte2FloatFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: character): float

(arg0: character): float
}

export namespace $Char2FloatFunction {
function identity<T>(): $Function<(character), (character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2FloatFunction$Type = ($Char2FloatFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2FloatFunction_ = $Char2FloatFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongCollection" {
import {$LongStream, $LongStream$Type} from "packages/java/util/stream/$LongStream"
import {$LongSpliterator, $LongSpliterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSpliterator"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$LongIterator, $LongIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIterator"
import {$LongIterable, $LongIterable$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIterable"
import {$LongPredicate, $LongPredicate$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongPredicate"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LongPredicate as $LongPredicate$0, $LongPredicate$Type as $LongPredicate$0$Type} from "packages/java/util/function/$LongPredicate"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$Type as $LongConsumer$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongConsumer"

export interface $LongCollection extends $Collection<(long)>, $LongIterable {

 "add"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "toArray"(arg0: (long)[]): (long)[]
 "iterator"(): $LongIterator
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(long)>
 "contains"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "addAll"(arg0: $LongCollection$Type): boolean
 "removeIf"(arg0: $LongPredicate$0$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $LongPredicate$Type): boolean
 "removeAll"(arg0: $LongCollection$Type): boolean
 "retainAll"(arg0: $LongCollection$Type): boolean
 "containsAll"(arg0: $LongCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(long)>
 "rem"(arg0: long): boolean
 "longStream"(): $LongStream
 "toLongArray"(): (long)[]
/**
 * 
 * @deprecated
 */
 "toLongArray"(arg0: (long)[]): (long)[]
 "longIterator"(): $LongIterator
 "longParallelStream"(): $LongStream
 "longSpliterator"(): $LongSpliterator
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "forEach"(arg0: $LongConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $LongConsumer$0$Type): void
}

export namespace $LongCollection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongCollection$Type = ($LongCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongCollection_ = $LongCollection$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$LongToDoubleFunction, $LongToDoubleFunction$Type} from "packages/java/util/function/$LongToDoubleFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"

export interface $Long2FloatFunction extends $Function$0<(long), (float)>, $LongToDoubleFunction {

 "remove"(arg0: long): float
 "get"(arg0: long): float
 "put"(arg0: long, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: float): float
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: long, arg1: float): float
 "applyAsDouble"(arg0: long): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(long), (T)>
 "andThenDouble"(arg0: $Float2DoubleFunction$Type): $Long2DoubleFunction
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2FloatFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2FloatFunction
 "andThenFloat"(arg0: $Float2FloatFunction$Type): $Long2FloatFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$Type): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2FloatFunction
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2FloatFunction
 "andThenInt"(arg0: $Float2IntFunction$Type): $Long2IntFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$Type): $Long2CharFunction
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2FloatFunction<(T)>
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$Type<(any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2FloatFunction<(T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$Type<(any)>): $Long2ObjectFunction<(T)>
 "andThenByte"(arg0: $Float2ByteFunction$Type): $Long2ByteFunction
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "andThenShort"(arg0: $Float2ShortFunction$Type): $Long2ShortFunction
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2FloatFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: long): float

(arg0: long): float
}

export namespace $Long2FloatFunction {
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2FloatFunction$Type = ($Long2FloatFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2FloatFunction_ = $Long2FloatFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$AbstractIntCollection" {
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntPredicate, $IntPredicate$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntPredicate"
import {$IntCollection, $IntCollection$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntCollection"
import {$IntPredicate as $IntPredicate$0, $IntPredicate$Type as $IntPredicate$0$Type} from "packages/java/util/function/$IntPredicate"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntConsumer"
import {$AbstractCollection, $AbstractCollection$Type} from "packages/java/util/$AbstractCollection"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$Type as $IntConsumer$0$Type} from "packages/java/util/function/$IntConsumer"

export class $AbstractIntCollection extends $AbstractCollection<(integer)> implements $IntCollection {


/**
 * 
 * @deprecated
 */
public "add"(arg0: integer): boolean
public "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
public "toString"(): string
public "toArray"(arg0: (integer)[]): (integer)[]
public "contains"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public "addAll"(arg0: $IntCollection$Type): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "forEach"(arg0: $IntConsumer$Type): void
public "removeIf"(arg0: $IntPredicate$Type): boolean
public "removeAll"(arg0: $IntCollection$Type): boolean
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $IntCollection$Type): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $IntCollection$Type): boolean
public "rem"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
public "toIntArray"(arg0: (integer)[]): (integer)[]
public "toIntArray"(): (integer)[]
/**
 * 
 * @deprecated
 */
public "stream"(): $Stream<(integer)>
public "intStream"(): $IntStream
/**
 * 
 * @deprecated
 */
public "removeIf"(arg0: $Predicate$Type<(any)>): boolean
public "removeIf"(arg0: $IntPredicate$0$Type): boolean
/**
 * 
 * @deprecated
 */
public "parallelStream"(): $Stream<(integer)>
public "intParallelStream"(): $IntStream
public "intSpliterator"(): $IntSpliterator
public "intIterator"(): $IntIterator
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "forEach"(arg0: $IntConsumer$0$Type): void
/**
 * 
 * @deprecated
 */
public "forEach"(arg0: $Consumer$Type<(any)>): void
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractIntCollection$Type = ($AbstractIntCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractIntCollection_ = $AbstractIntCollection$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Short2ObjectFunction<V> extends $Function$0<(short), (V)>, $IntFunction<(V)> {

 "remove"(arg0: short): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: short): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: V): V
 "put"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Short2DoubleFunction
 "composeChar"(arg0: $Char2ShortFunction$Type): $Char2ObjectFunction<(V)>
 "composeShort"(arg0: $Short2ShortFunction$Type): $Short2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Short2FloatFunction
 "composeFloat"(arg0: $Float2ShortFunction$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Short2LongFunction
 "composeLong"(arg0: $Long2ShortFunction$Type): $Long2ObjectFunction<(V)>
 "composeInt"(arg0: $Int2ShortFunction$Type): $Int2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Short2IntFunction
 "composeDouble"(arg0: $Double2ShortFunction$Type): $Double2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Short2CharFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Short2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ShortFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Short2ObjectFunction<(T)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Short2ByteFunction
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Short2ShortFunction
 "composeByte"(arg0: $Byte2ShortFunction$Type): $Byte2ObjectFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: short): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(short), (V)>

(arg0: short): V
}

export namespace $Short2ObjectFunction {
function identity<T>(): $Function<(short), (short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2ObjectFunction$Type<V> = ($Short2ObjectFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2ObjectFunction_<V> = $Short2ObjectFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Int2ObjectFunction<V> extends $Function$0<(integer), (V)>, $IntFunction<(V)> {

 "remove"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: V): V
 "put"(arg0: integer, arg1: V): V
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Int2DoubleFunction
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2ObjectFunction<(V)>
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Int2FloatFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2ObjectFunction<(V)>
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Int2IntFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Int2CharFunction
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Int2ObjectFunction<(T)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Int2ByteFunction
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Int2ShortFunction
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2ObjectFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: integer): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (V)>

(arg0: integer): V
}

export namespace $Int2ObjectFunction {
function identity<T>(): $Function<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2ObjectFunction$Type<V> = ($Int2ObjectFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2ObjectFunction_<V> = $Int2ObjectFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntPredicate" {
import {$IntPredicate as $IntPredicate$0, $IntPredicate$Type as $IntPredicate$0$Type} from "packages/java/util/function/$IntPredicate"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"

export interface $IntPredicate extends $Predicate<(integer)>, $IntPredicate$0 {

/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
 "or"(arg0: $IntPredicate$0$Type): $IntPredicate
/**
 * 
 * @deprecated
 */
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(integer)>
 "or"(arg0: $IntPredicate$Type): $IntPredicate
 "and"(arg0: $IntPredicate$0$Type): $IntPredicate
 "and"(arg0: $IntPredicate$Type): $IntPredicate
/**
 * 
 * @deprecated
 */
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(integer)>
 "test"(arg0: integer): boolean

(arg0: integer): boolean
}

export namespace $IntPredicate {
function isEqual<T>(arg0: any): $Predicate<(integer)>
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntPredicate$Type = ($IntPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntPredicate_ = $IntPredicate$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ObjectIterable" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectSpliterator, $ObjectSpliterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSpliterator"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export interface $ObjectIterable<K> extends $Iterable<(K)> {

 "spliterator"(): $ObjectSpliterator<(K)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $ObjectIterable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectIterable$Type<K> = ($ObjectIterable<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectIterable_<K> = $ObjectIterable$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction" {
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Short2CharFunction extends $Function$0<(short), (character)>, $IntUnaryOperator {

 "remove"(arg0: short): character
 "get"(arg0: short): character
 "put"(arg0: short, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: character): character
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: short, arg1: character): character
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(short), (T)>
 "andThenDouble"(arg0: $Char2DoubleFunction$Type): $Short2DoubleFunction
 "composeChar"(arg0: $Char2ShortFunction$Type): $Char2CharFunction
 "composeShort"(arg0: $Short2ShortFunction$Type): $Short2CharFunction
 "andThenFloat"(arg0: $Char2FloatFunction$Type): $Short2FloatFunction
 "composeFloat"(arg0: $Float2ShortFunction$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$Type): $Short2LongFunction
 "composeLong"(arg0: $Long2ShortFunction$Type): $Long2CharFunction
 "composeInt"(arg0: $Int2ShortFunction$Type): $Int2CharFunction
 "andThenInt"(arg0: $Char2IntFunction$Type): $Short2IntFunction
 "composeDouble"(arg0: $Double2ShortFunction$Type): $Double2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$Type): $Short2CharFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$Type<(any)>): $Object2CharFunction<(T)>
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$Type<(any)>): $Short2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ShortFunction$Type<(any)>): $Reference2CharFunction<(T)>
 "andThenObject"<T>(arg0: $Char2ObjectFunction$Type<(any)>): $Short2ObjectFunction<(T)>
 "andThenByte"(arg0: $Char2ByteFunction$Type): $Short2ByteFunction
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "andThenShort"(arg0: $Char2ShortFunction$Type): $Short2ShortFunction
 "composeByte"(arg0: $Byte2ShortFunction$Type): $Byte2CharFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: short): character
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: short): character
}

export namespace $Short2CharFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2CharFunction$Type = ($Short2CharFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2CharFunction_ = $Short2CharFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntListIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntConsumer"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$Type as $IntConsumer$0$Type} from "packages/java/util/function/$IntConsumer"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"
import {$IntBidirectionalIterator, $IntBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntBidirectionalIterator"

export interface $IntListIterator extends $IntBidirectionalIterator, $ListIterator<(integer)> {

/**
 * 
 * @deprecated
 */
 "add"(arg0: integer): void
 "add"(arg0: integer): void
 "remove"(): void
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer): void
 "set"(arg0: integer): void
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "previousInt"(): integer
 "hasNext"(): boolean
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $IntConsumer$Type): void
 "nextInt"(): integer
 "forEachRemaining"(arg0: $IntConsumer$0$Type): void
}

export namespace $IntListIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntListIterator$Type = ($IntListIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntListIterator_ = $IntListIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$LongFunction, $LongFunction$Type} from "packages/java/util/function/$LongFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Long2ObjectFunction<V> extends $Function$0<(long), (V)>, $LongFunction<(V)> {

 "remove"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: V): V
 "put"(arg0: long, arg1: V): V
 "apply"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Long2DoubleFunction
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2ObjectFunction<(V)>
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Long2FloatFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2ObjectFunction<(V)>
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Long2IntFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Long2CharFunction
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Long2ObjectFunction<(T)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Long2ByteFunction
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Long2ShortFunction
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2ObjectFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: long): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(long), (V)>

(arg0: long): V
}

export namespace $Long2ObjectFunction {
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ObjectFunction$Type<V> = ($Long2ObjectFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ObjectFunction_<V> = $Long2ObjectFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$Type} from "packages/java/util/function/$IntToDoubleFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Byte2DoubleFunction extends $Function$0<(byte), (double)>, $IntToDoubleFunction {

 "remove"(arg0: byte): double
 "get"(arg0: byte): double
 "put"(arg0: byte, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: double): double
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: byte, arg1: double): double
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(byte), (T)>
 "andThenDouble"(arg0: $Double2DoubleFunction$Type): $Byte2DoubleFunction
 "composeChar"(arg0: $Char2ByteFunction$Type): $Char2DoubleFunction
 "composeShort"(arg0: $Short2ByteFunction$Type): $Short2DoubleFunction
 "andThenFloat"(arg0: $Double2FloatFunction$Type): $Byte2FloatFunction
 "composeFloat"(arg0: $Float2ByteFunction$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$Type): $Byte2LongFunction
 "composeLong"(arg0: $Long2ByteFunction$Type): $Long2DoubleFunction
 "composeInt"(arg0: $Int2ByteFunction$Type): $Int2DoubleFunction
 "andThenInt"(arg0: $Double2IntFunction$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2ByteFunction$Type): $Double2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$Type): $Byte2CharFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$Type<(any)>): $Object2DoubleFunction<(T)>
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$Type<(any)>): $Byte2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ByteFunction$Type<(any)>): $Reference2DoubleFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$Type<(any)>): $Byte2ObjectFunction<(T)>
 "andThenByte"(arg0: $Double2ByteFunction$Type): $Byte2ByteFunction
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenShort"(arg0: $Double2ShortFunction$Type): $Byte2ShortFunction
 "composeByte"(arg0: $Byte2ByteFunction$Type): $Byte2DoubleFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: byte): double

(arg0: byte): double
}

export namespace $Byte2DoubleFunction {
function identity<T>(): $Function<(byte), (byte)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2DoubleFunction$Type = ($Byte2DoubleFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2DoubleFunction_ = $Byte2DoubleFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortSet" {
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ShortPredicate, $ShortPredicate$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortPredicate"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ShortSpliterator, $ShortSpliterator$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortSpliterator"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ShortConsumer, $ShortConsumer$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortConsumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$ShortCollection, $ShortCollection$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortCollection"

export interface $ShortSet extends $ShortCollection, $Set<(short)> {

/**
 * 
 * @deprecated
 */
 "add"(arg0: short): boolean
 "remove"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $ShortSpliterator
/**
 * 
 * @deprecated
 */
 "rem"(arg0: short): boolean
 "add"(arg0: short): boolean
 "toArray"(arg0: (short)[]): (short)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(short)>
 "intStream"(): $IntStream
 "contains"(arg0: short): boolean
 "addAll"(arg0: $ShortCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $ShortPredicate$Type): boolean
 "removeIf"(arg0: $IntPredicate$Type): boolean
 "removeAll"(arg0: $ShortCollection$Type): boolean
 "retainAll"(arg0: $ShortCollection$Type): boolean
 "containsAll"(arg0: $ShortCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(short)>
 "intParallelStream"(): $IntStream
 "intSpliterator"(): $IntSpliterator
 "intIterator"(): $IntIterator
/**
 * 
 * @deprecated
 */
 "toShortArray"(arg0: (short)[]): (short)[]
 "toShortArray"(): (short)[]
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "forEach"(arg0: $ShortConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $IntConsumer$Type): void
}

export namespace $ShortSet {
function of(arg0: short, arg1: short): $ShortSet
function of(): $ShortSet
function of(...arg0: (short)[]): $ShortSet
function of(arg0: short): $ShortSet
function of(arg0: short, arg1: short, arg2: short): $ShortSet
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short): $Set<(short)>
function of<E>(arg0: short): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short, arg8: short, arg9: short): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short, arg8: short): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short, arg7: short): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short, arg3: short, arg4: short, arg5: short, arg6: short): $Set<(short)>
function of<E>(...arg0: (short)[]): $Set<(short)>
function of<E>(arg0: short, arg1: short, arg2: short): $Set<(short)>
function of<E>(arg0: short, arg1: short): $Set<(short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortSet$Type = ($ShortSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortSet_ = $ShortSet$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2IntLinkedOpenHashMap" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Hash, $Hash$Type} from "packages/it/unimi/dsi/fastutil/$Hash"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$ObjectSortedSet, $ObjectSortedSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSortedSet"
import {$Object2IntSortedMap, $Object2IntSortedMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntSortedMap"
import {$AbstractObject2IntSortedMap, $AbstractObject2IntSortedMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2IntSortedMap"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Object2IntMap, $Object2IntMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntMap"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $Object2IntLinkedOpenHashMap<K> extends $AbstractObject2IntSortedMap<(K)> implements $Serializable, $Cloneable, $Hash {

constructor(arg0: $Map$Type<(any), (any)>)
constructor(arg0: $Object2IntMap$Type<(K)>, arg1: float)
constructor(arg0: $Object2IntMap$Type<(K)>)
constructor(arg0: (K)[], arg1: (integer)[], arg2: float)
constructor(arg0: (K)[], arg1: (integer)[])
constructor(arg0: integer, arg1: float)
constructor(arg0: integer)
constructor()
constructor(arg0: $Map$Type<(any), (any)>, arg1: float)

public "remove"(arg0: any, arg1: integer): boolean
public "put"(arg0: K, arg1: integer): integer
public "hashCode"(): integer
public "getInt"(arg0: any): integer
public "clear"(): void
public "isEmpty"(): boolean
public "replace"(arg0: K, arg1: integer, arg2: integer): boolean
public "replace"(arg0: K, arg1: integer): integer
public "size"(): integer
public "trim"(arg0: integer): boolean
public "trim"(): boolean
public "merge"(arg0: K, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "putIfAbsent"(arg0: K, arg1: integer): integer
public "containsKey"(arg0: any): boolean
public "computeIfAbsent"(arg0: K, arg1: $ToIntFunction$Type<(any)>): integer
public "computeIfAbsent"(arg0: K, arg1: $Object2IntFunction$Type<(any)>): integer
public "keySet"(): $ObjectSortedSet<(K)>
public "containsValue"(arg0: integer): boolean
public "getOrDefault"(arg0: any, arg1: integer): integer
public "comparator"(): $Comparator<(any)>
public "firstKey"(): K
public "addTo"(arg0: K, arg1: integer): integer
public "subMap"(arg0: K, arg1: K): $Object2IntSortedMap<(K)>
public "headMap"(arg0: K): $Object2IntSortedMap<(K)>
public "tailMap"(arg0: K): $Object2IntSortedMap<(K)>
public "lastKey"(): K
public "computeInt"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
public "removeFirstInt"(): integer
public "removeLastInt"(): integer
public "getAndMoveToFirst"(arg0: K): integer
public "getAndMoveToLast"(arg0: K): integer
public "putAndMoveToLast"(arg0: K, arg1: integer): integer
public "putAndMoveToFirst"(arg0: K, arg1: integer): integer
public "computeIntIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
public "removeInt"(arg0: any): integer
public "defaultReturnValue"(arg0: integer): void
public "defaultReturnValue"(): integer
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2IntLinkedOpenHashMap$Type<K> = ($Object2IntLinkedOpenHashMap<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2IntLinkedOpenHashMap_<K> = $Object2IntLinkedOpenHashMap$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Int2ObjectMap$Entry<V> extends $Map$Entry<(integer), (V)> {

/**
 * 
 * @deprecated
 */
 "getKey"(): integer
 "getIntKey"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "getValue"(): V
 "setValue"(arg0: V): V
}

export namespace $Int2ObjectMap$Entry {
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(integer), (V)>)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(integer), (V)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(integer), (V)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(integer), (V)>)>
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(integer), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2ObjectMap$Entry$Type<V> = ($Int2ObjectMap$Entry<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2ObjectMap$Entry_<V> = $Int2ObjectMap$Entry$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$AbstractLong2ObjectSortedMap" {
import {$AbstractLong2ObjectMap, $AbstractLong2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/longs/$AbstractLong2ObjectMap"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ObjectSortedSet, $ObjectSortedSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSortedSet"
import {$LongComparator, $LongComparator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongComparator"
import {$Long2ObjectMap$Entry, $Long2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap$Entry"
import {$Long2ObjectSortedMap, $Long2ObjectSortedMap$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectSortedMap"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export class $AbstractLong2ObjectSortedMap<V> extends $AbstractLong2ObjectMap<(V)> implements $Long2ObjectSortedMap<(V)> {


/**
 * 
 * @deprecated
 */
public "entrySet"(): $ObjectSortedSet<($Map$Entry<(long), (V)>)>
public "comparator"(): $LongComparator
/**
 * 
 * @deprecated
 */
public "subMap"(arg0: long, arg1: long): $Long2ObjectSortedMap<(V)>
public "subMap"(arg0: long, arg1: long): $Long2ObjectSortedMap<(V)>
public "headMap"(arg0: long): $Long2ObjectSortedMap<(V)>
/**
 * 
 * @deprecated
 */
public "headMap"(arg0: long): $Long2ObjectSortedMap<(V)>
/**
 * 
 * @deprecated
 */
public "tailMap"(arg0: long): $Long2ObjectSortedMap<(V)>
public "tailMap"(arg0: long): $Long2ObjectSortedMap<(V)>
public "firstLongKey"(): long
public "lastLongKey"(): long
public "long2ObjectEntrySet"(): $ObjectSortedSet<($Long2ObjectMap$Entry<(V)>)>
public "defaultReturnValue"(): V
public "defaultReturnValue"(arg0: V): void
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V): $Map<(long), (V)>
public static "of"<K, V>(): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V, arg18: long, arg19: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V): $Map<(long), (V)>
public static "entry"<K, V>(arg0: long, arg1: V): $Map$Entry<(long), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(long), (V)>
public static "identity"<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractLong2ObjectSortedMap$Type<V> = ($AbstractLong2ObjectSortedMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractLong2ObjectSortedMap_<V> = $AbstractLong2ObjectSortedMap$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$ShortConsumer, $ShortConsumer$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortConsumer"
import {$PrimitiveIterator, $PrimitiveIterator$Type} from "packages/java/util/$PrimitiveIterator"

export interface $ShortIterator extends $PrimitiveIterator<(short), ($ShortConsumer)> {

 "forEachRemaining"(arg0: $IntConsumer$Type): void
 "forEachRemaining"(arg0: $ShortConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "skip"(arg0: integer): integer
 "nextShort"(): short
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $ShortIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortIterator$Type = ($ShortIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortIterator_ = $ShortIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2ReferenceFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export class $AbstractObject2ReferenceFunction<K, V> implements $Object2ReferenceFunction<(K), (V)>, $Serializable {


public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public "remove"(arg0: any): V
public "get"(arg0: any): V
public "put"(arg0: K, arg1: V): V
public "getOrDefault"(arg0: any, arg1: V): V
public "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Object2DoubleFunction<(K)>
public "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2ReferenceFunction<(V)>
public "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2ReferenceFunction<(V)>
public "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Object2FloatFunction<(K)>
public "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2ReferenceFunction<(V)>
public "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Object2LongFunction<(K)>
public "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2ReferenceFunction<(V)>
public "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2ReferenceFunction<(V)>
public "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Object2IntFunction<(K)>
public "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2ReferenceFunction<(V)>
public "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Object2CharFunction<(K)>
public "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ReferenceFunction<(T), (V)>
public "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Object2ReferenceFunction<(K), (T)>
public "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2ReferenceFunction<(T), (V)>
public "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Object2ObjectFunction<(K), (T)>
public "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Object2ByteFunction<(K)>
public "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Object2ShortFunction<(K)>
public "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2ReferenceFunction<(V)>
public "clear"(): void
public "size"(): integer
public "apply"(arg0: K): V
public "containsKey"(arg0: any): boolean
public static "identity"<T>(): $Function<(K), (K)>
public "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (V)>
public "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractObject2ReferenceFunction$Type<K, V> = ($AbstractObject2ReferenceFunction<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractObject2ReferenceFunction_<K, V> = $AbstractObject2ReferenceFunction$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$FloatIterable" {
import {$FloatConsumer, $FloatConsumer$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatConsumer"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$DoubleSpliterator, $DoubleSpliterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleSpliterator"
import {$DoubleIterator, $DoubleIterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleIterator"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/java/util/function/$DoubleConsumer"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export interface $FloatIterable extends $Iterable<(float)> {

 "forEach"(arg0: $FloatConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $DoubleConsumer$Type): void
 "doubleSpliterator"(): $DoubleSpliterator
 "doubleIterator"(): $DoubleIterator
}

export namespace $FloatIterable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatIterable$Type = ($FloatIterable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatIterable_ = $FloatIterable$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2ObjectMap" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Object2ObjectMap$Entry, $Object2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap$Entry"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ObjectCollection, $ObjectCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectCollection"
import {$Object2ObjectMap, $Object2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap"
import {$AbstractObject2ObjectFunction, $AbstractObject2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2ObjectFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $AbstractObject2ObjectMap<K, V> extends $AbstractObject2ObjectFunction<(K), (V)> implements $Object2ObjectMap<(K), (V)>, $Serializable {


public "equals"(arg0: any): boolean
public "toString"(): string
public "values"(): $ObjectCollection<(V)>
public "hashCode"(): integer
public "isEmpty"(): boolean
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "containsKey"(arg0: any): boolean
public "containsValue"(arg0: any): boolean
public "remove"(arg0: any): V
public "remove"(arg0: any, arg1: any): boolean
public "put"(arg0: K, arg1: V): V
public "clear"(): void
public "replace"(arg0: K, arg1: V, arg2: V): boolean
public "replace"(arg0: K, arg1: V): V
public "size"(): integer
public "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "entrySet"(): $ObjectSet<($Map$Entry<(K), (V)>)>
public "putIfAbsent"(arg0: K, arg1: V): V
public "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
public "computeIfAbsent"(arg0: K, arg1: $Object2ObjectFunction$Type<(any), (any)>): V
public "getOrDefault"(arg0: any, arg1: V): V
public "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "object2ObjectEntrySet"(): $ObjectSet<($Object2ObjectMap$Entry<(K), (V)>)>
/**
 * 
 * @deprecated
 */
public "computeObjectIfAbsentPartial"(arg0: K, arg1: $Object2ObjectFunction$Type<(any), (any)>): V
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): V
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(K), (K)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractObject2ObjectMap$Type<K, V> = ($AbstractObject2ObjectMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractObject2ObjectMap_<K, V> = $AbstractObject2ObjectMap$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectSortedMap" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$LongFunction, $LongFunction$Type} from "packages/java/util/function/$LongFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$ObjectSortedSet, $ObjectSortedSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSortedSet"
import {$LongComparator, $LongComparator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongComparator"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Long2ObjectMap, $Long2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Long2ObjectMap$Entry, $Long2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap$Entry"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$SortedMap, $SortedMap$Type} from "packages/java/util/$SortedMap"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$LongSortedSet, $LongSortedSet$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSortedSet"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Long2ObjectSortedMap<V> extends $Long2ObjectMap<(V)>, $SortedMap<(long), (V)> {

/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSortedSet<($Map$Entry<(long), (V)>)>
 "keySet"(): $LongSortedSet
 "comparator"(): $LongComparator
/**
 * 
 * @deprecated
 */
 "subMap"(arg0: long, arg1: long): $Long2ObjectSortedMap<(V)>
 "subMap"(arg0: long, arg1: long): $Long2ObjectSortedMap<(V)>
 "headMap"(arg0: long): $Long2ObjectSortedMap<(V)>
/**
 * 
 * @deprecated
 */
 "headMap"(arg0: long): $Long2ObjectSortedMap<(V)>
/**
 * 
 * @deprecated
 */
 "tailMap"(arg0: long): $Long2ObjectSortedMap<(V)>
 "tailMap"(arg0: long): $Long2ObjectSortedMap<(V)>
 "firstLongKey"(): long
 "lastLongKey"(): long
 "long2ObjectEntrySet"(): $ObjectSortedSet<($Long2ObjectMap$Entry<(V)>)>
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: long, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: V): V
 "clear"(): void
 "replace"(arg0: long, arg1: V, arg2: V): boolean
 "replace"(arg0: long, arg1: V): V
 "size"(): integer
 "merge"(arg0: long, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
 "putIfAbsent"(arg0: long, arg1: V): V
 "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: long, arg1: $Long2ObjectFunction$Type<(any)>): V
 "computeIfAbsent"(arg0: long, arg1: $LongFunction$Type<(any)>): V
 "getOrDefault"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: long, arg1: $Long2ObjectFunction$Type<(any)>): V
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "remove"(arg0: long): V
 "get"(arg0: long): V
 "put"(arg0: long, arg1: V): V
 "apply"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Long2DoubleFunction
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2ObjectFunction<(V)>
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Long2FloatFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2ObjectFunction<(V)>
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Long2IntFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Long2CharFunction
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Long2ObjectFunction<(T)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Long2ByteFunction
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Long2ShortFunction
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2ObjectFunction<(V)>
 "remove"(arg0: any, arg1: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replace"(arg0: long, arg1: V): V
 "replace"(arg0: long, arg1: V, arg2: V): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "merge"(arg0: long, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "putIfAbsent"(arg0: long, arg1: V): V
 "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "computeIfAbsent"(arg0: long, arg1: $Function$Type<(any), (any)>): V
 "containsValue"(arg0: any): boolean
 "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "apply"(arg0: long): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(long), (V)>
}

export namespace $Long2ObjectSortedMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V): $Map<(long), (V)>
function of<K, V>(): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V, arg18: long, arg19: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V): $Map<(long), (V)>
function entry<K, V>(arg0: long, arg1: V): $Map$Entry<(long), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(long), (V)>
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ObjectSortedMap$Type<V> = ($Long2ObjectSortedMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ObjectSortedMap_<V> = $Long2ObjectSortedMap$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$DoubleToIntFunction, $DoubleToIntFunction$Type} from "packages/java/util/function/$DoubleToIntFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Double2ByteFunction extends $Function$0<(double), (byte)>, $DoubleToIntFunction {

 "remove"(arg0: double): byte
 "get"(arg0: double): byte
 "put"(arg0: double, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: byte): byte
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: double, arg1: byte): byte
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(double), (T)>
 "andThenDouble"(arg0: $Byte2DoubleFunction$Type): $Double2DoubleFunction
 "composeChar"(arg0: $Char2DoubleFunction$Type): $Char2ByteFunction
 "composeShort"(arg0: $Short2DoubleFunction$Type): $Short2ByteFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2DoubleFunction$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$Type): $Double2LongFunction
 "composeLong"(arg0: $Long2DoubleFunction$Type): $Long2ByteFunction
 "composeInt"(arg0: $Int2DoubleFunction$Type): $Int2ByteFunction
 "andThenInt"(arg0: $Byte2IntFunction$Type): $Double2IntFunction
 "composeDouble"(arg0: $Double2DoubleFunction$Type): $Double2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$Type): $Double2CharFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$Type<(any)>): $Object2ByteFunction<(T)>
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$Type<(any)>): $Double2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2DoubleFunction$Type<(any)>): $Reference2ByteFunction<(T)>
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$Type<(any)>): $Double2ObjectFunction<(T)>
 "andThenByte"(arg0: $Byte2ByteFunction$Type): $Double2ByteFunction
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "andThenShort"(arg0: $Byte2ShortFunction$Type): $Double2ShortFunction
 "composeByte"(arg0: $Byte2DoubleFunction$Type): $Byte2ByteFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: double): byte

(arg0: double): byte
}

export namespace $Double2ByteFunction {
function identity<T>(): $Function<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2ByteFunction$Type = ($Double2ByteFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2ByteFunction_ = $Double2ByteFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$LongPredicate, $LongPredicate$Type} from "packages/java/util/function/$LongPredicate"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"

export interface $Long2BooleanFunction extends $Function$0<(long), (boolean)>, $LongPredicate {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "remove"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: boolean): boolean
 "put"(arg0: long, arg1: boolean): boolean
 "test"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: long): boolean
 "getOrDefault"(arg0: long, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(long), (T)>
 "andThenDouble"(arg0: $Boolean2DoubleFunction$Type): $Long2DoubleFunction
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2BooleanFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2BooleanFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$Type): $Long2FloatFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$Type): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2BooleanFunction
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2BooleanFunction
 "andThenInt"(arg0: $Boolean2IntFunction$Type): $Long2IntFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$Type): $Long2CharFunction
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2BooleanFunction<(T)>
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$Type<(any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2BooleanFunction<(T)>
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$Type<(any)>): $Long2ObjectFunction<(T)>
 "andThenByte"(arg0: $Boolean2ByteFunction$Type): $Long2ByteFunction
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "andThenShort"(arg0: $Boolean2ShortFunction$Type): $Long2ShortFunction
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2BooleanFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: long): boolean
 "or"(arg0: $LongPredicate$Type): $LongPredicate
 "and"(arg0: $LongPredicate$Type): $LongPredicate
 "negate"(): $LongPredicate

(arg0: any): boolean
}

export namespace $Long2BooleanFunction {
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2BooleanFunction$Type = ($Long2BooleanFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2BooleanFunction_ = $Long2BooleanFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2IntMap" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$IntBinaryOperator, $IntBinaryOperator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntBinaryOperator"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Object2IntMap$Entry, $Object2IntMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntMap$Entry"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$IntBinaryOperator as $IntBinaryOperator$0, $IntBinaryOperator$Type as $IntBinaryOperator$0$Type} from "packages/java/util/function/$IntBinaryOperator"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$IntCollection, $IntCollection$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntCollection"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Object2IntMap<K> extends $Object2IntFunction<(K)>, $Map<(K), (integer)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
 "remove"(arg0: any, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: integer): integer
 "values"(): $IntCollection
 "clear"(): void
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: integer, arg2: integer): boolean
 "replace"(arg0: K, arg1: integer, arg2: integer): boolean
 "replace"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: integer): integer
 "size"(): integer
 "merge"(arg0: K, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
 "merge"(arg0: K, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (integer)>)>
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: K, arg1: integer): integer
 "putIfAbsent"(arg0: K, arg1: integer): integer
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $ToIntFunction$Type<(any)>): integer
 "computeIfAbsent"(arg0: K, arg1: $Object2IntFunction$Type<(any)>): integer
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "containsValue"(arg0: integer): boolean
 "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "object2IntEntrySet"(): $ObjectSet<($Object2IntMap$Entry<(K)>)>
/**
 * 
 * @deprecated
 */
 "mergeInt"(arg0: K, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
 "mergeInt"(arg0: K, arg1: integer, arg2: $IntBinaryOperator$Type): integer
 "mergeInt"(arg0: K, arg1: integer, arg2: $IntBinaryOperator$0$Type): integer
 "computeInt"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
 "computeIntIfAbsent"(arg0: K, arg1: $ToIntFunction$Type<(any)>): integer
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "computeIntIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
 "computeIntIfAbsentPartial"(arg0: K, arg1: $Object2IntFunction$Type<(any)>): integer
 "put"(arg0: K, arg1: integer): integer
 "getInt"(arg0: any): integer
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2IntFunction
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Object2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2IntFunction
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Object2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$Type): $Object2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2IntFunction<(T)>
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Object2ByteFunction<(K)>
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2IntFunction
 "removeInt"(arg0: any): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
 "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): integer
 "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
 "apply"(arg0: K): integer
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (integer)>
}

export namespace $Object2IntMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer): $Map<(K), (integer)>
function of<K, V>(): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer, arg18: K, arg19: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer): $Map<(K), (integer)>
function entry<K, V>(arg0: K, arg1: integer): $Map$Entry<(K), (integer)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (integer)>
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2IntMap$Type<K> = ($Object2IntMap<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2IntMap_<K> = $Object2IntMap$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Function, $Function$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/java/util/function/$Function"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Char2CharFunction extends $Function<(character), (character)>, $IntUnaryOperator {

 "remove"(arg0: character): character
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): character
 "get"(arg0: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: character): character
 "put"(arg0: character, arg1: character): character
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: character, arg1: character): character
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(character), (T)>
 "andThenDouble"(arg0: $Char2DoubleFunction$Type): $Char2DoubleFunction
 "composeChar"(arg0: $Char2CharFunction$Type): $Char2CharFunction
 "composeShort"(arg0: $Short2CharFunction$Type): $Short2CharFunction
 "andThenFloat"(arg0: $Char2FloatFunction$Type): $Char2FloatFunction
 "composeFloat"(arg0: $Float2CharFunction$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$Type): $Char2LongFunction
 "composeLong"(arg0: $Long2CharFunction$Type): $Long2CharFunction
 "composeInt"(arg0: $Int2CharFunction$Type): $Int2CharFunction
 "andThenInt"(arg0: $Char2IntFunction$Type): $Char2IntFunction
 "composeDouble"(arg0: $Double2CharFunction$Type): $Double2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$Type): $Char2CharFunction
 "composeObject"<T>(arg0: $Object2CharFunction$Type<(any)>): $Object2CharFunction<(T)>
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$Type<(any)>): $Char2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2CharFunction$Type<(any)>): $Reference2CharFunction<(T)>
 "andThenObject"<T>(arg0: $Char2ObjectFunction$Type<(any)>): $Char2ObjectFunction<(T)>
 "andThenByte"(arg0: $Char2ByteFunction$Type): $Char2ByteFunction
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "andThenShort"(arg0: $Char2ShortFunction$Type): $Char2ShortFunction
 "composeByte"(arg0: $Byte2CharFunction$Type): $Byte2CharFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: character): character
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: character): character
}

export namespace $Char2CharFunction {
function identity(): $Char2CharFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2CharFunction$Type = ($Char2CharFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2CharFunction_ = $Char2CharFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/$Hash$Strategy" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Hash$Strategy<K> {

 "equals"(arg0: K, arg1: K): boolean
 "hashCode"(arg0: K): integer
}

export namespace $Hash$Strategy {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Hash$Strategy$Type<K> = ($Hash$Strategy<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Hash$Strategy_<K> = $Hash$Strategy$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/$Hash" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Hash {

}

export namespace $Hash {
const DEFAULT_INITIAL_SIZE: integer
const DEFAULT_LOAD_FACTOR: float
const FAST_LOAD_FACTOR: float
const VERY_FAST_LOAD_FACTOR: float
const DEFAULT_GROWTH_FACTOR: integer
const FREE: byte
const OCCUPIED: byte
const REMOVED: byte
const PRIMES: (integer)[]
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Hash$Type = ($Hash);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Hash_ = $Hash$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$LongToIntFunction, $LongToIntFunction$Type} from "packages/java/util/function/$LongToIntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Long2CharFunction extends $Function$0<(long), (character)>, $LongToIntFunction {

 "remove"(arg0: long): character
 "get"(arg0: long): character
 "put"(arg0: long, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: character): character
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: long, arg1: character): character
 "applyAsInt"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(long), (T)>
 "andThenDouble"(arg0: $Char2DoubleFunction$Type): $Long2DoubleFunction
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2CharFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2CharFunction
 "andThenFloat"(arg0: $Char2FloatFunction$Type): $Long2FloatFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$Type): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2CharFunction
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2CharFunction
 "andThenInt"(arg0: $Char2IntFunction$Type): $Long2IntFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$Type): $Long2CharFunction
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2CharFunction<(T)>
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$Type<(any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2CharFunction<(T)>
 "andThenObject"<T>(arg0: $Char2ObjectFunction$Type<(any)>): $Long2ObjectFunction<(T)>
 "andThenByte"(arg0: $Char2ByteFunction$Type): $Long2ByteFunction
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "andThenShort"(arg0: $Char2ShortFunction$Type): $Long2ShortFunction
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2CharFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: long): character

(arg0: long): character
}

export namespace $Long2CharFunction {
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2CharFunction$Type = ($Long2CharFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2CharFunction_ = $Long2CharFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Reference2ShortFunction<K> extends $Function$0<(K), (short)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): short
 "put"(arg0: K, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: short): short
 "getShort"(arg0: any): short
 "getOrDefault"(arg0: any, arg1: short): short
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "andThenDouble"(arg0: $Short2DoubleFunction$Type): $Reference2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2ShortFunction
 "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2ShortFunction
 "andThenFloat"(arg0: $Short2FloatFunction$Type): $Reference2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$Type): $Reference2LongFunction<(K)>
 "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2ShortFunction
 "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2ShortFunction
 "andThenInt"(arg0: $Short2IntFunction$Type): $Reference2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$Type): $Reference2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2ShortFunction<(T)>
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$Type<(any)>): $Reference2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2ShortFunction<(T)>
 "andThenObject"<T>(arg0: $Short2ObjectFunction$Type<(any)>): $Reference2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Short2ByteFunction$Type): $Reference2ByteFunction<(K)>
 "defaultReturnValue"(): short
 "defaultReturnValue"(arg0: short): void
 "andThenShort"(arg0: $Short2ShortFunction$Type): $Reference2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2ShortFunction
 "removeShort"(arg0: any): short
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): short
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (short)>

(arg0: any): short
}

export namespace $Reference2ShortFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2ShortFunction$Type<K> = ($Reference2ShortFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2ShortFunction_<K> = $Reference2ShortFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongBidirectionalIterable" {
import {$LongBidirectionalIterator, $LongBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongBidirectionalIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$LongSpliterator, $LongSpliterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSpliterator"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$Type as $LongConsumer$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongConsumer"
import {$LongIterator, $LongIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIterator"
import {$LongIterable, $LongIterable$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIterable"

export interface $LongBidirectionalIterable extends $LongIterable {

 "iterator"(): $LongBidirectionalIterator
 "forEach"(arg0: $LongConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $LongConsumer$0$Type): void
 "longIterator"(): $LongIterator
 "longSpliterator"(): $LongSpliterator

(): $LongBidirectionalIterator
}

export namespace $LongBidirectionalIterable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongBidirectionalIterable$Type = ($LongBidirectionalIterable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongBidirectionalIterable_ = $LongBidirectionalIterable$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Int2CharFunction extends $Function$0<(integer), (character)>, $IntUnaryOperator {

 "remove"(arg0: integer): character
 "get"(arg0: integer): character
 "put"(arg0: integer, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: character): character
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: integer, arg1: character): character
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (T)>
 "andThenDouble"(arg0: $Char2DoubleFunction$Type): $Int2DoubleFunction
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2CharFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2CharFunction
 "andThenFloat"(arg0: $Char2FloatFunction$Type): $Int2FloatFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$Type): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2CharFunction
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2CharFunction
 "andThenInt"(arg0: $Char2IntFunction$Type): $Int2IntFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$Type): $Int2CharFunction
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2CharFunction<(T)>
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$Type<(any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2CharFunction<(T)>
 "andThenObject"<T>(arg0: $Char2ObjectFunction$Type<(any)>): $Int2ObjectFunction<(T)>
 "andThenByte"(arg0: $Char2ByteFunction$Type): $Int2ByteFunction
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "andThenShort"(arg0: $Char2ShortFunction$Type): $Int2ShortFunction
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2CharFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: integer): character
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: integer): character
}

export namespace $Int2CharFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2CharFunction$Type = ($Int2CharFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2CharFunction_ = $Int2CharFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap" {
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Object2ObjectMap$Entry, $Object2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap$Entry"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ObjectCollection, $ObjectCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectCollection"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Object2ObjectMap<K, V> extends $Object2ObjectFunction<(K), (V)>, $Map<(K), (V)> {

 "remove"(arg0: any): V
 "remove"(arg0: any, arg1: any): boolean
 "put"(arg0: K, arg1: V): V
 "values"(): $ObjectCollection<(V)>
 "clear"(): void
 "replace"(arg0: K, arg1: V, arg2: V): boolean
 "replace"(arg0: K, arg1: V): V
 "size"(): integer
 "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (V)>)>
 "putIfAbsent"(arg0: K, arg1: V): V
 "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $Object2ObjectFunction$Type<(any), (any)>): V
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "object2ObjectEntrySet"(): $ObjectSet<($Object2ObjectMap$Entry<(K), (V)>)>
/**
 * 
 * @deprecated
 */
 "computeObjectIfAbsentPartial"(arg0: K, arg1: $Object2ObjectFunction$Type<(any), (any)>): V
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "get"(arg0: any): V
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Object2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2ObjectFunction<(V)>
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Object2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2ObjectFunction<(V)>
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Object2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Object2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ObjectFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Object2ByteFunction<(K)>
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Object2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2ObjectFunction<(V)>
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): V
 "containsValue"(arg0: any): boolean
 "apply"(arg0: K): V
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (V)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(K), (V)>
}

export namespace $Object2ObjectMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
function of<K, V>(): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
function entry<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ObjectMap$Type<K, V> = ($Object2ObjectMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ObjectMap_<K, V> = $Object2ObjectMap$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectLinkedOpenHashMap" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Hash, $Hash$Type} from "packages/it/unimi/dsi/fastutil/$Hash"
import {$AbstractObject2ObjectSortedMap, $AbstractObject2ObjectSortedMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2ObjectSortedMap"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ObjectCollection, $ObjectCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectCollection"
import {$Object2ObjectSortedMap, $Object2ObjectSortedMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectSortedMap"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$Object2ObjectMap, $Object2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $Object2ObjectLinkedOpenHashMap<K, V> extends $AbstractObject2ObjectSortedMap<(K), (V)> implements $Serializable, $Cloneable, $Hash {

constructor(arg0: $Map$Type<(any), (any)>)
constructor(arg0: $Object2ObjectMap$Type<(K), (V)>, arg1: float)
constructor(arg0: $Object2ObjectMap$Type<(K), (V)>)
constructor(arg0: (K)[], arg1: (V)[], arg2: float)
constructor(arg0: (K)[], arg1: (V)[])
constructor(arg0: integer, arg1: float)
constructor(arg0: integer)
constructor()
constructor(arg0: $Map$Type<(any), (any)>, arg1: float)

public "remove"(arg0: any, arg1: any): boolean
public "remove"(arg0: any): V
public "get"(arg0: any): V
public "put"(arg0: K, arg1: V): V
public "values"(): $ObjectCollection<(V)>
public "hashCode"(): integer
public "clone"(): $Object2ObjectLinkedOpenHashMap<(K), (V)>
public "clear"(): void
public "isEmpty"(): boolean
public "replace"(arg0: K, arg1: V): V
public "replace"(arg0: K, arg1: V, arg2: V): boolean
public "size"(): integer
public "trim"(): boolean
public "trim"(arg0: integer): boolean
public "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "putIfAbsent"(arg0: K, arg1: V): V
public "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "containsKey"(arg0: any): boolean
public "computeIfAbsent"(arg0: K, arg1: $Object2ObjectFunction$Type<(any), (any)>): V
public "containsValue"(arg0: any): boolean
public "getOrDefault"(arg0: any, arg1: V): V
public "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "comparator"(): $Comparator<(any)>
public "firstKey"(): K
public "removeFirst"(): V
public "removeLast"(): V
public "subMap"(arg0: K, arg1: K): $Object2ObjectSortedMap<(K), (V)>
public "tailMap"(arg0: K): $Object2ObjectSortedMap<(K), (V)>
public "lastKey"(): K
public "getAndMoveToFirst"(arg0: K): V
public "getAndMoveToLast"(arg0: K): V
public "putAndMoveToLast"(arg0: K, arg1: V): V
public "putAndMoveToFirst"(arg0: K, arg1: V): V
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ObjectLinkedOpenHashMap$Type<K, V> = ($Object2ObjectLinkedOpenHashMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ObjectLinkedOpenHashMap_<K, V> = $Object2ObjectLinkedOpenHashMap$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$DoubleFunction, $DoubleFunction$Type} from "packages/java/util/function/$DoubleFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Float2ReferenceFunction<V> extends $Function$0<(float), (V)>, $DoubleFunction<(V)> {

 "remove"(arg0: float): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: float): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: V): V
 "put"(arg0: float, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: double): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: float, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Float2DoubleFunction
 "composeChar"(arg0: $Char2FloatFunction$Type): $Char2ReferenceFunction<(V)>
 "composeShort"(arg0: $Short2FloatFunction$Type): $Short2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Float2FloatFunction
 "composeFloat"(arg0: $Float2FloatFunction$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Float2LongFunction
 "composeLong"(arg0: $Long2FloatFunction$Type): $Long2ReferenceFunction<(V)>
 "composeInt"(arg0: $Int2FloatFunction$Type): $Int2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Float2IntFunction
 "composeDouble"(arg0: $Double2FloatFunction$Type): $Double2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Float2CharFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$Type<(any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Float2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2FloatFunction$Type<(any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Float2ObjectFunction<(T)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Float2ByteFunction
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Float2ShortFunction
 "composeByte"(arg0: $Byte2FloatFunction$Type): $Byte2ReferenceFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: float): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(float), (V)>

(arg0: float): V
}

export namespace $Float2ReferenceFunction {
function identity<T>(): $Function<(float), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2ReferenceFunction$Type<V> = ($Float2ReferenceFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2ReferenceFunction_<V> = $Float2ReferenceFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$PrimitiveIterator$OfLong, $PrimitiveIterator$OfLong$Type} from "packages/java/util/$PrimitiveIterator$OfLong"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$Type as $LongConsumer$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongConsumer"

export interface $LongIterator extends $PrimitiveIterator$OfLong {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $LongConsumer$0$Type): void
 "skip"(arg0: integer): integer
 "nextLong"(): long
 "forEachRemaining"(arg0: $LongConsumer$Type): void
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $LongIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongIterator$Type = ($LongIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongIterator_ = $LongIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ObjectIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export interface $ObjectIterator<K> extends $Iterator<(K)> {

 "skip"(arg0: integer): integer
 "remove"(): void
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "hasNext"(): boolean
 "next"(): K
}

export namespace $ObjectIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectIterator$Type<K> = ($ObjectIterator<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectIterator_<K> = $ObjectIterator$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2FloatMap" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$FloatCollection, $FloatCollection$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatCollection"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Object2FloatMap$Entry, $Object2FloatMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatMap$Entry"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$DoubleBinaryOperator, $DoubleBinaryOperator$Type} from "packages/java/util/function/$DoubleBinaryOperator"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$FloatBinaryOperator, $FloatBinaryOperator$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatBinaryOperator"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Object2FloatMap<K> extends $Object2FloatFunction<(K)>, $Map<(K), (float)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
 "remove"(arg0: any, arg1: float): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: float): float
 "values"(): $FloatCollection
 "clear"(): void
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: float, arg2: float): boolean
 "replace"(arg0: K, arg1: float, arg2: float): boolean
 "replace"(arg0: K, arg1: float): float
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: float): float
 "size"(): integer
 "merge"(arg0: K, arg1: float, arg2: $BiFunction$Type<(any), (any), (any)>): float
/**
 * 
 * @deprecated
 */
 "merge"(arg0: K, arg1: float, arg2: $BiFunction$Type<(any), (any), (any)>): float
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (float)>)>
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: K, arg1: float): float
 "putIfAbsent"(arg0: K, arg1: float): float
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $ToDoubleFunction$Type<(any)>): float
 "computeIfAbsent"(arg0: K, arg1: $Object2FloatFunction$Type<(any)>): float
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "containsValue"(arg0: float): boolean
 "getOrDefault"(arg0: any, arg1: float): float
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
/**
 * 
 * @deprecated
 */
 "computeFloatIfAbsentPartial"(arg0: K, arg1: $Object2FloatFunction$Type<(any)>): float
 "computeFloatIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): float
/**
 * 
 * @deprecated
 */
 "computeFloatIfAbsent"(arg0: K, arg1: $ToDoubleFunction$Type<(any)>): float
 "object2FloatEntrySet"(): $ObjectSet<($Object2FloatMap$Entry<(K)>)>
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
/**
 * 
 * @deprecated
 */
 "mergeFloat"(arg0: K, arg1: float, arg2: $BiFunction$Type<(any), (any), (any)>): float
 "mergeFloat"(arg0: K, arg1: float, arg2: $DoubleBinaryOperator$Type): float
 "mergeFloat"(arg0: K, arg1: float, arg2: $FloatBinaryOperator$Type): float
 "computeFloat"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): float
 "put"(arg0: K, arg1: float): float
 "getFloat"(arg0: any): float
 "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeFloat"(arg0: any): float
 "andThenDouble"(arg0: $Float2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2FloatFunction
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2FloatFunction
 "andThenFloat"(arg0: $Float2FloatFunction$Type): $Object2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2FloatFunction
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2FloatFunction
 "andThenInt"(arg0: $Float2IntFunction$Type): $Object2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$Type): $Object2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2FloatFunction<(T)>
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2FloatFunction<(T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Float2ByteFunction$Type): $Object2ByteFunction<(K)>
 "andThenShort"(arg0: $Float2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2FloatFunction
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): float
 "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): float
 "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): float
 "apply"(arg0: K): float
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (float)>
}

export namespace $Object2FloatMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float): $Map<(K), (float)>
function of<K, V>(): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float, arg12: K, arg13: float, arg14: K, arg15: float, arg16: K, arg17: float, arg18: K, arg19: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float, arg12: K, arg13: float, arg14: K, arg15: float, arg16: K, arg17: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float, arg12: K, arg13: float, arg14: K, arg15: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float, arg12: K, arg13: float): $Map<(K), (float)>
function of<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float): $Map<(K), (float)>
function entry<K, V>(arg0: K, arg1: float): $Map$Entry<(K), (float)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (float)>
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2FloatMap$Type<K> = ($Object2FloatMap<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2FloatMap_<K> = $Object2FloatMap$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2IntSortedMap" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$IntBinaryOperator, $IntBinaryOperator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntBinaryOperator"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$ObjectSortedSet, $ObjectSortedSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSortedSet"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Object2IntMap$Entry, $Object2IntMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntMap$Entry"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$SortedMap, $SortedMap$Type} from "packages/java/util/$SortedMap"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$IntBinaryOperator as $IntBinaryOperator$0, $IntBinaryOperator$Type as $IntBinaryOperator$0$Type} from "packages/java/util/function/$IntBinaryOperator"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Object2IntMap, $Object2IntMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntMap"

export interface $Object2IntSortedMap<K> extends $Object2IntMap<(K)>, $SortedMap<(K), (integer)> {

 "comparator"(): $Comparator<(any)>
 "object2IntEntrySet"(): $ObjectSortedSet<($Object2IntMap$Entry<(K)>)>
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
 "remove"(arg0: any, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: integer): integer
 "clear"(): void
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: integer, arg2: integer): boolean
 "replace"(arg0: K, arg1: integer, arg2: integer): boolean
 "replace"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "replace"(arg0: K, arg1: integer): integer
 "size"(): integer
 "merge"(arg0: K, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
 "merge"(arg0: K, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: K, arg1: integer): integer
 "putIfAbsent"(arg0: K, arg1: integer): integer
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $ToIntFunction$Type<(any)>): integer
 "computeIfAbsent"(arg0: K, arg1: $Object2IntFunction$Type<(any)>): integer
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "containsValue"(arg0: integer): boolean
 "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "mergeInt"(arg0: K, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
 "mergeInt"(arg0: K, arg1: integer, arg2: $IntBinaryOperator$Type): integer
 "mergeInt"(arg0: K, arg1: integer, arg2: $IntBinaryOperator$0$Type): integer
 "computeInt"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
 "computeIntIfAbsent"(arg0: K, arg1: $ToIntFunction$Type<(any)>): integer
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "computeIntIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
 "computeIntIfAbsentPartial"(arg0: K, arg1: $Object2IntFunction$Type<(any)>): integer
 "firstKey"(): K
 "lastKey"(): K
 "put"(arg0: K, arg1: integer): integer
 "getInt"(arg0: any): integer
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2IntFunction
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Object2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2IntFunction
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Object2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$Type): $Object2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2IntFunction<(T)>
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Object2ByteFunction<(K)>
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2IntFunction
 "removeInt"(arg0: any): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
 "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): integer
 "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): integer
 "apply"(arg0: K): integer
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (integer)>
}

export namespace $Object2IntSortedMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer): $Map<(K), (integer)>
function of<K, V>(): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer, arg18: K, arg19: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer): $Map<(K), (integer)>
function of<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer): $Map<(K), (integer)>
function entry<K, V>(arg0: K, arg1: integer): $Map$Entry<(K), (integer)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (integer)>
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2IntSortedMap$Type<K> = ($Object2IntSortedMap<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2IntSortedMap_<K> = $Object2IntSortedMap$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$DoubleToLongFunction, $DoubleToLongFunction$Type} from "packages/java/util/function/$DoubleToLongFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"

export interface $Double2LongFunction extends $Function$0<(double), (long)>, $DoubleToLongFunction {

 "remove"(arg0: double): long
 "get"(arg0: double): long
 "put"(arg0: double, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: long): long
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: double, arg1: long): long
 "applyAsLong"(arg0: double): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(double), (T)>
 "andThenDouble"(arg0: $Long2DoubleFunction$Type): $Double2DoubleFunction
 "composeChar"(arg0: $Char2DoubleFunction$Type): $Char2LongFunction
 "composeShort"(arg0: $Short2DoubleFunction$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2DoubleFunction$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$Type): $Double2LongFunction
 "composeLong"(arg0: $Long2DoubleFunction$Type): $Long2LongFunction
 "composeInt"(arg0: $Int2DoubleFunction$Type): $Int2LongFunction
 "andThenInt"(arg0: $Long2IntFunction$Type): $Double2IntFunction
 "composeDouble"(arg0: $Double2DoubleFunction$Type): $Double2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$Type): $Double2CharFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$Type<(any)>): $Object2LongFunction<(T)>
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$Type<(any)>): $Double2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2DoubleFunction$Type<(any)>): $Reference2LongFunction<(T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$Type<(any)>): $Double2ObjectFunction<(T)>
 "andThenByte"(arg0: $Long2ByteFunction$Type): $Double2ByteFunction
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenShort"(arg0: $Long2ShortFunction$Type): $Double2ShortFunction
 "composeByte"(arg0: $Byte2DoubleFunction$Type): $Byte2LongFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: double): long

(arg0: double): long
}

export namespace $Double2LongFunction {
function identity<T>(): $Function<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2LongFunction$Type = ($Double2LongFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2LongFunction_ = $Double2LongFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Char2BooleanFunction extends $Function$0<(character), (boolean)>, $IntPredicate {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "remove"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: boolean): boolean
 "put"(arg0: character, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
 "getOrDefault"(arg0: character, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(character), (T)>
 "andThenDouble"(arg0: $Boolean2DoubleFunction$Type): $Char2DoubleFunction
 "composeChar"(arg0: $Char2CharFunction$Type): $Char2BooleanFunction
 "composeShort"(arg0: $Short2CharFunction$Type): $Short2BooleanFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$Type): $Char2FloatFunction
 "composeFloat"(arg0: $Float2CharFunction$Type): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$Type): $Char2LongFunction
 "composeLong"(arg0: $Long2CharFunction$Type): $Long2BooleanFunction
 "composeInt"(arg0: $Int2CharFunction$Type): $Int2BooleanFunction
 "andThenInt"(arg0: $Boolean2IntFunction$Type): $Char2IntFunction
 "composeDouble"(arg0: $Double2CharFunction$Type): $Double2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$Type): $Char2CharFunction
 "composeObject"<T>(arg0: $Object2CharFunction$Type<(any)>): $Object2BooleanFunction<(T)>
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$Type<(any)>): $Char2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2CharFunction$Type<(any)>): $Reference2BooleanFunction<(T)>
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$Type<(any)>): $Char2ObjectFunction<(T)>
 "andThenByte"(arg0: $Boolean2ByteFunction$Type): $Char2ByteFunction
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "andThenShort"(arg0: $Boolean2ShortFunction$Type): $Char2ShortFunction
 "composeByte"(arg0: $Byte2CharFunction$Type): $Byte2BooleanFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: character): boolean
 "or"(arg0: $IntPredicate$Type): $IntPredicate
 "and"(arg0: $IntPredicate$Type): $IntPredicate
 "negate"(): $IntPredicate

(arg0: any): boolean
}

export namespace $Char2BooleanFunction {
function identity<T>(): $Function<(character), (character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2BooleanFunction$Type = ($Char2BooleanFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2BooleanFunction_ = $Char2BooleanFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntConsumer"
import {$Spliterator$OfInt, $Spliterator$OfInt$Type} from "packages/java/util/$Spliterator$OfInt"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$Type as $IntConsumer$0$Type} from "packages/java/util/function/$IntConsumer"

export interface $IntSpliterator extends $Spliterator$OfInt {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $IntConsumer$Type): void
 "skip"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "tryAdvance"(arg0: $Consumer$Type<(any)>): boolean
 "tryAdvance"(arg0: $IntConsumer$Type): boolean
 "forEachRemaining"(arg0: $IntConsumer$0$Type): void
 "tryAdvance"(arg0: $IntConsumer$0$Type): boolean
 "characteristics"(): integer
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
}

export namespace $IntSpliterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntSpliterator$Type = ($IntSpliterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntSpliterator_ = $IntSpliterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Reference2IntFunction<K> extends $Function$0<(K), (integer)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): integer
 "put"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: integer): integer
 "getInt"(arg0: any): integer
 "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Reference2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2IntFunction
 "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Reference2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$Type): $Reference2LongFunction<(K)>
 "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2IntFunction
 "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Reference2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$Type): $Reference2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2IntFunction<(T)>
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Reference2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Reference2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Reference2ByteFunction<(K)>
 "defaultReturnValue"(): integer
 "defaultReturnValue"(arg0: integer): void
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Reference2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2IntFunction
 "removeInt"(arg0: any): integer
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): integer
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (integer)>

(arg0: any): integer
}

export namespace $Reference2IntFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2IntFunction$Type<K> = ($Reference2IntFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2IntFunction_<K> = $Reference2IntFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortIterable" {
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$ShortConsumer, $ShortConsumer$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortConsumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export interface $ShortIterable extends $Iterable<(short)> {

 "forEach"(arg0: $ShortConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $IntConsumer$Type): void
 "intSpliterator"(): $IntSpliterator
 "intIterator"(): $IntIterator
}

export namespace $ShortIterable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortIterable$Type = ($ShortIterable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortIterable_ = $ShortIterable$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$ToLongFunction, $ToLongFunction$Type} from "packages/java/util/function/$ToLongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Reference2LongFunction<K> extends $Function$0<(K), (long)>, $ToLongFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): long
 "put"(arg0: K, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: long): long
 "getLong"(arg0: any): long
 "getOrDefault"(arg0: any, arg1: long): long
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "applyAsLong"(arg0: K): long
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "andThenDouble"(arg0: $Long2DoubleFunction$Type): $Reference2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2LongFunction
 "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$Type): $Reference2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$Type): $Reference2LongFunction<(K)>
 "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2LongFunction
 "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2LongFunction
 "andThenInt"(arg0: $Long2IntFunction$Type): $Reference2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$Type): $Reference2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2LongFunction<(T)>
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$Type<(any)>): $Reference2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2LongFunction<(T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$Type<(any)>): $Reference2ObjectFunction<(K), (T)>
 "removeLong"(arg0: any): long
 "andThenByte"(arg0: $Long2ByteFunction$Type): $Reference2ByteFunction<(K)>
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenShort"(arg0: $Long2ShortFunction$Type): $Reference2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2LongFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): long
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (long)>

(arg0: any): long
}

export namespace $Reference2LongFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2LongFunction$Type<K> = ($Reference2LongFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2LongFunction_<K> = $Reference2LongFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$FloatBinaryOperator" {
import {$BinaryOperator, $BinaryOperator$Type} from "packages/java/util/function/$BinaryOperator"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$DoubleBinaryOperator, $DoubleBinaryOperator$Type} from "packages/java/util/function/$DoubleBinaryOperator"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"

export interface $FloatBinaryOperator extends $BinaryOperator<(float)>, $DoubleBinaryOperator {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: float, arg1: float): float
 "apply"(arg0: float, arg1: float): float
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: double, arg1: double): double
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $BiFunction<(float), (float), (V)>

(arg0: float, arg1: float): float
}

export namespace $FloatBinaryOperator {
function maxBy<T>(arg0: $Comparator$Type<(any)>): $BinaryOperator<(float)>
function minBy<T>(arg0: $Comparator$Type<(any)>): $BinaryOperator<(float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatBinaryOperator$Type = ($FloatBinaryOperator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatBinaryOperator_ = $FloatBinaryOperator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Reference2ByteFunction<K> extends $Function$0<(K), (byte)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): byte
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): byte
 "put"(arg0: K, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: byte): byte
 "getByte"(arg0: any): byte
 "getOrDefault"(arg0: any, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeByte"(arg0: any): byte
 "andThenDouble"(arg0: $Byte2DoubleFunction$Type): $Reference2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2ByteFunction
 "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2ByteFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$Type): $Reference2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$Type): $Reference2LongFunction<(K)>
 "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2ByteFunction
 "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2ByteFunction
 "andThenInt"(arg0: $Byte2IntFunction$Type): $Reference2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$Type): $Reference2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2ByteFunction<(T)>
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$Type<(any)>): $Reference2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2ByteFunction<(T)>
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$Type<(any)>): $Reference2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Byte2ByteFunction$Type): $Reference2ByteFunction<(K)>
 "defaultReturnValue"(): byte
 "defaultReturnValue"(arg0: byte): void
 "andThenShort"(arg0: $Byte2ShortFunction$Type): $Reference2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2ByteFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): byte
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (byte)>

(arg0: any): byte
}

export namespace $Reference2ByteFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2ByteFunction$Type<K> = ($Reference2ByteFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2ByteFunction_<K> = $Reference2ByteFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceMap" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Reference2ReferenceMap$Entry, $Reference2ReferenceMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceMap$Entry"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ReferenceCollection, $ReferenceCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ReferenceCollection"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Reference2ReferenceMap<K, V> extends $Reference2ReferenceFunction<(K), (V)>, $Map<(K), (V)> {

 "remove"(arg0: any): V
 "remove"(arg0: any, arg1: any): boolean
 "put"(arg0: K, arg1: V): V
 "values"(): $ReferenceCollection<(V)>
 "clear"(): void
 "replace"(arg0: K, arg1: V, arg2: V): boolean
 "replace"(arg0: K, arg1: V): V
 "size"(): integer
 "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (V)>)>
 "putIfAbsent"(arg0: K, arg1: V): V
 "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $Reference2ReferenceFunction$Type<(any), (any)>): V
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
/**
 * 
 * @deprecated
 */
 "computeReferenceIfAbsentPartial"(arg0: K, arg1: $Reference2ReferenceFunction$Type<(any), (any)>): V
 "reference2ReferenceEntrySet"(): $ObjectSet<($Reference2ReferenceMap$Entry<(K), (V)>)>
 "get"(arg0: any): V
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Reference2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2ReferenceFunction<(V)>
 "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Reference2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Reference2LongFunction<(K)>
 "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2ReferenceFunction<(V)>
 "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Reference2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Reference2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Reference2ByteFunction<(K)>
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Reference2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2ReferenceFunction<(V)>
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): V
 "containsValue"(arg0: any): boolean
 "apply"(arg0: K): V
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (V)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(K), (V)>
}

export namespace $Reference2ReferenceMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
function of<K, V>(): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
function entry<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2ReferenceMap$Type<K, V> = ($Reference2ReferenceMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2ReferenceMap_<K, V> = $Reference2ReferenceMap$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntBidirectionalIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$IntConsumer, $IntConsumer$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntConsumer"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$Type as $IntConsumer$0$Type} from "packages/java/util/function/$IntConsumer"
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterator"

export interface $IntBidirectionalIterator extends $IntIterator, $ObjectBidirectionalIterator<(integer)> {

 "skip"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "previous"(): integer
 "back"(arg0: integer): integer
 "previousInt"(): integer
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $IntConsumer$Type): void
 "nextInt"(): integer
 "forEachRemaining"(arg0: $IntConsumer$0$Type): void
 "hasPrevious"(): boolean
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $IntBidirectionalIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntBidirectionalIterator$Type = ($IntBidirectionalIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntBidirectionalIterator_ = $IntBidirectionalIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Boolean2ReferenceFunction<V> extends $Function$0<(boolean), (V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: boolean): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: boolean): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: V): V
 "put"(arg0: boolean, arg1: V): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: boolean, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Boolean2DoubleFunction
 "composeChar"(arg0: $Char2BooleanFunction$Type): $Char2ReferenceFunction<(V)>
 "composeShort"(arg0: $Short2BooleanFunction$Type): $Short2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Boolean2FloatFunction
 "composeFloat"(arg0: $Float2BooleanFunction$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Boolean2LongFunction
 "composeLong"(arg0: $Long2BooleanFunction$Type): $Long2ReferenceFunction<(V)>
 "composeInt"(arg0: $Int2BooleanFunction$Type): $Int2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Boolean2IntFunction
 "composeDouble"(arg0: $Double2BooleanFunction$Type): $Double2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Boolean2CharFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$Type<(any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Boolean2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2BooleanFunction$Type<(any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Boolean2ObjectFunction<(T)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Boolean2ByteFunction
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Boolean2ShortFunction
 "composeByte"(arg0: $Byte2BooleanFunction$Type): $Byte2ReferenceFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: boolean): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(boolean), (V)>

(arg0: any): V
}

export namespace $Boolean2ReferenceFunction {
function identity<T>(): $Function<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2ReferenceFunction$Type<V> = ($Boolean2ReferenceFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2ReferenceFunction_<V> = $Boolean2ReferenceFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ObjectArrayList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$AbstractObjectList, $AbstractObjectList$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractObjectList"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Collector, $Collector$Type} from "packages/java/util/stream/$Collector"
import {$ObjectSpliterator, $ObjectSpliterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSpliterator"
import {$ObjectCollection, $ObjectCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectCollection"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectList, $ObjectList$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectList"
import {$ObjectIterator, $ObjectIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectIterator"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$RandomAccess, $RandomAccess$Type} from "packages/java/util/$RandomAccess"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $ObjectArrayList<K> extends $AbstractObjectList<(K)> implements $RandomAccess, $Cloneable, $Serializable {
static readonly "DEFAULT_INITIAL_CAPACITY": integer

constructor()
constructor(arg0: $Collection$Type<(any)>)
constructor(arg0: $ObjectCollection$Type<(any)>)
constructor(arg0: $ObjectList$Type<(any)>)
constructor(arg0: (K)[])
constructor(arg0: (K)[], arg1: integer, arg2: integer)
constructor(arg0: $ObjectIterator$Type<(any)>)
constructor(arg0: $Iterator$Type<(any)>)
constructor(arg0: integer)

public "add"(arg0: integer, arg1: K): void
public "add"(arg0: K): boolean
public "remove"(arg0: any): boolean
public "remove"(arg0: integer): K
public "get"(arg0: integer): K
public "equals"(arg0: $ObjectArrayList$Type<(K)>): boolean
public "equals"(arg0: any): boolean
public "compareTo"(arg0: $List$Type<(any)>): integer
public "compareTo"(arg0: $ObjectArrayList$Type<(any)>): integer
public "indexOf"(arg0: any): integer
public "clear"(): void
public static "wrap"<K>(arg0: (K)[]): $ObjectArrayList<(K)>
public static "wrap"<K>(arg0: (K)[], arg1: integer): $ObjectArrayList<(K)>
public "lastIndexOf"(arg0: any): integer
public "isEmpty"(): boolean
public "size"(arg0: integer): void
public "size"(): integer
public "toArray"<K>(arg0: (K)[]): (K)[]
public "toArray"(): (any)[]
public "trim"(arg0: integer): void
public "trim"(): void
public static "toList"<K>(): $Collector<(K), (any), ($ObjectArrayList<(K)>)>
public static "of"<K>(...arg0: (K)[]): $ObjectArrayList<(K)>
public static "of"<K>(): $ObjectArrayList<(K)>
public "elements"(): (K)[]
public "spliterator"(): $ObjectSpliterator<(K)>
public "addAll"(arg0: integer, arg1: $ObjectList$Type<(any)>): boolean
public "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
public "set"(arg0: integer, arg1: K): K
public "forEach"(arg0: $Consumer$Type<(any)>): void
public "ensureCapacity"(arg0: integer): void
public "sort"(arg0: $Comparator$Type<(any)>): void
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "unstableSort"(arg0: $Comparator$Type<(any)>): void
public "addElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
public "removeElements"(arg0: integer, arg1: integer): void
public "getElements"(arg0: integer, arg1: (any)[], arg2: integer, arg3: integer): void
public "setElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
public static "toListWithExpectedSize"<K>(arg0: integer): $Collector<(K), (any), ($ObjectArrayList<(K)>)>
public static "of"<K>(arg0: K, arg1: K, arg2: K): $ObjectList<(K)>
public static "of"<K>(arg0: K, arg1: K): $ObjectList<(K)>
public static "of"<K>(arg0: K): $ObjectList<(K)>
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $List<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $List<(E)>
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectArrayList$Type<K> = ($ObjectArrayList<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectArrayList_<K> = $ObjectArrayList$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/$Stack" {
export {} // Mark the file as a module, do not remove unless there are other import/exports!
export interface $Stack<K> {

 "isEmpty"(): boolean
 "top"(): K
 "peek"(arg0: integer): K
 "push"(arg0: K): void
 "pop"(): K
}

export namespace $Stack {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Stack$Type<K> = ($Stack<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Stack_<K> = $Stack$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2LongMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Object2LongMap$Entry<K> extends $Map$Entry<(K), (long)> {

/**
 * 
 * @deprecated
 */
 "getValue"(): long
/**
 * 
 * @deprecated
 */
 "setValue"(arg0: long): long
 "setValue"(arg0: long): long
 "getLongValue"(): long
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "getKey"(): K
}

export namespace $Object2LongMap$Entry {
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(K), (long)>)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (long)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(K), (long)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (long)>)>
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(K), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2LongMap$Entry$Type<K> = ($Object2LongMap$Entry<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2LongMap$Entry_<K> = $Object2LongMap$Entry$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$DoubleToIntFunction, $DoubleToIntFunction$Type} from "packages/java/util/function/$DoubleToIntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Float2CharFunction extends $Function$0<(float), (character)>, $DoubleToIntFunction {

 "remove"(arg0: float): character
 "get"(arg0: float): character
 "put"(arg0: float, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: character): character
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: float, arg1: character): character
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(float), (T)>
 "andThenDouble"(arg0: $Char2DoubleFunction$Type): $Float2DoubleFunction
 "composeChar"(arg0: $Char2FloatFunction$Type): $Char2CharFunction
 "composeShort"(arg0: $Short2FloatFunction$Type): $Short2CharFunction
 "andThenFloat"(arg0: $Char2FloatFunction$Type): $Float2FloatFunction
 "composeFloat"(arg0: $Float2FloatFunction$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$Type): $Float2LongFunction
 "composeLong"(arg0: $Long2FloatFunction$Type): $Long2CharFunction
 "composeInt"(arg0: $Int2FloatFunction$Type): $Int2CharFunction
 "andThenInt"(arg0: $Char2IntFunction$Type): $Float2IntFunction
 "composeDouble"(arg0: $Double2FloatFunction$Type): $Double2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$Type): $Float2CharFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$Type<(any)>): $Object2CharFunction<(T)>
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$Type<(any)>): $Float2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2FloatFunction$Type<(any)>): $Reference2CharFunction<(T)>
 "andThenObject"<T>(arg0: $Char2ObjectFunction$Type<(any)>): $Float2ObjectFunction<(T)>
 "andThenByte"(arg0: $Char2ByteFunction$Type): $Float2ByteFunction
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "andThenShort"(arg0: $Char2ShortFunction$Type): $Float2ShortFunction
 "composeByte"(arg0: $Byte2FloatFunction$Type): $Byte2CharFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: float): character

(arg0: float): character
}

export namespace $Float2CharFunction {
function identity<T>(): $Function<(float), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2CharFunction$Type = ($Float2CharFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2CharFunction_ = $Float2CharFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction" {
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Int2ReferenceFunction<V> extends $Function$0<(integer), (V)>, $IntFunction<(V)> {

 "remove"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: V): V
 "put"(arg0: integer, arg1: V): V
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Int2DoubleFunction
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2ReferenceFunction<(V)>
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Int2FloatFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2ReferenceFunction<(V)>
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Int2IntFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Int2CharFunction
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Int2ObjectFunction<(T)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Int2ByteFunction
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Int2ShortFunction
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2ReferenceFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: integer): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (V)>

(arg0: integer): V
}

export namespace $Int2ReferenceFunction {
function identity<T>(): $Function<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2ReferenceFunction$Type<V> = ($Int2ReferenceFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2ReferenceFunction_<V> = $Int2ReferenceFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$DoubleToIntFunction, $DoubleToIntFunction$Type} from "packages/java/util/function/$DoubleToIntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Float2ShortFunction extends $Function$0<(float), (short)>, $DoubleToIntFunction {

 "remove"(arg0: float): short
 "get"(arg0: float): short
 "put"(arg0: float, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: short): short
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: float, arg1: short): short
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(float), (T)>
 "andThenDouble"(arg0: $Short2DoubleFunction$Type): $Float2DoubleFunction
 "composeChar"(arg0: $Char2FloatFunction$Type): $Char2ShortFunction
 "composeShort"(arg0: $Short2FloatFunction$Type): $Short2ShortFunction
 "andThenFloat"(arg0: $Short2FloatFunction$Type): $Float2FloatFunction
 "composeFloat"(arg0: $Float2FloatFunction$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$Type): $Float2LongFunction
 "composeLong"(arg0: $Long2FloatFunction$Type): $Long2ShortFunction
 "composeInt"(arg0: $Int2FloatFunction$Type): $Int2ShortFunction
 "andThenInt"(arg0: $Short2IntFunction$Type): $Float2IntFunction
 "composeDouble"(arg0: $Double2FloatFunction$Type): $Double2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$Type): $Float2CharFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$Type<(any)>): $Object2ShortFunction<(T)>
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$Type<(any)>): $Float2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2FloatFunction$Type<(any)>): $Reference2ShortFunction<(T)>
 "andThenObject"<T>(arg0: $Short2ObjectFunction$Type<(any)>): $Float2ObjectFunction<(T)>
 "andThenByte"(arg0: $Short2ByteFunction$Type): $Float2ByteFunction
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "andThenShort"(arg0: $Short2ShortFunction$Type): $Float2ShortFunction
 "composeByte"(arg0: $Byte2FloatFunction$Type): $Byte2ShortFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: float): short

(arg0: float): short
}

export namespace $Float2ShortFunction {
function identity<T>(): $Function<(float), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2ShortFunction$Type = ($Float2ShortFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2ShortFunction_ = $Float2ShortFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$FloatCollection" {
import {$FloatConsumer, $FloatConsumer$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatConsumer"
import {$FloatIterator, $FloatIterator$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatIterator"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$DoubleSpliterator, $DoubleSpliterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleSpliterator"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/java/util/function/$DoubleConsumer"
import {$FloatIterable, $FloatIterable$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatIterable"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$FloatPredicate, $FloatPredicate$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatPredicate"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$DoubleIterator, $DoubleIterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleIterator"
import {$DoublePredicate, $DoublePredicate$Type} from "packages/java/util/function/$DoublePredicate"

export interface $FloatCollection extends $Collection<(float)>, $FloatIterable {

 "add"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "toArray"(arg0: (float)[]): (float)[]
 "iterator"(): $FloatIterator
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(float)>
 "contains"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "addAll"(arg0: $FloatCollection$Type): boolean
 "removeIf"(arg0: $FloatPredicate$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $DoublePredicate$Type): boolean
 "removeAll"(arg0: $FloatCollection$Type): boolean
 "retainAll"(arg0: $FloatCollection$Type): boolean
 "containsAll"(arg0: $FloatCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(float)>
 "rem"(arg0: float): boolean
 "doubleStream"(): $DoubleStream
 "doubleSpliterator"(): $DoubleSpliterator
 "doubleIterator"(): $DoubleIterator
 "doubleParallelStream"(): $DoubleStream
 "toFloatArray"(): (float)[]
/**
 * 
 * @deprecated
 */
 "toFloatArray"(arg0: (float)[]): (float)[]
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "forEach"(arg0: $FloatConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $DoubleConsumer$Type): void
}

export namespace $FloatCollection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $FloatCollection$Type = ($FloatCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $FloatCollection_ = $FloatCollection$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongIterable" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$LongSpliterator, $LongSpliterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSpliterator"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$Type as $LongConsumer$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongConsumer"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"
import {$LongIterator, $LongIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIterator"

export interface $LongIterable extends $Iterable<(long)> {

 "forEach"(arg0: $LongConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $LongConsumer$0$Type): void
 "longIterator"(): $LongIterator
 "longSpliterator"(): $LongSpliterator
}

export namespace $LongIterable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongIterable$Type = ($LongIterable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongIterable_ = $LongIterable$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction" {
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Boolean2ByteFunction extends $Function$0<(boolean), (byte)> {

 "remove"(arg0: boolean): byte
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): byte
 "get"(arg0: boolean): byte
 "put"(arg0: boolean, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: byte): byte
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: boolean, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(boolean), (T)>
 "andThenDouble"(arg0: $Byte2DoubleFunction$Type): $Boolean2DoubleFunction
 "composeChar"(arg0: $Char2BooleanFunction$Type): $Char2ByteFunction
 "composeShort"(arg0: $Short2BooleanFunction$Type): $Short2ByteFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$Type): $Boolean2FloatFunction
 "composeFloat"(arg0: $Float2BooleanFunction$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$Type): $Boolean2LongFunction
 "composeLong"(arg0: $Long2BooleanFunction$Type): $Long2ByteFunction
 "composeInt"(arg0: $Int2BooleanFunction$Type): $Int2ByteFunction
 "andThenInt"(arg0: $Byte2IntFunction$Type): $Boolean2IntFunction
 "composeDouble"(arg0: $Double2BooleanFunction$Type): $Double2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$Type): $Boolean2CharFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$Type<(any)>): $Object2ByteFunction<(T)>
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$Type<(any)>): $Boolean2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2BooleanFunction$Type<(any)>): $Reference2ByteFunction<(T)>
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$Type<(any)>): $Boolean2ObjectFunction<(T)>
 "andThenByte"(arg0: $Byte2ByteFunction$Type): $Boolean2ByteFunction
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "andThenShort"(arg0: $Byte2ShortFunction$Type): $Boolean2ShortFunction
 "composeByte"(arg0: $Byte2BooleanFunction$Type): $Byte2ByteFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: boolean): byte

(arg0: boolean): byte
}

export namespace $Boolean2ByteFunction {
function identity<T>(): $Function<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2ByteFunction$Type = ($Boolean2ByteFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2ByteFunction_ = $Boolean2ByteFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$AbstractInt2ObjectFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export class $AbstractInt2ObjectFunction<V> implements $Int2ObjectFunction<(V)>, $Serializable {


public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public "remove"(arg0: integer): V
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
public "get"(arg0: any): V
public "get"(arg0: integer): V
/**
 * 
 * @deprecated
 */
public "put"(arg0: integer, arg1: V): V
public "put"(arg0: integer, arg1: V): V
public "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
public "containsKey"(arg0: any): boolean
public "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
public "getOrDefault"(arg0: any, arg1: V): V
public "getOrDefault"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
public "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
public "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Int2DoubleFunction
public "composeChar"(arg0: $Char2IntFunction$Type): $Char2ObjectFunction<(V)>
public "composeShort"(arg0: $Short2IntFunction$Type): $Short2ObjectFunction<(V)>
public "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Int2FloatFunction
public "composeFloat"(arg0: $Float2IntFunction$Type): $Float2ObjectFunction<(V)>
public "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Int2LongFunction
public "composeLong"(arg0: $Long2IntFunction$Type): $Long2ObjectFunction<(V)>
public "composeInt"(arg0: $Int2IntFunction$Type): $Int2ObjectFunction<(V)>
public "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Int2IntFunction
public "composeDouble"(arg0: $Double2IntFunction$Type): $Double2ObjectFunction<(V)>
public "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Int2CharFunction
public "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
public "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Int2ReferenceFunction<(T)>
public "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
public "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Int2ObjectFunction<(T)>
public "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Int2ByteFunction
public "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Int2ShortFunction
public "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2ObjectFunction<(V)>
public "clear"(): void
public "size"(): integer
public "apply"(arg0: integer): V
public static "identity"<T>(): $Function<(integer), (integer)>
public "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractInt2ObjectFunction$Type<V> = ($AbstractInt2ObjectFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractInt2ObjectFunction_<V> = $AbstractInt2ObjectFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$DoubleToIntFunction, $DoubleToIntFunction$Type} from "packages/java/util/function/$DoubleToIntFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Double2CharFunction extends $Function$0<(double), (character)>, $DoubleToIntFunction {

 "remove"(arg0: double): character
 "get"(arg0: double): character
 "put"(arg0: double, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: character): character
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "getOrDefault"(arg0: double, arg1: character): character
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(double), (T)>
 "andThenDouble"(arg0: $Char2DoubleFunction$Type): $Double2DoubleFunction
 "composeChar"(arg0: $Char2DoubleFunction$Type): $Char2CharFunction
 "composeShort"(arg0: $Short2DoubleFunction$Type): $Short2CharFunction
 "andThenFloat"(arg0: $Char2FloatFunction$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2DoubleFunction$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$Type): $Double2LongFunction
 "composeLong"(arg0: $Long2DoubleFunction$Type): $Long2CharFunction
 "composeInt"(arg0: $Int2DoubleFunction$Type): $Int2CharFunction
 "andThenInt"(arg0: $Char2IntFunction$Type): $Double2IntFunction
 "composeDouble"(arg0: $Double2DoubleFunction$Type): $Double2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$Type): $Double2CharFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$Type<(any)>): $Object2CharFunction<(T)>
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$Type<(any)>): $Double2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2DoubleFunction$Type<(any)>): $Reference2CharFunction<(T)>
 "andThenObject"<T>(arg0: $Char2ObjectFunction$Type<(any)>): $Double2ObjectFunction<(T)>
 "andThenByte"(arg0: $Char2ByteFunction$Type): $Double2ByteFunction
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "andThenShort"(arg0: $Char2ShortFunction$Type): $Double2ShortFunction
 "composeByte"(arg0: $Byte2DoubleFunction$Type): $Byte2CharFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: double): character

(arg0: double): character
}

export namespace $Double2CharFunction {
function identity<T>(): $Function<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2CharFunction$Type = ($Double2CharFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2CharFunction_ = $Double2CharFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortPredicate" {
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"

export interface $ShortPredicate extends $Predicate<(short)>, $IntPredicate {

/**
 * 
 * @deprecated
 */
 "test"(arg0: short): boolean
 "test"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
 "or"(arg0: $ShortPredicate$Type): $ShortPredicate
 "or"(arg0: $IntPredicate$Type): $ShortPredicate
/**
 * 
 * @deprecated
 */
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(short)>
 "and"(arg0: $ShortPredicate$Type): $ShortPredicate
/**
 * 
 * @deprecated
 */
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(short)>
 "negate"(): $ShortPredicate

(arg0: short): boolean
}

export namespace $ShortPredicate {
function isEqual<T>(arg0: any): $Predicate<(short)>
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortPredicate$Type = ($ShortPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortPredicate_ = $ShortPredicate$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntBinaryOperator" {
import {$BinaryOperator, $BinaryOperator$Type} from "packages/java/util/function/$BinaryOperator"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$IntBinaryOperator as $IntBinaryOperator$0, $IntBinaryOperator$Type as $IntBinaryOperator$0$Type} from "packages/java/util/function/$IntBinaryOperator"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"

export interface $IntBinaryOperator extends $BinaryOperator<(integer)>, $IntBinaryOperator$0 {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer, arg1: integer): integer
 "apply"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer, arg1: integer): integer
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $BiFunction<(integer), (integer), (V)>

(arg0: integer, arg1: integer): integer
}

export namespace $IntBinaryOperator {
function maxBy<T>(arg0: $Comparator$Type<(any)>): $BinaryOperator<(integer)>
function minBy<T>(arg0: $Comparator$Type<(any)>): $BinaryOperator<(integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntBinaryOperator$Type = ($IntBinaryOperator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntBinaryOperator_ = $IntBinaryOperator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Char2ReferenceFunction<V> extends $Function$0<(character), (V)>, $IntFunction<(V)> {

 "remove"(arg0: character): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: character): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: V): V
 "put"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Char2DoubleFunction
 "composeChar"(arg0: $Char2CharFunction$Type): $Char2ReferenceFunction<(V)>
 "composeShort"(arg0: $Short2CharFunction$Type): $Short2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Char2FloatFunction
 "composeFloat"(arg0: $Float2CharFunction$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Char2LongFunction
 "composeLong"(arg0: $Long2CharFunction$Type): $Long2ReferenceFunction<(V)>
 "composeInt"(arg0: $Int2CharFunction$Type): $Int2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Char2IntFunction
 "composeDouble"(arg0: $Double2CharFunction$Type): $Double2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Char2CharFunction
 "composeObject"<T>(arg0: $Object2CharFunction$Type<(any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Char2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2CharFunction$Type<(any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Char2ObjectFunction<(T)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Char2ByteFunction
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Char2ShortFunction
 "composeByte"(arg0: $Byte2CharFunction$Type): $Byte2ReferenceFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: character): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(character), (V)>

(arg0: character): V
}

export namespace $Char2ReferenceFunction {
function identity<T>(): $Function<(character), (character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2ReferenceFunction$Type<V> = ($Char2ReferenceFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2ReferenceFunction_<V> = $Char2ReferenceFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceMap" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Object2ReferenceMap$Entry, $Object2ReferenceMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceMap$Entry"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$ReferenceCollection, $ReferenceCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ReferenceCollection"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Object2ReferenceMap<K, V> extends $Object2ReferenceFunction<(K), (V)>, $Map<(K), (V)> {

 "remove"(arg0: any): V
 "remove"(arg0: any, arg1: any): boolean
 "put"(arg0: K, arg1: V): V
 "values"(): $ReferenceCollection<(V)>
 "clear"(): void
 "replace"(arg0: K, arg1: V, arg2: V): boolean
 "replace"(arg0: K, arg1: V): V
 "size"(): integer
 "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
 "entrySet"(): $ObjectSet<($Map$Entry<(K), (V)>)>
 "putIfAbsent"(arg0: K, arg1: V): V
 "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $Object2ReferenceFunction$Type<(any), (any)>): V
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "object2ReferenceEntrySet"(): $ObjectSet<($Object2ReferenceMap$Entry<(K), (V)>)>
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
/**
 * 
 * @deprecated
 */
 "computeReferenceIfAbsentPartial"(arg0: K, arg1: $Object2ReferenceFunction$Type<(any), (any)>): V
 "get"(arg0: any): V
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Object2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2ReferenceFunction<(V)>
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Object2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2ReferenceFunction<(V)>
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Object2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Object2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Object2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Object2ByteFunction<(K)>
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Object2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2ReferenceFunction<(V)>
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): V
 "containsValue"(arg0: any): boolean
 "apply"(arg0: K): V
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (V)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(K), (V)>
}

export namespace $Object2ReferenceMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
function of<K, V>(): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
function entry<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ReferenceMap$Type<K, V> = ($Object2ReferenceMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ReferenceMap_<K, V> = $Object2ReferenceMap$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$AbstractIntSet" {
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$AbstractIntCollection, $AbstractIntCollection$Type} from "packages/it/unimi/dsi/fastutil/ints/$AbstractIntCollection"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$IntSet, $IntSet$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSet"

export class $AbstractIntSet extends $AbstractIntCollection implements $Cloneable, $IntSet {


public "remove"(arg0: integer): boolean
public "equals"(arg0: any): boolean
public "hashCode"(): integer
public "iterator"(): $IntIterator
/**
 * 
 * @deprecated
 */
public "rem"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
public "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
public static "of"(arg0: integer, arg1: integer): $IntSet
public static "of"(): $IntSet
public static "of"(...arg0: (integer)[]): $IntSet
public static "of"(arg0: integer): $IntSet
public static "of"(arg0: integer, arg1: integer, arg2: integer): $IntSet
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public "spliterator"(): $IntSpliterator
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $Set<(integer)>
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): $Set<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer): $Set<(integer)>
public static "of"<E>(arg0: integer): $Set<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $Set<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): $Set<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer): $Set<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): $Set<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer): $Set<(integer)>
public static "of"<E>(...arg0: (integer)[]): $Set<(integer)>
public static "of"<E>(arg0: integer, arg1: integer, arg2: integer): $Set<(integer)>
public static "of"<E>(arg0: integer, arg1: integer): $Set<(integer)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractIntSet$Type = ($AbstractIntSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractIntSet_ = $AbstractIntSet$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Char2ByteFunction extends $Function$0<(character), (byte)>, $IntUnaryOperator {

 "remove"(arg0: character): byte
 "get"(arg0: character): byte
 "put"(arg0: character, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: byte): byte
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: character, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(character), (T)>
 "andThenDouble"(arg0: $Byte2DoubleFunction$Type): $Char2DoubleFunction
 "composeChar"(arg0: $Char2CharFunction$Type): $Char2ByteFunction
 "composeShort"(arg0: $Short2CharFunction$Type): $Short2ByteFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$Type): $Char2FloatFunction
 "composeFloat"(arg0: $Float2CharFunction$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$Type): $Char2LongFunction
 "composeLong"(arg0: $Long2CharFunction$Type): $Long2ByteFunction
 "composeInt"(arg0: $Int2CharFunction$Type): $Int2ByteFunction
 "andThenInt"(arg0: $Byte2IntFunction$Type): $Char2IntFunction
 "composeDouble"(arg0: $Double2CharFunction$Type): $Double2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$Type): $Char2CharFunction
 "composeObject"<T>(arg0: $Object2CharFunction$Type<(any)>): $Object2ByteFunction<(T)>
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$Type<(any)>): $Char2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2CharFunction$Type<(any)>): $Reference2ByteFunction<(T)>
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$Type<(any)>): $Char2ObjectFunction<(T)>
 "andThenByte"(arg0: $Byte2ByteFunction$Type): $Char2ByteFunction
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "andThenShort"(arg0: $Byte2ShortFunction$Type): $Char2ShortFunction
 "composeByte"(arg0: $Byte2CharFunction$Type): $Byte2ByteFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: character): byte
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: character): byte
}

export namespace $Char2ByteFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2ByteFunction$Type = ($Char2ByteFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2ByteFunction_ = $Char2ByteFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Byte2ReferenceFunction<V> extends $Function$0<(byte), (V)>, $IntFunction<(V)> {

 "remove"(arg0: byte): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: byte): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: V): V
 "put"(arg0: byte, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: byte, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Byte2DoubleFunction
 "composeChar"(arg0: $Char2ByteFunction$Type): $Char2ReferenceFunction<(V)>
 "composeShort"(arg0: $Short2ByteFunction$Type): $Short2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Byte2FloatFunction
 "composeFloat"(arg0: $Float2ByteFunction$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Byte2LongFunction
 "composeLong"(arg0: $Long2ByteFunction$Type): $Long2ReferenceFunction<(V)>
 "composeInt"(arg0: $Int2ByteFunction$Type): $Int2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Byte2IntFunction
 "composeDouble"(arg0: $Double2ByteFunction$Type): $Double2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Byte2CharFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$Type<(any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Byte2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ByteFunction$Type<(any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Byte2ObjectFunction<(T)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Byte2ByteFunction
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Byte2ShortFunction
 "composeByte"(arg0: $Byte2ByteFunction$Type): $Byte2ReferenceFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: byte): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(byte), (V)>

(arg0: byte): V
}

export namespace $Byte2ReferenceFunction {
function identity<T>(): $Function<(byte), (byte)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2ReferenceFunction$Type<V> = ($Byte2ReferenceFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2ReferenceFunction_<V> = $Byte2ReferenceFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongSet" {
import {$LongStream, $LongStream$Type} from "packages/java/util/stream/$LongStream"
import {$LongSpliterator, $LongSpliterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSpliterator"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$LongIterator, $LongIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIterator"
import {$LongPredicate, $LongPredicate$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongPredicate"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LongPredicate as $LongPredicate$0, $LongPredicate$Type as $LongPredicate$0$Type} from "packages/java/util/function/$LongPredicate"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$Type as $LongConsumer$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongConsumer"
import {$LongCollection, $LongCollection$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongCollection"

export interface $LongSet extends $LongCollection, $Set<(long)> {

/**
 * 
 * @deprecated
 */
 "add"(arg0: long): boolean
 "remove"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $LongSpliterator
/**
 * 
 * @deprecated
 */
 "rem"(arg0: long): boolean
 "add"(arg0: long): boolean
 "toArray"(arg0: (long)[]): (long)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(long)>
 "contains"(arg0: long): boolean
 "addAll"(arg0: $LongCollection$Type): boolean
 "removeIf"(arg0: $LongPredicate$0$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $LongPredicate$Type): boolean
 "removeAll"(arg0: $LongCollection$Type): boolean
 "retainAll"(arg0: $LongCollection$Type): boolean
 "containsAll"(arg0: $LongCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(long)>
 "longStream"(): $LongStream
 "toLongArray"(): (long)[]
/**
 * 
 * @deprecated
 */
 "toLongArray"(arg0: (long)[]): (long)[]
 "longIterator"(): $LongIterator
 "longParallelStream"(): $LongStream
 "longSpliterator"(): $LongSpliterator
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "forEach"(arg0: $LongConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $LongConsumer$0$Type): void
}

export namespace $LongSet {
function of(arg0: long, arg1: long): $LongSet
function of(): $LongSet
function of(...arg0: (long)[]): $LongSet
function of(arg0: long): $LongSet
function of(arg0: long, arg1: long, arg2: long): $LongSet
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long): $Set<(long)>
function of<E>(arg0: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long, arg9: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long): $Set<(long)>
function of<E>(...arg0: (long)[]): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long): $Set<(long)>
function of<E>(arg0: long, arg1: long): $Set<(long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongSet$Type = ($LongSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongSet_ = $LongSet$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectOpenHashMap" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Hash, $Hash$Type} from "packages/it/unimi/dsi/fastutil/$Hash"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$Object2ObjectMap, $Object2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap"
import {$AbstractObject2ObjectMap, $AbstractObject2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2ObjectMap"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $Object2ObjectOpenHashMap<K, V> extends $AbstractObject2ObjectMap<(K), (V)> implements $Serializable, $Cloneable, $Hash {

constructor(arg0: $Map$Type<(any), (any)>)
constructor(arg0: $Object2ObjectMap$Type<(K), (V)>, arg1: float)
constructor(arg0: $Object2ObjectMap$Type<(K), (V)>)
constructor(arg0: (K)[], arg1: (V)[], arg2: float)
constructor(arg0: (K)[], arg1: (V)[])
constructor(arg0: integer, arg1: float)
constructor(arg0: integer)
constructor()
constructor(arg0: $Map$Type<(any), (any)>, arg1: float)

public "remove"(arg0: any, arg1: any): boolean
public "remove"(arg0: any): V
public "get"(arg0: any): V
public "put"(arg0: K, arg1: V): V
public "hashCode"(): integer
public "clear"(): void
public "isEmpty"(): boolean
public "replace"(arg0: K, arg1: V, arg2: V): boolean
public "replace"(arg0: K, arg1: V): V
public "size"(): integer
public "trim"(): boolean
public "trim"(arg0: integer): boolean
public "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "putIfAbsent"(arg0: K, arg1: V): V
public "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "containsKey"(arg0: any): boolean
public "computeIfAbsent"(arg0: K, arg1: $Object2ObjectFunction$Type<(any), (any)>): V
public "keySet"(): $ObjectSet<(K)>
public "containsValue"(arg0: any): boolean
public "getOrDefault"(arg0: any, arg1: V): V
public "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ObjectOpenHashMap$Type<K, V> = ($Object2ObjectOpenHashMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ObjectOpenHashMap_<K, V> = $Object2ObjectOpenHashMap$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ObjectListIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterator"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"

export interface $ObjectListIterator<K> extends $ObjectBidirectionalIterator<(K)>, $ListIterator<(K)> {

 "add"(arg0: K): void
 "remove"(): void
 "set"(arg0: K): void
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "hasNext"(): boolean
 "next"(): K
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
 "previous"(): K
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
}

export namespace $ObjectListIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectListIterator$Type<K> = ($ObjectListIterator<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectListIterator_<K> = $ObjectListIterator$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$DoubleToLongFunction, $DoubleToLongFunction$Type} from "packages/java/util/function/$DoubleToLongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"

export interface $Float2LongFunction extends $Function$0<(float), (long)>, $DoubleToLongFunction {

 "remove"(arg0: float): long
 "get"(arg0: float): long
 "put"(arg0: float, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: long): long
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: float, arg1: long): long
/**
 * 
 * @deprecated
 */
 "applyAsLong"(arg0: double): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(float), (T)>
 "andThenDouble"(arg0: $Long2DoubleFunction$Type): $Float2DoubleFunction
 "composeChar"(arg0: $Char2FloatFunction$Type): $Char2LongFunction
 "composeShort"(arg0: $Short2FloatFunction$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$Type): $Float2FloatFunction
 "composeFloat"(arg0: $Float2FloatFunction$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$Type): $Float2LongFunction
 "composeLong"(arg0: $Long2FloatFunction$Type): $Long2LongFunction
 "composeInt"(arg0: $Int2FloatFunction$Type): $Int2LongFunction
 "andThenInt"(arg0: $Long2IntFunction$Type): $Float2IntFunction
 "composeDouble"(arg0: $Double2FloatFunction$Type): $Double2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$Type): $Float2CharFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$Type<(any)>): $Object2LongFunction<(T)>
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$Type<(any)>): $Float2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2FloatFunction$Type<(any)>): $Reference2LongFunction<(T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$Type<(any)>): $Float2ObjectFunction<(T)>
 "andThenByte"(arg0: $Long2ByteFunction$Type): $Float2ByteFunction
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenShort"(arg0: $Long2ShortFunction$Type): $Float2ShortFunction
 "composeByte"(arg0: $Byte2FloatFunction$Type): $Byte2LongFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: float): long

(arg0: float): long
}

export namespace $Float2LongFunction {
function identity<T>(): $Function<(float), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2LongFunction$Type = ($Float2LongFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2LongFunction_ = $Float2LongFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2ReferenceMap" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$AbstractObject2ReferenceFunction, $AbstractObject2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2ReferenceFunction"
import {$Object2ReferenceMap, $Object2ReferenceMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceMap"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Object2ReferenceMap$Entry, $Object2ReferenceMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceMap$Entry"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ReferenceCollection, $ReferenceCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ReferenceCollection"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $AbstractObject2ReferenceMap<K, V> extends $AbstractObject2ReferenceFunction<(K), (V)> implements $Object2ReferenceMap<(K), (V)>, $Serializable {


public "equals"(arg0: any): boolean
public "toString"(): string
public "values"(): $ReferenceCollection<(V)>
public "hashCode"(): integer
public "isEmpty"(): boolean
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "containsKey"(arg0: any): boolean
public "containsValue"(arg0: any): boolean
public "remove"(arg0: any): V
public "remove"(arg0: any, arg1: any): boolean
public "put"(arg0: K, arg1: V): V
public "clear"(): void
public "replace"(arg0: K, arg1: V, arg2: V): boolean
public "replace"(arg0: K, arg1: V): V
public "size"(): integer
public "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "entrySet"(): $ObjectSet<($Map$Entry<(K), (V)>)>
public "putIfAbsent"(arg0: K, arg1: V): V
public "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
public "computeIfAbsent"(arg0: K, arg1: $Object2ReferenceFunction$Type<(any), (any)>): V
public "getOrDefault"(arg0: any, arg1: V): V
public "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "object2ReferenceEntrySet"(): $ObjectSet<($Object2ReferenceMap$Entry<(K), (V)>)>
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
/**
 * 
 * @deprecated
 */
public "computeReferenceIfAbsentPartial"(arg0: K, arg1: $Object2ReferenceFunction$Type<(any), (any)>): V
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): V
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(K), (K)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractObject2ReferenceMap$Type<K, V> = ($AbstractObject2ReferenceMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractObject2ReferenceMap_<K, V> = $AbstractObject2ReferenceMap$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortListIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$ShortConsumer, $ShortConsumer$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortConsumer"
import {$ShortBidirectionalIterator, $ShortBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortBidirectionalIterator"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"

export interface $ShortListIterator extends $ShortBidirectionalIterator, $ListIterator<(short)> {

/**
 * 
 * @deprecated
 */
 "add"(arg0: short): void
 "add"(arg0: short): void
 "remove"(): void
/**
 * 
 * @deprecated
 */
 "set"(arg0: short): void
 "set"(arg0: short): void
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "previousShort"(): short
 "hasNext"(): boolean
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
 "forEachRemaining"(arg0: $IntConsumer$Type): void
 "forEachRemaining"(arg0: $ShortConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "nextShort"(): short
}

export namespace $ShortListIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortListIterator$Type = ($ShortListIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortListIterator_ = $ShortListIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Reference2FloatFunction<K> extends $Function$0<(K), (float)>, $ToDoubleFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): float
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): float
 "put"(arg0: K, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: float): float
 "getFloat"(arg0: any): float
 "getOrDefault"(arg0: any, arg1: float): float
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeFloat"(arg0: any): float
 "andThenDouble"(arg0: $Float2DoubleFunction$Type): $Reference2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2FloatFunction
 "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2FloatFunction
 "andThenFloat"(arg0: $Float2FloatFunction$Type): $Reference2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$Type): $Reference2LongFunction<(K)>
 "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2FloatFunction
 "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2FloatFunction
 "andThenInt"(arg0: $Float2IntFunction$Type): $Reference2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$Type): $Reference2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2FloatFunction<(T)>
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$Type<(any)>): $Reference2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2FloatFunction<(T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$Type<(any)>): $Reference2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Float2ByteFunction$Type): $Reference2ByteFunction<(K)>
 "defaultReturnValue"(): float
 "defaultReturnValue"(arg0: float): void
 "andThenShort"(arg0: $Float2ShortFunction$Type): $Reference2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2FloatFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): float
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (float)>

(arg0: any): float
}

export namespace $Reference2FloatFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2FloatFunction$Type<K> = ($Reference2FloatFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2FloatFunction_<K> = $Reference2FloatFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Int2ByteFunction extends $Function$0<(integer), (byte)>, $IntUnaryOperator {

 "remove"(arg0: integer): byte
 "get"(arg0: integer): byte
 "put"(arg0: integer, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: byte): byte
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: integer, arg1: byte): byte
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (T)>
 "andThenDouble"(arg0: $Byte2DoubleFunction$Type): $Int2DoubleFunction
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2ByteFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2ByteFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$Type): $Int2FloatFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$Type): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2ByteFunction
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2ByteFunction
 "andThenInt"(arg0: $Byte2IntFunction$Type): $Int2IntFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$Type): $Int2CharFunction
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2ByteFunction<(T)>
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$Type<(any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2ByteFunction<(T)>
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$Type<(any)>): $Int2ObjectFunction<(T)>
 "andThenByte"(arg0: $Byte2ByteFunction$Type): $Int2ByteFunction
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "andThenShort"(arg0: $Byte2ShortFunction$Type): $Int2ShortFunction
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2ByteFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: integer): byte
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: integer): byte
}

export namespace $Int2ByteFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2ByteFunction$Type = ($Int2ByteFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2ByteFunction_ = $Int2ByteFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Byte2IntFunction extends $Function$0<(byte), (integer)>, $IntUnaryOperator {

 "remove"(arg0: byte): integer
 "get"(arg0: byte): integer
 "put"(arg0: byte, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: integer): integer
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: byte, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(byte), (T)>
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Byte2DoubleFunction
 "composeChar"(arg0: $Char2ByteFunction$Type): $Char2IntFunction
 "composeShort"(arg0: $Short2ByteFunction$Type): $Short2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Byte2FloatFunction
 "composeFloat"(arg0: $Float2ByteFunction$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$Type): $Byte2LongFunction
 "composeLong"(arg0: $Long2ByteFunction$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2ByteFunction$Type): $Int2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2ByteFunction$Type): $Double2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$Type): $Byte2CharFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$Type<(any)>): $Object2IntFunction<(T)>
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Byte2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ByteFunction$Type<(any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Byte2ObjectFunction<(T)>
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Byte2ByteFunction
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Byte2ShortFunction
 "composeByte"(arg0: $Byte2ByteFunction$Type): $Byte2IntFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: byte): integer
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: byte): integer
}

export namespace $Byte2IntFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2IntFunction$Type = ($Byte2IntFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2IntFunction_ = $Byte2IntFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"

export interface $Boolean2LongFunction extends $Function$0<(boolean), (long)> {

 "remove"(arg0: boolean): long
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): long
 "get"(arg0: boolean): long
 "put"(arg0: boolean, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: long): long
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: boolean, arg1: long): long
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(boolean), (T)>
 "andThenDouble"(arg0: $Long2DoubleFunction$Type): $Boolean2DoubleFunction
 "composeChar"(arg0: $Char2BooleanFunction$Type): $Char2LongFunction
 "composeShort"(arg0: $Short2BooleanFunction$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$Type): $Boolean2FloatFunction
 "composeFloat"(arg0: $Float2BooleanFunction$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$Type): $Boolean2LongFunction
 "composeLong"(arg0: $Long2BooleanFunction$Type): $Long2LongFunction
 "composeInt"(arg0: $Int2BooleanFunction$Type): $Int2LongFunction
 "andThenInt"(arg0: $Long2IntFunction$Type): $Boolean2IntFunction
 "composeDouble"(arg0: $Double2BooleanFunction$Type): $Double2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$Type): $Boolean2CharFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$Type<(any)>): $Object2LongFunction<(T)>
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$Type<(any)>): $Boolean2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2BooleanFunction$Type<(any)>): $Reference2LongFunction<(T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$Type<(any)>): $Boolean2ObjectFunction<(T)>
 "andThenByte"(arg0: $Long2ByteFunction$Type): $Boolean2ByteFunction
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenShort"(arg0: $Long2ShortFunction$Type): $Boolean2ShortFunction
 "composeByte"(arg0: $Byte2BooleanFunction$Type): $Byte2LongFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: boolean): long

(arg0: boolean): long
}

export namespace $Boolean2LongFunction {
function identity<T>(): $Function<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2LongFunction$Type = ($Boolean2LongFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2LongFunction_ = $Boolean2LongFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntConsumer"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$Type as $IntConsumer$0$Type} from "packages/java/util/function/$IntConsumer"
import {$PrimitiveIterator$OfInt, $PrimitiveIterator$OfInt$Type} from "packages/java/util/$PrimitiveIterator$OfInt"

export interface $IntIterator extends $PrimitiveIterator$OfInt {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $IntConsumer$Type): void
 "skip"(arg0: integer): integer
 "nextInt"(): integer
 "forEachRemaining"(arg0: $IntConsumer$0$Type): void
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $IntIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntIterator$Type = ($IntIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntIterator_ = $IntIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntOpenHashSet" {
import {$IntCollection, $IntCollection$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntCollection"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$Hash, $Hash$Type} from "packages/it/unimi/dsi/fastutil/$Hash"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"
import {$AbstractIntSet, $AbstractIntSet$Type} from "packages/it/unimi/dsi/fastutil/ints/$AbstractIntSet"
import {$Iterator, $Iterator$Type} from "packages/java/util/$Iterator"

export class $IntOpenHashSet extends $AbstractIntSet implements $Serializable, $Cloneable, $Hash {

constructor(arg0: $Iterator$Type<(any)>)
constructor(arg0: $Iterator$Type<(any)>, arg1: float)
constructor(arg0: $IntIterator$Type)
constructor(arg0: $IntIterator$Type, arg1: float)
constructor(arg0: (integer)[])
constructor(arg0: (integer)[], arg1: float)
constructor(arg0: (integer)[], arg1: integer, arg2: integer)
constructor(arg0: (integer)[], arg1: integer, arg2: integer, arg3: float)
constructor(arg0: $Collection$Type<(any)>, arg1: float)
constructor()
constructor(arg0: integer)
constructor(arg0: integer, arg1: float)
constructor(arg0: $IntCollection$Type)
constructor(arg0: $IntCollection$Type, arg1: float)
constructor(arg0: $Collection$Type<(any)>)

public "add"(arg0: integer): boolean
public "remove"(arg0: integer): boolean
public "hashCode"(): integer
public "clone"(): $IntOpenHashSet
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public "iterator"(): $IntIterator
public "trim"(): boolean
public "trim"(arg0: integer): boolean
public static "of"(): $IntOpenHashSet
public static "of"(arg0: integer): $IntOpenHashSet
public static "of"(arg0: integer, arg1: integer): $IntOpenHashSet
public static "of"(...arg0: (integer)[]): $IntOpenHashSet
public static "of"(arg0: integer, arg1: integer, arg2: integer): $IntOpenHashSet
public "contains"(arg0: integer): boolean
public "addAll"(arg0: $IntCollection$Type): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "forEach"(arg0: $IntConsumer$Type): void
public static "toSet"(arg0: $IntStream$Type): $IntOpenHashSet
public static "toSetWithExpectedSize"(arg0: $IntStream$Type, arg1: integer): $IntOpenHashSet
/**
 * 
 * @deprecated
 */
public "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
public "contains"(arg0: any): boolean
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $Set<(E)>
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E): $Set<(E)>
public static "of"<E>(arg0: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E, arg9: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E, arg8: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E, arg7: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E, arg3: E, arg4: E, arg5: E, arg6: E): $Set<(E)>
public static "of"<E>(...arg0: (E)[]): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E, arg2: E): $Set<(E)>
public static "of"<E>(arg0: E, arg1: E): $Set<(E)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntOpenHashSet$Type = ($IntOpenHashSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntOpenHashSet_ = $IntOpenHashSet$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Object2ShortFunction<K> extends $Function$0<(K), (short)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): short
 "put"(arg0: K, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: short): short
 "getShort"(arg0: any): short
 "getOrDefault"(arg0: any, arg1: short): short
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "andThenDouble"(arg0: $Short2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2ShortFunction
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2ShortFunction
 "andThenFloat"(arg0: $Short2FloatFunction$Type): $Object2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2ShortFunction
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2ShortFunction
 "andThenInt"(arg0: $Short2IntFunction$Type): $Object2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$Type): $Object2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ShortFunction<(T)>
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2ShortFunction<(T)>
 "andThenObject"<T>(arg0: $Short2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Short2ByteFunction$Type): $Object2ByteFunction<(K)>
 "defaultReturnValue"(): short
 "defaultReturnValue"(arg0: short): void
 "andThenShort"(arg0: $Short2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2ShortFunction
 "removeShort"(arg0: any): short
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): short
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (short)>

(arg0: any): short
}

export namespace $Object2ShortFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ShortFunction$Type<K> = ($Object2ShortFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ShortFunction_<K> = $Object2ShortFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$LongToIntFunction, $LongToIntFunction$Type} from "packages/java/util/function/$LongToIntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"

export interface $Long2IntFunction extends $Function$0<(long), (integer)>, $LongToIntFunction {

 "remove"(arg0: long): integer
 "get"(arg0: long): integer
 "put"(arg0: long, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: integer): integer
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: long, arg1: integer): integer
 "applyAsInt"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(long), (T)>
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Long2DoubleFunction
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2IntFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Long2FloatFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$Type): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Long2IntFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$Type): $Long2CharFunction
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2IntFunction<(T)>
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Long2ObjectFunction<(T)>
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Long2ByteFunction
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Long2ShortFunction
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2IntFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: long): integer

(arg0: long): integer
}

export namespace $Long2IntFunction {
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2IntFunction$Type = ($Long2IntFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2IntFunction_ = $Long2IntFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoubleBinaryOperator" {
import {$BinaryOperator, $BinaryOperator$Type} from "packages/java/util/function/$BinaryOperator"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$DoubleBinaryOperator as $DoubleBinaryOperator$0, $DoubleBinaryOperator$Type as $DoubleBinaryOperator$0$Type} from "packages/java/util/function/$DoubleBinaryOperator"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"

export interface $DoubleBinaryOperator extends $BinaryOperator<(double)>, $DoubleBinaryOperator$0 {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: double, arg1: double): double
 "apply"(arg0: double, arg1: double): double
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: double, arg1: double): double
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $BiFunction<(double), (double), (V)>

(arg0: double, arg1: double): double
}

export namespace $DoubleBinaryOperator {
function maxBy<T>(arg0: $Comparator$Type<(any)>): $BinaryOperator<(double)>
function minBy<T>(arg0: $Comparator$Type<(any)>): $BinaryOperator<(double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleBinaryOperator$Type = ($DoubleBinaryOperator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleBinaryOperator_ = $DoubleBinaryOperator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoubleComparator" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$ToLongFunction, $ToLongFunction$Type} from "packages/java/util/function/$ToLongFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"

export interface $DoubleComparator extends $Comparator<(double)> {

/**
 * 
 * @deprecated
 */
 "compare"(arg0: double, arg1: double): integer
 "compare"(arg0: double, arg1: double): integer
 "thenComparing"(arg0: $Comparator$Type<(any)>): $Comparator<(double)>
 "thenComparing"(arg0: $DoubleComparator$Type): $DoubleComparator
 "reversed"(): $DoubleComparator
 "equals"(arg0: any): boolean
 "thenComparing"<U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(double)>
 "thenComparing"<U extends $Comparable<(any)>>(arg0: $Function$Type<(any), (any)>): $Comparator<(double)>
 "thenComparingInt"(arg0: $ToIntFunction$Type<(any)>): $Comparator<(double)>
 "thenComparingLong"(arg0: $ToLongFunction$Type<(any)>): $Comparator<(double)>
 "thenComparingDouble"(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(double)>
}

export namespace $DoubleComparator {
function reverseOrder<T>(): $Comparator<(double)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>): $Comparator<(double)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(double)>
function comparingInt<T>(arg0: $ToIntFunction$Type<(any)>): $Comparator<(double)>
function comparingLong<T>(arg0: $ToLongFunction$Type<(any)>): $Comparator<(double)>
function comparingDouble<T>(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(double)>
function naturalOrder<T>(): $Comparator<(double)>
function nullsFirst<T>(arg0: $Comparator$Type<(any)>): $Comparator<(double)>
function nullsLast<T>(arg0: $Comparator$Type<(any)>): $Comparator<(double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleComparator$Type = ($DoubleComparator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleComparator_ = $DoubleComparator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2FloatMap" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$FloatCollection, $FloatCollection$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatCollection"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Object2FloatMap, $Object2FloatMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatMap"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Object2FloatMap$Entry, $Object2FloatMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatMap$Entry"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$DoubleBinaryOperator, $DoubleBinaryOperator$Type} from "packages/java/util/function/$DoubleBinaryOperator"
import {$FloatBinaryOperator, $FloatBinaryOperator$Type} from "packages/it/unimi/dsi/fastutil/floats/$FloatBinaryOperator"
import {$AbstractObject2FloatFunction, $AbstractObject2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2FloatFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $AbstractObject2FloatMap<K> extends $AbstractObject2FloatFunction<(K)> implements $Object2FloatMap<(K)>, $Serializable {


public "equals"(arg0: any): boolean
public "toString"(): string
public "values"(): $FloatCollection
public "hashCode"(): integer
public "isEmpty"(): boolean
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "containsKey"(arg0: any): boolean
public "containsValue"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any, arg1: any): boolean
public "remove"(arg0: any, arg1: float): boolean
/**
 * 
 * @deprecated
 */
public "get"(arg0: any): float
/**
 * 
 * @deprecated
 */
public "put"(arg0: K, arg1: float): float
public "clear"(): void
/**
 * 
 * @deprecated
 */
public "replace"(arg0: K, arg1: float, arg2: float): boolean
public "replace"(arg0: K, arg1: float, arg2: float): boolean
public "replace"(arg0: K, arg1: float): float
/**
 * 
 * @deprecated
 */
public "replace"(arg0: K, arg1: float): float
public "size"(): integer
public "merge"(arg0: K, arg1: float, arg2: $BiFunction$Type<(any), (any), (any)>): float
/**
 * 
 * @deprecated
 */
public "merge"(arg0: K, arg1: float, arg2: $BiFunction$Type<(any), (any), (any)>): float
/**
 * 
 * @deprecated
 */
public "entrySet"(): $ObjectSet<($Map$Entry<(K), (float)>)>
/**
 * 
 * @deprecated
 */
public "putIfAbsent"(arg0: K, arg1: float): float
public "putIfAbsent"(arg0: K, arg1: float): float
public "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
public "computeIfAbsent"(arg0: K, arg1: $ToDoubleFunction$Type<(any)>): float
public "computeIfAbsent"(arg0: K, arg1: $Object2FloatFunction$Type<(any)>): float
/**
 * 
 * @deprecated
 */
public "containsValue"(arg0: any): boolean
public "getOrDefault"(arg0: any, arg1: float): float
/**
 * 
 * @deprecated
 */
public "getOrDefault"(arg0: any, arg1: float): float
/**
 * 
 * @deprecated
 */
public "computeFloatIfAbsentPartial"(arg0: K, arg1: $Object2FloatFunction$Type<(any)>): float
public "computeFloatIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): float
/**
 * 
 * @deprecated
 */
public "computeFloatIfAbsent"(arg0: K, arg1: $ToDoubleFunction$Type<(any)>): float
public "object2FloatEntrySet"(): $ObjectSet<($Object2FloatMap$Entry<(K)>)>
public "defaultReturnValue"(arg0: float): void
public "defaultReturnValue"(): float
/**
 * 
 * @deprecated
 */
public "mergeFloat"(arg0: K, arg1: float, arg2: $BiFunction$Type<(any), (any), (any)>): float
public "mergeFloat"(arg0: K, arg1: float, arg2: $DoubleBinaryOperator$Type): float
public "mergeFloat"(arg0: K, arg1: float, arg2: $FloatBinaryOperator$Type): float
public "computeFloat"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): float
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (float)>
public "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
public static "of"<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float): $Map<(K), (float)>
public static "of"<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float): $Map<(K), (float)>
public static "of"<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float): $Map<(K), (float)>
public static "of"<K, V>(): $Map<(K), (float)>
public static "of"<K, V>(arg0: K, arg1: float, arg2: K, arg3: float): $Map<(K), (float)>
public static "of"<K, V>(arg0: K, arg1: float): $Map<(K), (float)>
public static "of"<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float, arg12: K, arg13: float, arg14: K, arg15: float, arg16: K, arg17: float, arg18: K, arg19: float): $Map<(K), (float)>
public static "of"<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float, arg12: K, arg13: float, arg14: K, arg15: float, arg16: K, arg17: float): $Map<(K), (float)>
public static "of"<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float, arg12: K, arg13: float, arg14: K, arg15: float): $Map<(K), (float)>
public static "of"<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float, arg12: K, arg13: float): $Map<(K), (float)>
public static "of"<K, V>(arg0: K, arg1: float, arg2: K, arg3: float, arg4: K, arg5: float, arg6: K, arg7: float, arg8: K, arg9: float, arg10: K, arg11: float): $Map<(K), (float)>
public "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): float
public static "entry"<K, V>(arg0: K, arg1: float): $Map$Entry<(K), (float)>
public "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): float
public "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): float
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (float)>
public static "identity"<T>(): $Function<(K), (K)>
[index: string | number]: float
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractObject2FloatMap$Type<K> = ($AbstractObject2FloatMap<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractObject2FloatMap_<K> = $AbstractObject2FloatMap$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongComparator" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$ToLongFunction, $ToLongFunction$Type} from "packages/java/util/function/$ToLongFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"

export interface $LongComparator extends $Comparator<(long)> {

/**
 * 
 * @deprecated
 */
 "compare"(arg0: long, arg1: long): integer
 "compare"(arg0: long, arg1: long): integer
 "thenComparing"(arg0: $Comparator$Type<(any)>): $Comparator<(long)>
 "thenComparing"(arg0: $LongComparator$Type): $LongComparator
 "reversed"(): $LongComparator
 "equals"(arg0: any): boolean
 "thenComparing"<U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(long)>
 "thenComparing"<U extends $Comparable<(any)>>(arg0: $Function$Type<(any), (any)>): $Comparator<(long)>
 "thenComparingInt"(arg0: $ToIntFunction$Type<(any)>): $Comparator<(long)>
 "thenComparingLong"(arg0: $ToLongFunction$Type<(any)>): $Comparator<(long)>
 "thenComparingDouble"(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(long)>
}

export namespace $LongComparator {
function reverseOrder<T>(): $Comparator<(long)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>): $Comparator<(long)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(long)>
function comparingInt<T>(arg0: $ToIntFunction$Type<(any)>): $Comparator<(long)>
function comparingLong<T>(arg0: $ToLongFunction$Type<(any)>): $Comparator<(long)>
function comparingDouble<T>(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(long)>
function naturalOrder<T>(): $Comparator<(long)>
function nullsFirst<T>(arg0: $Comparator$Type<(any)>): $Comparator<(long)>
function nullsLast<T>(arg0: $Comparator$Type<(any)>): $Comparator<(long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongComparator$Type = ($LongComparator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongComparator_ = $LongComparator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$AbstractInt2ObjectMap" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Int2ObjectMap, $Int2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectMap"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Int2ObjectMap$Entry, $Int2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectMap$Entry"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ObjectCollection, $ObjectCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectCollection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$AbstractInt2ObjectFunction, $AbstractInt2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$AbstractInt2ObjectFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $AbstractInt2ObjectMap<V> extends $AbstractInt2ObjectFunction<(V)> implements $Int2ObjectMap<(V)>, $Serializable {


public "equals"(arg0: any): boolean
public "toString"(): string
public "values"(): $ObjectCollection<(V)>
public "hashCode"(): integer
public "isEmpty"(): boolean
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "containsKey"(arg0: integer): boolean
public "containsValue"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): V
public "remove"(arg0: integer, arg1: any): boolean
/**
 * 
 * @deprecated
 */
public "get"(arg0: any): V
/**
 * 
 * @deprecated
 */
public "put"(arg0: integer, arg1: V): V
public "clear"(): void
public "replace"(arg0: integer, arg1: V, arg2: V): boolean
public "replace"(arg0: integer, arg1: V): V
public "size"(): integer
public "merge"(arg0: integer, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
/**
 * 
 * @deprecated
 */
public "entrySet"(): $ObjectSet<($Map$Entry<(integer), (V)>)>
public "putIfAbsent"(arg0: integer, arg1: V): V
public "compute"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
/**
 * 
 * @deprecated
 */
public "containsKey"(arg0: any): boolean
public "computeIfAbsent"(arg0: integer, arg1: $Int2ObjectFunction$Type<(any)>): V
public "computeIfAbsent"(arg0: integer, arg1: $IntFunction$Type<(any)>): V
public "getOrDefault"(arg0: integer, arg1: V): V
/**
 * 
 * @deprecated
 */
public "getOrDefault"(arg0: any, arg1: V): V
public "computeIfPresent"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): V
/**
 * 
 * @deprecated
 */
public "computeIfAbsentPartial"(arg0: integer, arg1: $Int2ObjectFunction$Type<(any)>): V
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public "int2ObjectEntrySet"(): $ObjectSet<($Int2ObjectMap$Entry<(V)>)>
public "remove"(arg0: any, arg1: any): boolean
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(integer), (V)>
public "replace"(arg0: integer, arg1: V): V
public "replace"(arg0: integer, arg1: V, arg2: V): boolean
public "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
public static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V): $Map<(integer), (V)>
public static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V): $Map<(integer), (V)>
public static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V): $Map<(integer), (V)>
public static "of"<K, V>(): $Map<(integer), (V)>
public static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V): $Map<(integer), (V)>
public static "of"<K, V>(arg0: integer, arg1: V): $Map<(integer), (V)>
public static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V, arg16: integer, arg17: V, arg18: integer, arg19: V): $Map<(integer), (V)>
public static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V, arg16: integer, arg17: V): $Map<(integer), (V)>
public static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V, arg14: integer, arg15: V): $Map<(integer), (V)>
public static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V, arg12: integer, arg13: V): $Map<(integer), (V)>
public static "of"<K, V>(arg0: integer, arg1: V, arg2: integer, arg3: V, arg4: integer, arg5: V, arg6: integer, arg7: V, arg8: integer, arg9: V, arg10: integer, arg11: V): $Map<(integer), (V)>
public "merge"(arg0: integer, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "putIfAbsent"(arg0: integer, arg1: V): V
public "compute"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): V
public static "entry"<K, V>(arg0: integer, arg1: V): $Map$Entry<(integer), (V)>
public "computeIfAbsent"(arg0: integer, arg1: $Function$Type<(any), (any)>): V
public "computeIfPresent"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): V
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(integer), (V)>
public static "identity"<T>(): $Function<(integer), (integer)>
[index: string | number]: V
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractInt2ObjectMap$Type<V> = ($AbstractInt2ObjectMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractInt2ObjectMap_<V> = $AbstractInt2ObjectMap$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2FloatMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Object2FloatMap$Entry<K> extends $Map$Entry<(K), (float)> {

/**
 * 
 * @deprecated
 */
 "getValue"(): float
/**
 * 
 * @deprecated
 */
 "setValue"(arg0: float): float
 "setValue"(arg0: float): float
 "getFloatValue"(): float
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "getKey"(): K
}

export namespace $Object2FloatMap$Entry {
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(K), (float)>)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (float)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(K), (float)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (float)>)>
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(K), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2FloatMap$Entry$Type<K> = ($Object2FloatMap$Entry<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2FloatMap$Entry_<K> = $Object2FloatMap$Entry$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/$Function" {
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/java/util/function/$Function"

export interface $Function<K, V> extends $Function$0<(K), (V)> {

 "remove"(arg0: any): V
 "get"(arg0: any): V
 "put"(arg0: K, arg1: V): V
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): V
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: any, arg1: V): V
 "compose"<V>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(V), (V)>
 "andThen"<V>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(K), (V)>

(arg0: any): V
}

export namespace $Function {
function identity<T>(): $Function$0<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Function$Type<K, V> = ($Function<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Function_<K, V> = $Function$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongSpliterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$Type as $LongConsumer$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongConsumer"
import {$Spliterator$OfLong, $Spliterator$OfLong$Type} from "packages/java/util/$Spliterator$OfLong"

export interface $LongSpliterator extends $Spliterator$OfLong {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $LongConsumer$0$Type): void
 "skip"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "tryAdvance"(arg0: $Consumer$Type<(any)>): boolean
 "tryAdvance"(arg0: $LongConsumer$0$Type): boolean
 "forEachRemaining"(arg0: $LongConsumer$Type): void
 "tryAdvance"(arg0: $LongConsumer$Type): boolean
 "characteristics"(): integer
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
}

export namespace $LongSpliterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongSpliterator$Type = ($LongSpliterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongSpliterator_ = $LongSpliterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$IntToLongFunction, $IntToLongFunction$Type} from "packages/java/util/function/$IntToLongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"

export interface $Int2LongFunction extends $Function$0<(integer), (long)>, $IntToLongFunction {

 "remove"(arg0: integer): long
 "get"(arg0: integer): long
 "put"(arg0: integer, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: long): long
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: integer, arg1: long): long
 "applyAsLong"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (T)>
 "andThenDouble"(arg0: $Long2DoubleFunction$Type): $Int2DoubleFunction
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2LongFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$Type): $Int2FloatFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$Type): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2LongFunction
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2LongFunction
 "andThenInt"(arg0: $Long2IntFunction$Type): $Int2IntFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$Type): $Int2CharFunction
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2LongFunction<(T)>
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$Type<(any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2LongFunction<(T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$Type<(any)>): $Int2ObjectFunction<(T)>
 "andThenByte"(arg0: $Long2ByteFunction$Type): $Int2ByteFunction
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenShort"(arg0: $Long2ShortFunction$Type): $Int2ShortFunction
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2LongFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: integer): long

(arg0: integer): long
}

export namespace $Int2LongFunction {
function identity<T>(): $Function<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2LongFunction$Type = ($Int2LongFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2LongFunction_ = $Int2LongFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntCollection" {
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntPredicate, $IntPredicate$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntPredicate"
import {$IntPredicate as $IntPredicate$0, $IntPredicate$Type as $IntPredicate$0$Type} from "packages/java/util/function/$IntPredicate"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$IntConsumer, $IntConsumer$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntConsumer"
import {$IntIterable, $IntIterable$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterable"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$Type as $IntConsumer$0$Type} from "packages/java/util/function/$IntConsumer"

export interface $IntCollection extends $Collection<(integer)>, $IntIterable {

 "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "toArray"(arg0: (integer)[]): (integer)[]
 "iterator"(): $IntIterator
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(integer)>
 "intStream"(): $IntStream
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "contains"(arg0: integer): boolean
 "addAll"(arg0: $IntCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $IntPredicate$0$Type): boolean
 "removeIf"(arg0: $IntPredicate$Type): boolean
 "removeAll"(arg0: $IntCollection$Type): boolean
 "retainAll"(arg0: $IntCollection$Type): boolean
 "containsAll"(arg0: $IntCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(integer)>
 "rem"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "toIntArray"(arg0: (integer)[]): (integer)[]
 "toIntArray"(): (integer)[]
 "intParallelStream"(): $IntStream
 "intSpliterator"(): $IntSpliterator
 "intIterator"(): $IntIterator
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "forEach"(arg0: $IntConsumer$0$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $IntConsumer$Type): void
}

export namespace $IntCollection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntCollection$Type = ($IntCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntCollection_ = $IntCollection$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortUnaryOperator" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"

export interface $ShortUnaryOperator extends $UnaryOperator<(short)>, $IntUnaryOperator {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: short): short
 "apply"(arg0: short): short
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (short)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(short), (V)>

(arg0: short): short
}

export namespace $ShortUnaryOperator {
function identity(): $ShortUnaryOperator
function negation(): $ShortUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortUnaryOperator$Type = ($ShortUnaryOperator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortUnaryOperator_ = $ShortUnaryOperator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction" {
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Function, $Function$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/java/util/function/$Function"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"

export interface $Short2ShortFunction extends $Function<(short), (short)>, $IntUnaryOperator {

 "remove"(arg0: short): short
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): short
 "get"(arg0: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: short): short
 "put"(arg0: short, arg1: short): short
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: short, arg1: short): short
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(short), (T)>
 "andThenDouble"(arg0: $Short2DoubleFunction$Type): $Short2DoubleFunction
 "composeChar"(arg0: $Char2ShortFunction$Type): $Char2ShortFunction
 "composeShort"(arg0: $Short2ShortFunction$Type): $Short2ShortFunction
 "andThenFloat"(arg0: $Short2FloatFunction$Type): $Short2FloatFunction
 "composeFloat"(arg0: $Float2ShortFunction$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$Type): $Short2LongFunction
 "composeLong"(arg0: $Long2ShortFunction$Type): $Long2ShortFunction
 "composeInt"(arg0: $Int2ShortFunction$Type): $Int2ShortFunction
 "andThenInt"(arg0: $Short2IntFunction$Type): $Short2IntFunction
 "composeDouble"(arg0: $Double2ShortFunction$Type): $Double2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$Type): $Short2CharFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$Type<(any)>): $Object2ShortFunction<(T)>
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$Type<(any)>): $Short2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ShortFunction$Type<(any)>): $Reference2ShortFunction<(T)>
 "andThenObject"<T>(arg0: $Short2ObjectFunction$Type<(any)>): $Short2ObjectFunction<(T)>
 "andThenByte"(arg0: $Short2ByteFunction$Type): $Short2ByteFunction
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "andThenShort"(arg0: $Short2ShortFunction$Type): $Short2ShortFunction
 "composeByte"(arg0: $Byte2ShortFunction$Type): $Byte2ShortFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: short): short
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: short): short
}

export namespace $Short2ShortFunction {
function identity(): $Short2ShortFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2ShortFunction$Type = ($Short2ShortFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2ShortFunction_ = $Short2ShortFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Reference2ObjectFunction<K, V> extends $Function$0<(K), (V)> {

 "remove"(arg0: any): V
 "get"(arg0: any): V
 "put"(arg0: K, arg1: V): V
 "getOrDefault"(arg0: any, arg1: V): V
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Reference2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2ObjectFunction<(V)>
 "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Reference2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Reference2LongFunction<(K)>
 "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2ObjectFunction<(V)>
 "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Reference2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Reference2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2ObjectFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Reference2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Reference2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Reference2ByteFunction<(K)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Reference2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2ObjectFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): V
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (V)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(K), (V)>

(arg0: any): V
}

export namespace $Reference2ObjectFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2ObjectFunction$Type<K, V> = ($Reference2ObjectFunction<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2ObjectFunction_<K, V> = $Reference2ObjectFunction$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction" {
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Boolean2ObjectFunction<V> extends $Function$0<(boolean), (V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: boolean): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: boolean): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: V): V
 "put"(arg0: boolean, arg1: V): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: boolean, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Boolean2DoubleFunction
 "composeChar"(arg0: $Char2BooleanFunction$Type): $Char2ObjectFunction<(V)>
 "composeShort"(arg0: $Short2BooleanFunction$Type): $Short2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Boolean2FloatFunction
 "composeFloat"(arg0: $Float2BooleanFunction$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Boolean2LongFunction
 "composeLong"(arg0: $Long2BooleanFunction$Type): $Long2ObjectFunction<(V)>
 "composeInt"(arg0: $Int2BooleanFunction$Type): $Int2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Boolean2IntFunction
 "composeDouble"(arg0: $Double2BooleanFunction$Type): $Double2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Boolean2CharFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Boolean2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2BooleanFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Boolean2ObjectFunction<(T)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Boolean2ByteFunction
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Boolean2ShortFunction
 "composeByte"(arg0: $Byte2BooleanFunction$Type): $Byte2ObjectFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: boolean): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(boolean), (V)>

(arg0: any): V
}

export namespace $Boolean2ObjectFunction {
function identity<T>(): $Function<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2ObjectFunction$Type<V> = ($Boolean2ObjectFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2ObjectFunction_<V> = $Boolean2ObjectFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoubleUnaryOperator" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$DoubleUnaryOperator as $DoubleUnaryOperator$0, $DoubleUnaryOperator$Type as $DoubleUnaryOperator$0$Type} from "packages/java/util/function/$DoubleUnaryOperator"

export interface $DoubleUnaryOperator extends $UnaryOperator<(double)>, $DoubleUnaryOperator$0 {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: double): double
 "apply"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: double): double
 "compose"(arg0: $DoubleUnaryOperator$0$Type): $DoubleUnaryOperator$0
 "andThen"(arg0: $DoubleUnaryOperator$0$Type): $DoubleUnaryOperator$0
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (double)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(double), (V)>

(arg0: double): double
}

export namespace $DoubleUnaryOperator {
function identity(): $DoubleUnaryOperator
function negation(): $DoubleUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleUnaryOperator$Type = ($DoubleUnaryOperator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleUnaryOperator_ = $DoubleUnaryOperator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Int2DoubleMap$Entry extends $Map$Entry<(integer), (double)> {

/**
 * 
 * @deprecated
 */
 "getValue"(): double
/**
 * 
 * @deprecated
 */
 "setValue"(arg0: double): double
 "setValue"(arg0: double): double
 "getIntKey"(): integer
 "getDoubleValue"(): double
 "equals"(arg0: any): boolean
 "hashCode"(): integer
}

export namespace $Int2DoubleMap$Entry {
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(integer), (double)>)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(integer), (double)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(integer), (double)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(integer), (double)>)>
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(integer), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2DoubleMap$Entry$Type = ($Int2DoubleMap$Entry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2DoubleMap$Entry_ = $Int2DoubleMap$Entry$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Char2IntFunction extends $Function$0<(character), (integer)>, $IntUnaryOperator {

 "remove"(arg0: character): integer
 "get"(arg0: character): integer
 "put"(arg0: character, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: integer): integer
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: character, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(character), (T)>
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Char2DoubleFunction
 "composeChar"(arg0: $Char2CharFunction$Type): $Char2IntFunction
 "composeShort"(arg0: $Short2CharFunction$Type): $Short2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Char2FloatFunction
 "composeFloat"(arg0: $Float2CharFunction$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$Type): $Char2LongFunction
 "composeLong"(arg0: $Long2CharFunction$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2CharFunction$Type): $Int2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Char2IntFunction
 "composeDouble"(arg0: $Double2CharFunction$Type): $Double2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$Type): $Char2CharFunction
 "composeObject"<T>(arg0: $Object2CharFunction$Type<(any)>): $Object2IntFunction<(T)>
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Char2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2CharFunction$Type<(any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Char2ObjectFunction<(T)>
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Char2ByteFunction
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Char2ShortFunction
 "composeByte"(arg0: $Byte2CharFunction$Type): $Byte2IntFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: character): integer
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: character): integer
}

export namespace $Char2IntFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2IntFunction$Type = ($Char2IntFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2IntFunction_ = $Char2IntFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2IntMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Int2IntMap$Entry extends $Map$Entry<(integer), (integer)> {

/**
 * 
 * @deprecated
 */
 "getValue"(): integer
/**
 * 
 * @deprecated
 */
 "setValue"(arg0: integer): integer
 "setValue"(arg0: integer): integer
 "getIntKey"(): integer
 "getIntValue"(): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
}

export namespace $Int2IntMap$Entry {
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(integer), (integer)>)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(integer), (integer)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(integer), (integer)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(integer), (integer)>)>
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2IntMap$Entry$Type = ($Int2IntMap$Entry);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2IntMap$Entry_ = $Int2IntMap$Entry$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortSpliterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Spliterator$OfPrimitive, $Spliterator$OfPrimitive$Type} from "packages/java/util/$Spliterator$OfPrimitive"
import {$ShortConsumer, $ShortConsumer$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortConsumer"

export interface $ShortSpliterator extends $Spliterator$OfPrimitive<(short), ($ShortConsumer), ($ShortSpliterator)> {

/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "skip"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "tryAdvance"(arg0: $Consumer$Type<(any)>): boolean
 "forEachRemaining"(arg0: $ShortConsumer$Type): void
 "tryAdvance"(arg0: $ShortConsumer$Type): boolean
 "characteristics"(): integer
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
}

export namespace $ShortSpliterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortSpliterator$Type = ($ShortSpliterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortSpliterator_ = $ShortSpliterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Boolean2ShortFunction extends $Function$0<(boolean), (short)> {

 "remove"(arg0: boolean): short
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): short
 "get"(arg0: boolean): short
 "put"(arg0: boolean, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: short): short
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: boolean, arg1: short): short
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(boolean), (T)>
 "andThenDouble"(arg0: $Short2DoubleFunction$Type): $Boolean2DoubleFunction
 "composeChar"(arg0: $Char2BooleanFunction$Type): $Char2ShortFunction
 "composeShort"(arg0: $Short2BooleanFunction$Type): $Short2ShortFunction
 "andThenFloat"(arg0: $Short2FloatFunction$Type): $Boolean2FloatFunction
 "composeFloat"(arg0: $Float2BooleanFunction$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$Type): $Boolean2LongFunction
 "composeLong"(arg0: $Long2BooleanFunction$Type): $Long2ShortFunction
 "composeInt"(arg0: $Int2BooleanFunction$Type): $Int2ShortFunction
 "andThenInt"(arg0: $Short2IntFunction$Type): $Boolean2IntFunction
 "composeDouble"(arg0: $Double2BooleanFunction$Type): $Double2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$Type): $Boolean2CharFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$Type<(any)>): $Object2ShortFunction<(T)>
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$Type<(any)>): $Boolean2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2BooleanFunction$Type<(any)>): $Reference2ShortFunction<(T)>
 "andThenObject"<T>(arg0: $Short2ObjectFunction$Type<(any)>): $Boolean2ObjectFunction<(T)>
 "andThenByte"(arg0: $Short2ByteFunction$Type): $Boolean2ByteFunction
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "andThenShort"(arg0: $Short2ShortFunction$Type): $Boolean2ShortFunction
 "composeByte"(arg0: $Byte2BooleanFunction$Type): $Byte2ShortFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: boolean): short

(arg0: boolean): short
}

export namespace $Boolean2ShortFunction {
function identity<T>(): $Function<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2ShortFunction$Type = ($Boolean2ShortFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2ShortFunction_ = $Boolean2ShortFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$Type} from "packages/java/util/function/$IntToDoubleFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"

export interface $Int2DoubleFunction extends $Function$0<(integer), (double)>, $IntToDoubleFunction {

 "remove"(arg0: integer): double
 "get"(arg0: integer): double
 "put"(arg0: integer, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: double): double
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: integer, arg1: double): double
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (T)>
 "andThenDouble"(arg0: $Double2DoubleFunction$Type): $Int2DoubleFunction
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2DoubleFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2DoubleFunction
 "andThenFloat"(arg0: $Double2FloatFunction$Type): $Int2FloatFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$Type): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2DoubleFunction
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2DoubleFunction
 "andThenInt"(arg0: $Double2IntFunction$Type): $Int2IntFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$Type): $Int2CharFunction
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2DoubleFunction<(T)>
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$Type<(any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2DoubleFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$Type<(any)>): $Int2ObjectFunction<(T)>
 "andThenByte"(arg0: $Double2ByteFunction$Type): $Int2ByteFunction
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenShort"(arg0: $Double2ShortFunction$Type): $Int2ShortFunction
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2DoubleFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: integer): double

(arg0: integer): double
}

export namespace $Int2DoubleFunction {
function identity<T>(): $Function<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2DoubleFunction$Type = ($Int2DoubleFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2DoubleFunction_ = $Int2DoubleFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongConsumer" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$Type as $LongConsumer$0$Type} from "packages/java/util/function/$LongConsumer"

export interface $LongConsumer extends $Consumer<(long)>, $LongConsumer$0 {

/**
 * 
 * @deprecated
 */
 "accept"(arg0: long): void
/**
 * 
 * @deprecated
 */
 "andThen"(arg0: $Consumer$Type<(any)>): $Consumer<(long)>
 "andThen"(arg0: $LongConsumer$Type): $LongConsumer
 "accept"(arg0: long): void

(arg0: long): void
}

export namespace $LongConsumer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongConsumer$Type = ($LongConsumer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongConsumer_ = $LongConsumer$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$Type} from "packages/java/util/function/$IntToDoubleFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Char2DoubleFunction extends $Function$0<(character), (double)>, $IntToDoubleFunction {

 "remove"(arg0: character): double
 "get"(arg0: character): double
 "put"(arg0: character, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: double): double
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: character, arg1: double): double
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(character), (T)>
 "andThenDouble"(arg0: $Double2DoubleFunction$Type): $Char2DoubleFunction
 "composeChar"(arg0: $Char2CharFunction$Type): $Char2DoubleFunction
 "composeShort"(arg0: $Short2CharFunction$Type): $Short2DoubleFunction
 "andThenFloat"(arg0: $Double2FloatFunction$Type): $Char2FloatFunction
 "composeFloat"(arg0: $Float2CharFunction$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$Type): $Char2LongFunction
 "composeLong"(arg0: $Long2CharFunction$Type): $Long2DoubleFunction
 "composeInt"(arg0: $Int2CharFunction$Type): $Int2DoubleFunction
 "andThenInt"(arg0: $Double2IntFunction$Type): $Char2IntFunction
 "composeDouble"(arg0: $Double2CharFunction$Type): $Double2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$Type): $Char2CharFunction
 "composeObject"<T>(arg0: $Object2CharFunction$Type<(any)>): $Object2DoubleFunction<(T)>
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$Type<(any)>): $Char2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2CharFunction$Type<(any)>): $Reference2DoubleFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$Type<(any)>): $Char2ObjectFunction<(T)>
 "andThenByte"(arg0: $Double2ByteFunction$Type): $Char2ByteFunction
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenShort"(arg0: $Double2ShortFunction$Type): $Char2ShortFunction
 "composeByte"(arg0: $Byte2CharFunction$Type): $Byte2DoubleFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: character): double

(arg0: character): double
}

export namespace $Char2DoubleFunction {
function identity<T>(): $Function<(character), (character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2DoubleFunction$Type = ($Char2DoubleFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2DoubleFunction_ = $Char2DoubleFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$ShortCollection" {
import {$ShortIterator, $ShortIterator$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortIterator"
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$ShortPredicate, $ShortPredicate$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortPredicate"
import {$ShortIterable, $ShortIterable$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortIterable"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ShortConsumer, $ShortConsumer$Type} from "packages/it/unimi/dsi/fastutil/shorts/$ShortConsumer"
import {$IntConsumer, $IntConsumer$Type} from "packages/java/util/function/$IntConsumer"

export interface $ShortCollection extends $Collection<(short)>, $ShortIterable {

 "add"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "toArray"(arg0: (short)[]): (short)[]
 "iterator"(): $ShortIterator
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(short)>
 "intStream"(): $IntStream
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "contains"(arg0: short): boolean
 "addAll"(arg0: $ShortCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $ShortPredicate$Type): boolean
 "removeIf"(arg0: $IntPredicate$Type): boolean
 "removeAll"(arg0: $ShortCollection$Type): boolean
 "retainAll"(arg0: $ShortCollection$Type): boolean
 "containsAll"(arg0: $ShortCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(short)>
 "rem"(arg0: short): boolean
 "intParallelStream"(): $IntStream
 "intSpliterator"(): $IntSpliterator
 "intIterator"(): $IntIterator
/**
 * 
 * @deprecated
 */
 "toShortArray"(arg0: (short)[]): (short)[]
 "toShortArray"(): (short)[]
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "forEach"(arg0: $ShortConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $IntConsumer$Type): void
}

export namespace $ShortCollection {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ShortCollection$Type = ($ShortCollection);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ShortCollection_ = $ShortCollection$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2FloatFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export class $AbstractObject2FloatFunction<K> implements $Object2FloatFunction<(K)>, $Serializable {


public "defaultReturnValue"(arg0: float): void
public "defaultReturnValue"(): float
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): float
/**
 * 
 * @deprecated
 */
public "get"(arg0: any): float
public "put"(arg0: K, arg1: float): float
/**
 * 
 * @deprecated
 */
public "put"(arg0: K, arg1: float): float
public "getFloat"(arg0: any): float
public "getOrDefault"(arg0: any, arg1: float): float
/**
 * 
 * @deprecated
 */
public "getOrDefault"(arg0: any, arg1: float): float
public "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
public "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
public "removeFloat"(arg0: any): float
public "andThenDouble"(arg0: $Float2DoubleFunction$Type): $Object2DoubleFunction<(K)>
public "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2FloatFunction
public "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2FloatFunction
public "andThenFloat"(arg0: $Float2FloatFunction$Type): $Object2FloatFunction<(K)>
public "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2FloatFunction
public "andThenLong"(arg0: $Float2LongFunction$Type): $Object2LongFunction<(K)>
public "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2FloatFunction
public "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2FloatFunction
public "andThenInt"(arg0: $Float2IntFunction$Type): $Object2IntFunction<(K)>
public "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2FloatFunction
public "andThenChar"(arg0: $Float2CharFunction$Type): $Object2CharFunction<(K)>
public "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2FloatFunction<(T)>
public "andThenReference"<T>(arg0: $Float2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
public "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2FloatFunction<(T)>
public "andThenObject"<T>(arg0: $Float2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
public "andThenByte"(arg0: $Float2ByteFunction$Type): $Object2ByteFunction<(K)>
public "andThenShort"(arg0: $Float2ShortFunction$Type): $Object2ShortFunction<(K)>
public "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2FloatFunction
public "clear"(): void
public "size"(): integer
public "apply"(arg0: K): float
public "containsKey"(arg0: any): boolean
public static "identity"<T>(): $Function<(K), (K)>
public "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractObject2FloatFunction$Type<K> = ($AbstractObject2FloatFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractObject2FloatFunction_<K> = $AbstractObject2FloatFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction" {
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Object2BooleanFunction<K> extends $Function$0<(K), (boolean)>, $Predicate<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: boolean): boolean
 "put"(arg0: K, arg1: boolean): boolean
 "getBoolean"(arg0: any): boolean
 "test"(arg0: K): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "andThenDouble"(arg0: $Boolean2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2BooleanFunction
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2BooleanFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$Type): $Object2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2BooleanFunction
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2BooleanFunction
 "andThenInt"(arg0: $Boolean2IntFunction$Type): $Object2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$Type): $Object2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2BooleanFunction<(T)>
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2BooleanFunction<(T)>
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Boolean2ByteFunction$Type): $Object2ByteFunction<(K)>
 "defaultReturnValue"(): boolean
 "defaultReturnValue"(arg0: boolean): void
 "removeBoolean"(arg0: any): boolean
 "andThenShort"(arg0: $Boolean2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2BooleanFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): boolean
 "containsKey"(arg0: any): boolean
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
 "negate"(): $Predicate<(K)>
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (boolean)>

(arg0: any): boolean
}

export namespace $Object2BooleanFunction {
function isEqual<T>(arg0: any): $Predicate<(K)>
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2BooleanFunction$Type<K> = ($Object2BooleanFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2BooleanFunction_<K> = $Object2BooleanFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntComparator" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$ToLongFunction, $ToLongFunction$Type} from "packages/java/util/function/$ToLongFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"

export interface $IntComparator extends $Comparator<(integer)> {

/**
 * 
 * @deprecated
 */
 "compare"(arg0: integer, arg1: integer): integer
 "compare"(arg0: integer, arg1: integer): integer
 "thenComparing"(arg0: $Comparator$Type<(any)>): $Comparator<(integer)>
 "thenComparing"(arg0: $IntComparator$Type): $IntComparator
 "reversed"(): $IntComparator
 "equals"(arg0: any): boolean
 "thenComparing"<U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(integer)>
 "thenComparing"<U extends $Comparable<(any)>>(arg0: $Function$Type<(any), (any)>): $Comparator<(integer)>
 "thenComparingInt"(arg0: $ToIntFunction$Type<(any)>): $Comparator<(integer)>
 "thenComparingLong"(arg0: $ToLongFunction$Type<(any)>): $Comparator<(integer)>
 "thenComparingDouble"(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(integer)>
}

export namespace $IntComparator {
function reverseOrder<T>(): $Comparator<(integer)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>): $Comparator<(integer)>
function comparing<T, U>(arg0: $Function$Type<(any), (any)>, arg1: $Comparator$Type<(any)>): $Comparator<(integer)>
function comparingInt<T>(arg0: $ToIntFunction$Type<(any)>): $Comparator<(integer)>
function comparingLong<T>(arg0: $ToLongFunction$Type<(any)>): $Comparator<(integer)>
function comparingDouble<T>(arg0: $ToDoubleFunction$Type<(any)>): $Comparator<(integer)>
function naturalOrder<T>(): $Comparator<(integer)>
function nullsFirst<T>(arg0: $Comparator$Type<(any)>): $Comparator<(integer)>
function nullsLast<T>(arg0: $Comparator$Type<(any)>): $Comparator<(integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntComparator$Type = ($IntComparator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntComparator_ = $IntComparator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongBidirectionalIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$Type as $LongConsumer$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongConsumer"
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterator"
import {$LongIterator, $LongIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIterator"

export interface $LongBidirectionalIterator extends $LongIterator, $ObjectBidirectionalIterator<(long)> {

 "skip"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "previous"(): long
 "back"(arg0: integer): integer
 "previousLong"(): long
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $LongConsumer$0$Type): void
 "nextLong"(): long
 "forEachRemaining"(arg0: $LongConsumer$Type): void
 "hasPrevious"(): boolean
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $LongBidirectionalIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongBidirectionalIterator$Type = ($LongBidirectionalIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongBidirectionalIterator_ = $LongBidirectionalIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongUnaryOperator" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$LongUnaryOperator as $LongUnaryOperator$0, $LongUnaryOperator$Type as $LongUnaryOperator$0$Type} from "packages/java/util/function/$LongUnaryOperator"

export interface $LongUnaryOperator extends $UnaryOperator<(long)>, $LongUnaryOperator$0 {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: long): long
 "apply"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "applyAsLong"(arg0: long): long
 "compose"(arg0: $LongUnaryOperator$0$Type): $LongUnaryOperator$0
 "andThen"(arg0: $LongUnaryOperator$0$Type): $LongUnaryOperator$0
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (long)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(long), (V)>

(arg0: long): long
}

export namespace $LongUnaryOperator {
function identity(): $LongUnaryOperator
function negation(): $LongUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongUnaryOperator$Type = ($LongUnaryOperator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongUnaryOperator_ = $LongUnaryOperator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntConsumer" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$Type as $IntConsumer$0$Type} from "packages/java/util/function/$IntConsumer"

export interface $IntConsumer extends $Consumer<(integer)>, $IntConsumer$0 {

/**
 * 
 * @deprecated
 */
 "accept"(arg0: integer): void
/**
 * 
 * @deprecated
 */
 "andThen"(arg0: $Consumer$Type<(any)>): $Consumer<(integer)>
 "andThen"(arg0: $IntConsumer$Type): $IntConsumer
 "accept"(arg0: integer): void

(arg0: integer): void
}

export namespace $IntConsumer {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntConsumer$Type = ($IntConsumer);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntConsumer_ = $IntConsumer$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$AbstractLong2ObjectFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export class $AbstractLong2ObjectFunction<V> implements $Long2ObjectFunction<(V)>, $Serializable {


public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public "remove"(arg0: long): V
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
public "get"(arg0: any): V
public "get"(arg0: long): V
/**
 * 
 * @deprecated
 */
public "put"(arg0: long, arg1: V): V
public "put"(arg0: long, arg1: V): V
public "apply"(arg0: long): V
/**
 * 
 * @deprecated
 */
public "containsKey"(arg0: any): boolean
public "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
public "getOrDefault"(arg0: any, arg1: V): V
public "getOrDefault"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
public "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
public "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Long2DoubleFunction
public "composeChar"(arg0: $Char2LongFunction$Type): $Char2ObjectFunction<(V)>
public "composeShort"(arg0: $Short2LongFunction$Type): $Short2ObjectFunction<(V)>
public "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Long2FloatFunction
public "composeFloat"(arg0: $Float2LongFunction$Type): $Float2ObjectFunction<(V)>
public "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Long2LongFunction
public "composeLong"(arg0: $Long2LongFunction$Type): $Long2ObjectFunction<(V)>
public "composeInt"(arg0: $Int2LongFunction$Type): $Int2ObjectFunction<(V)>
public "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Long2IntFunction
public "composeDouble"(arg0: $Double2LongFunction$Type): $Double2ObjectFunction<(V)>
public "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Long2CharFunction
public "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
public "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Long2ReferenceFunction<(T)>
public "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
public "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Long2ObjectFunction<(T)>
public "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Long2ByteFunction
public "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Long2ShortFunction
public "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2ObjectFunction<(V)>
public "clear"(): void
public "size"(): integer
public "apply"(arg0: long): V
public static "identity"<T>(): $Function<(long), (long)>
public "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(long), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractLong2ObjectFunction$Type<V> = ($AbstractLong2ObjectFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractLong2ObjectFunction_<V> = $AbstractLong2ObjectFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Reference2CharFunction<K> extends $Function$0<(K), (character)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): character
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): character
 "put"(arg0: K, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: character): character
 "getChar"(arg0: any): character
 "getOrDefault"(arg0: any, arg1: character): character
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeChar"(arg0: any): character
 "andThenDouble"(arg0: $Char2DoubleFunction$Type): $Reference2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2CharFunction
 "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2CharFunction
 "andThenFloat"(arg0: $Char2FloatFunction$Type): $Reference2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$Type): $Reference2LongFunction<(K)>
 "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2CharFunction
 "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2CharFunction
 "andThenInt"(arg0: $Char2IntFunction$Type): $Reference2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$Type): $Reference2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2CharFunction<(T)>
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$Type<(any)>): $Reference2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2CharFunction<(T)>
 "andThenObject"<T>(arg0: $Char2ObjectFunction$Type<(any)>): $Reference2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Char2ByteFunction$Type): $Reference2ByteFunction<(K)>
 "defaultReturnValue"(): character
 "defaultReturnValue"(arg0: character): void
 "andThenShort"(arg0: $Char2ShortFunction$Type): $Reference2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2CharFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): character
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (character)>

(arg0: any): character
}

export namespace $Reference2CharFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2CharFunction$Type<K> = ($Reference2CharFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2CharFunction_<K> = $Reference2CharFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Short2ReferenceFunction<V> extends $Function$0<(short), (V)>, $IntFunction<(V)> {

 "remove"(arg0: short): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: short): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: V): V
 "put"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: short, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Short2DoubleFunction
 "composeChar"(arg0: $Char2ShortFunction$Type): $Char2ReferenceFunction<(V)>
 "composeShort"(arg0: $Short2ShortFunction$Type): $Short2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Short2FloatFunction
 "composeFloat"(arg0: $Float2ShortFunction$Type): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Short2LongFunction
 "composeLong"(arg0: $Long2ShortFunction$Type): $Long2ReferenceFunction<(V)>
 "composeInt"(arg0: $Int2ShortFunction$Type): $Int2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Short2IntFunction
 "composeDouble"(arg0: $Double2ShortFunction$Type): $Double2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Short2CharFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$Type<(any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Short2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ShortFunction$Type<(any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Short2ObjectFunction<(T)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Short2ByteFunction
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Short2ShortFunction
 "composeByte"(arg0: $Byte2ShortFunction$Type): $Byte2ReferenceFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: short): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(short), (V)>

(arg0: short): V
}

export namespace $Short2ReferenceFunction {
function identity<T>(): $Function<(short), (short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2ReferenceFunction$Type<V> = ($Short2ReferenceFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2ReferenceFunction_<V> = $Short2ReferenceFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$LongFunction, $LongFunction$Type} from "packages/java/util/function/$LongFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Long2ObjectMap$Entry, $Long2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap$Entry"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Long2ObjectMap<V> extends $Long2ObjectFunction<(V)>, $Map<(long), (V)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
 "remove"(arg0: long, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: V): V
 "clear"(): void
 "replace"(arg0: long, arg1: V, arg2: V): boolean
 "replace"(arg0: long, arg1: V): V
 "size"(): integer
 "merge"(arg0: long, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(long), (V)>)>
 "putIfAbsent"(arg0: long, arg1: V): V
 "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: long, arg1: $Long2ObjectFunction$Type<(any)>): V
 "computeIfAbsent"(arg0: long, arg1: $LongFunction$Type<(any)>): V
 "getOrDefault"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "long2ObjectEntrySet"(): $ObjectSet<($Long2ObjectMap$Entry<(V)>)>
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: long, arg1: $Long2ObjectFunction$Type<(any)>): V
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "remove"(arg0: long): V
 "get"(arg0: long): V
 "put"(arg0: long, arg1: V): V
 "apply"(arg0: long): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Long2DoubleFunction
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2ObjectFunction<(V)>
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Long2FloatFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2ObjectFunction<(V)>
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Long2IntFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Long2CharFunction
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Long2ObjectFunction<(T)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Long2ByteFunction
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Long2ShortFunction
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2ObjectFunction<(V)>
 "remove"(arg0: any, arg1: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replace"(arg0: long, arg1: V): V
 "replace"(arg0: long, arg1: V, arg2: V): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "merge"(arg0: long, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "putIfAbsent"(arg0: long, arg1: V): V
 "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "computeIfAbsent"(arg0: long, arg1: $Function$Type<(any), (any)>): V
 "containsValue"(arg0: any): boolean
 "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "apply"(arg0: long): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(long), (V)>
}

export namespace $Long2ObjectMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V): $Map<(long), (V)>
function of<K, V>(): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V, arg18: long, arg19: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V): $Map<(long), (V)>
function of<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V): $Map<(long), (V)>
function entry<K, V>(arg0: long, arg1: V): $Map$Entry<(long), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(long), (V)>
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ObjectMap$Type<V> = ($Long2ObjectMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ObjectMap_<V> = $Long2ObjectMap$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2IntMap" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$IntBinaryOperator, $IntBinaryOperator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntBinaryOperator"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Int2IntMap$Entry, $Int2IntMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntMap$Entry"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$IntBinaryOperator as $IntBinaryOperator$0, $IntBinaryOperator$Type as $IntBinaryOperator$0$Type} from "packages/java/util/function/$IntBinaryOperator"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"
import {$Map, $Map$Type} from "packages/java/util/$Map"

export interface $Int2IntMap extends $Int2IntFunction, $Map<(integer), (integer)> {

 "remove"(arg0: integer, arg1: integer): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any, arg1: any): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: integer): integer
 "clear"(): void
 "replace"(arg0: integer, arg1: integer, arg2: integer): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: integer, arg1: integer, arg2: integer): boolean
/**
 * 
 * @deprecated
 */
 "replace"(arg0: integer, arg1: integer): integer
 "replace"(arg0: integer, arg1: integer): integer
 "size"(): integer
 "merge"(arg0: integer, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
 "merge"(arg0: integer, arg1: integer, arg2: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
 "entrySet"(): $ObjectSet<($Map$Entry<(integer), (integer)>)>
/**
 * 
 * @deprecated
 */
 "putIfAbsent"(arg0: integer, arg1: integer): integer
 "putIfAbsent"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "compute"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): integer
 "compute"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): integer
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: integer, arg1: $IntUnaryOperator$Type): integer
/**
 * 
 * @deprecated
 */
 "computeIfAbsent"(arg0: integer, arg1: $Function$Type<(any), (any)>): integer
 "computeIfAbsent"(arg0: integer, arg1: $Int2IntFunction$Type): integer
 "containsValue"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsValue"(arg0: any): boolean
 "getOrDefault"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): integer
/**
 * 
 * @deprecated
 */
 "computeIfPresent"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): integer
 "computeIfAbsentNullable"(arg0: integer, arg1: $IntFunction$Type<(any)>): integer
 "mergeInt"(arg0: integer, arg1: integer, arg2: $IntBinaryOperator$Type): integer
 "mergeInt"(arg0: integer, arg1: integer, arg2: $IntBinaryOperator$0$Type): integer
/**
 * 
 * @deprecated
 */
 "computeIfAbsentPartial"(arg0: integer, arg1: $Int2IntFunction$Type): integer
 "defaultReturnValue"(): integer
 "defaultReturnValue"(arg0: integer): void
 "int2IntEntrySet"(): $ObjectSet<($Int2IntMap$Entry)>
 "remove"(arg0: integer): integer
 "get"(arg0: integer): integer
 "put"(arg0: integer, arg1: integer): integer
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (T)>
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Int2DoubleFunction
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2IntFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Int2FloatFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$Type): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Int2IntFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$Type): $Int2CharFunction
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2IntFunction<(T)>
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Int2ObjectFunction<(T)>
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Int2ByteFunction
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Int2ShortFunction
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2IntFunction
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "apply"(arg0: integer): integer
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
}

export namespace $Int2IntMap {
function identity(): $Int2IntFunction
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): $Map<(integer), (integer)>
function of<K, V>(): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer, arg12: integer, arg13: integer, arg14: integer, arg15: integer, arg16: integer, arg17: integer, arg18: integer, arg19: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer, arg12: integer, arg13: integer, arg14: integer, arg15: integer, arg16: integer, arg17: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer, arg12: integer, arg13: integer, arg14: integer, arg15: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer, arg12: integer, arg13: integer): $Map<(integer), (integer)>
function of<K, V>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer, arg10: integer, arg11: integer): $Map<(integer), (integer)>
function entry<K, V>(arg0: integer, arg1: integer): $Map$Entry<(integer), (integer)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2IntMap$Type = ($Int2IntMap);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2IntMap_ = $Int2IntMap$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2IntFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export class $AbstractObject2IntFunction<K> implements $Object2IntFunction<(K)>, $Serializable {


public "defaultReturnValue"(arg0: integer): void
public "defaultReturnValue"(): integer
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): integer
public "put"(arg0: K, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public "put"(arg0: K, arg1: integer): integer
public "getInt"(arg0: any): integer
public "getOrDefault"(arg0: any, arg1: integer): integer
/**
 * 
 * @deprecated
 */
public "getOrDefault"(arg0: any, arg1: integer): integer
public "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
public "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
public "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Object2DoubleFunction<(K)>
public "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2IntFunction
public "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2IntFunction
public "andThenFloat"(arg0: $Int2FloatFunction$Type): $Object2FloatFunction<(K)>
public "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2IntFunction
public "andThenLong"(arg0: $Int2LongFunction$Type): $Object2LongFunction<(K)>
public "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2IntFunction
public "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2IntFunction
public "andThenInt"(arg0: $Int2IntFunction$Type): $Object2IntFunction<(K)>
public "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2IntFunction
public "andThenChar"(arg0: $Int2CharFunction$Type): $Object2CharFunction<(K)>
public "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2IntFunction<(T)>
public "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
public "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2IntFunction<(T)>
public "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
public "andThenByte"(arg0: $Int2ByteFunction$Type): $Object2ByteFunction<(K)>
public "andThenShort"(arg0: $Int2ShortFunction$Type): $Object2ShortFunction<(K)>
public "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2IntFunction
public "removeInt"(arg0: any): integer
public "clear"(): void
public "size"(): integer
public "apply"(arg0: K): integer
public "containsKey"(arg0: any): boolean
public static "identity"<T>(): $Function<(K), (K)>
public "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractObject2IntFunction$Type<K> = ($AbstractObject2IntFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractObject2IntFunction_<K> = $AbstractObject2IntFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Reference2ReferenceMap$Entry<K, V> extends $Map$Entry<(K), (V)> {

 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "getValue"(): V
 "getKey"(): K
 "setValue"(arg0: V): V
}

export namespace $Reference2ReferenceMap$Entry {
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(K), (V)>)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (V)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(K), (V)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (V)>)>
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2ReferenceMap$Entry$Type<K, V> = ($Reference2ReferenceMap$Entry<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2ReferenceMap$Entry_<K, V> = $Reference2ReferenceMap$Entry$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$Type} from "packages/java/util/function/$IntToDoubleFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Short2DoubleFunction extends $Function$0<(short), (double)>, $IntToDoubleFunction {

 "remove"(arg0: short): double
 "get"(arg0: short): double
 "put"(arg0: short, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: double): double
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: short, arg1: double): double
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(short), (T)>
 "andThenDouble"(arg0: $Double2DoubleFunction$Type): $Short2DoubleFunction
 "composeChar"(arg0: $Char2ShortFunction$Type): $Char2DoubleFunction
 "composeShort"(arg0: $Short2ShortFunction$Type): $Short2DoubleFunction
 "andThenFloat"(arg0: $Double2FloatFunction$Type): $Short2FloatFunction
 "composeFloat"(arg0: $Float2ShortFunction$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$Type): $Short2LongFunction
 "composeLong"(arg0: $Long2ShortFunction$Type): $Long2DoubleFunction
 "composeInt"(arg0: $Int2ShortFunction$Type): $Int2DoubleFunction
 "andThenInt"(arg0: $Double2IntFunction$Type): $Short2IntFunction
 "composeDouble"(arg0: $Double2ShortFunction$Type): $Double2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$Type): $Short2CharFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$Type<(any)>): $Object2DoubleFunction<(T)>
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$Type<(any)>): $Short2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ShortFunction$Type<(any)>): $Reference2DoubleFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$Type<(any)>): $Short2ObjectFunction<(T)>
 "andThenByte"(arg0: $Double2ByteFunction$Type): $Short2ByteFunction
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenShort"(arg0: $Double2ShortFunction$Type): $Short2ShortFunction
 "composeByte"(arg0: $Byte2ShortFunction$Type): $Byte2DoubleFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: short): double

(arg0: short): double
}

export namespace $Short2DoubleFunction {
function identity<T>(): $Function<(short), (short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2DoubleFunction$Type = ($Short2DoubleFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2DoubleFunction_ = $Short2DoubleFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$IntToLongFunction, $IntToLongFunction$Type} from "packages/java/util/function/$IntToLongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Byte2LongFunction extends $Function$0<(byte), (long)>, $IntToLongFunction {

 "remove"(arg0: byte): long
 "get"(arg0: byte): long
 "put"(arg0: byte, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: long): long
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: byte, arg1: long): long
/**
 * 
 * @deprecated
 */
 "applyAsLong"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(byte), (T)>
 "andThenDouble"(arg0: $Long2DoubleFunction$Type): $Byte2DoubleFunction
 "composeChar"(arg0: $Char2ByteFunction$Type): $Char2LongFunction
 "composeShort"(arg0: $Short2ByteFunction$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$Type): $Byte2FloatFunction
 "composeFloat"(arg0: $Float2ByteFunction$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$Type): $Byte2LongFunction
 "composeLong"(arg0: $Long2ByteFunction$Type): $Long2LongFunction
 "composeInt"(arg0: $Int2ByteFunction$Type): $Int2LongFunction
 "andThenInt"(arg0: $Long2IntFunction$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2ByteFunction$Type): $Double2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$Type): $Byte2CharFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$Type<(any)>): $Object2LongFunction<(T)>
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$Type<(any)>): $Byte2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ByteFunction$Type<(any)>): $Reference2LongFunction<(T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$Type<(any)>): $Byte2ObjectFunction<(T)>
 "andThenByte"(arg0: $Long2ByteFunction$Type): $Byte2ByteFunction
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenShort"(arg0: $Long2ShortFunction$Type): $Byte2ShortFunction
 "composeByte"(arg0: $Byte2ByteFunction$Type): $Byte2LongFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: byte): long

(arg0: byte): long
}

export namespace $Byte2LongFunction {
function identity<T>(): $Function<(byte), (byte)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2LongFunction$Type = ($Byte2LongFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2LongFunction_ = $Byte2LongFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"

export interface $Boolean2DoubleFunction extends $Function$0<(boolean), (double)> {

 "remove"(arg0: boolean): double
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): double
 "get"(arg0: boolean): double
 "put"(arg0: boolean, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: double): double
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: boolean, arg1: double): double
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(boolean), (T)>
 "andThenDouble"(arg0: $Double2DoubleFunction$Type): $Boolean2DoubleFunction
 "composeChar"(arg0: $Char2BooleanFunction$Type): $Char2DoubleFunction
 "composeShort"(arg0: $Short2BooleanFunction$Type): $Short2DoubleFunction
 "andThenFloat"(arg0: $Double2FloatFunction$Type): $Boolean2FloatFunction
 "composeFloat"(arg0: $Float2BooleanFunction$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$Type): $Boolean2LongFunction
 "composeLong"(arg0: $Long2BooleanFunction$Type): $Long2DoubleFunction
 "composeInt"(arg0: $Int2BooleanFunction$Type): $Int2DoubleFunction
 "andThenInt"(arg0: $Double2IntFunction$Type): $Boolean2IntFunction
 "composeDouble"(arg0: $Double2BooleanFunction$Type): $Double2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$Type): $Boolean2CharFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$Type<(any)>): $Object2DoubleFunction<(T)>
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$Type<(any)>): $Boolean2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2BooleanFunction$Type<(any)>): $Reference2DoubleFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$Type<(any)>): $Boolean2ObjectFunction<(T)>
 "andThenByte"(arg0: $Double2ByteFunction$Type): $Boolean2ByteFunction
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenShort"(arg0: $Double2ShortFunction$Type): $Boolean2ShortFunction
 "composeByte"(arg0: $Byte2BooleanFunction$Type): $Byte2DoubleFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: boolean): double

(arg0: boolean): double
}

export namespace $Boolean2DoubleFunction {
function identity<T>(): $Function<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2DoubleFunction$Type = ($Boolean2DoubleFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2DoubleFunction_ = $Boolean2DoubleFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$AbstractObjectList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectListIterator, $ObjectListIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectListIterator"
import {$ObjectList, $ObjectList$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectList"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$List, $List$Type} from "packages/java/util/$List"
import {$AbstractObjectCollection, $AbstractObjectCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractObjectCollection"
import {$Stack, $Stack$Type} from "packages/it/unimi/dsi/fastutil/$Stack"

export class $AbstractObjectList<K> extends $AbstractObjectCollection<(K)> implements $ObjectList<(K)>, $Stack<(K)> {


public "add"(arg0: K): boolean
public "add"(arg0: integer, arg1: K): void
public "remove"(arg0: integer): K
public "equals"(arg0: any): boolean
public "toString"(): string
public "hashCode"(): integer
public "compareTo"(arg0: $List$Type<(any)>): integer
public "indexOf"(arg0: any): integer
public "clear"(): void
public "lastIndexOf"(arg0: any): integer
public "size"(arg0: integer): void
public "toArray"<T>(arg0: (T)[]): (T)[]
public "toArray"(): (any)[]
public "contains"(arg0: any): boolean
public "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
public "addAll"(arg0: $Collection$Type<(any)>): boolean
public "set"(arg0: integer, arg1: K): K
public "forEach"(arg0: $Consumer$Type<(any)>): void
public "top"(): K
public "peek"(arg0: integer): K
public "listIterator"(): $ObjectListIterator<(K)>
public "push"(arg0: K): void
public "pop"(): K
public "addElements"(arg0: integer, arg1: (K)[]): void
public "addElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
public "removeElements"(arg0: integer, arg1: integer): void
public "getElements"(arg0: integer, arg1: (any)[], arg2: integer, arg3: integer): void
public "setElements"(arg0: integer, arg1: (K)[], arg2: integer, arg3: integer): void
public static "of"<K>(...arg0: (K)[]): $ObjectList<(K)>
public static "of"<K>(arg0: K, arg1: K, arg2: K): $ObjectList<(K)>
public static "of"<K>(arg0: K, arg1: K): $ObjectList<(K)>
public static "of"<K>(): $ObjectList<(K)>
public static "of"<K>(arg0: K): $ObjectList<(K)>
public "addAll"(arg0: $ObjectList$Type<(any)>): boolean
public "addAll"(arg0: integer, arg1: $ObjectList$Type<(any)>): boolean
public "sort"(arg0: $Comparator$Type<(any)>): void
public "unstableSort"(arg0: $Comparator$Type<(any)>): void
public "setElements"(arg0: integer, arg1: (K)[]): void
public "setElements"(arg0: (K)[]): void
public "isEmpty"(): boolean
public "remove"(arg0: any): boolean
public "get"(arg0: integer): K
public static "copyOf"<E>(arg0: $Collection$Type<(any)>): $List<(K)>
public "replaceAll"(arg0: $UnaryOperator$Type<(K)>): void
public "size"(): integer
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K, arg9: K): $List<(K)>
public static "of"<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K): $List<(K)>
public "removeAll"(arg0: $Collection$Type<(any)>): boolean
public "retainAll"(arg0: $Collection$Type<(any)>): boolean
public "containsAll"(arg0: $Collection$Type<(any)>): boolean
set "elements"(value: (K)[])
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractObjectList$Type<K> = ($AbstractObjectList<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractObjectList_<K> = $AbstractObjectList$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Int2ShortFunction extends $Function$0<(integer), (short)>, $IntUnaryOperator {

 "remove"(arg0: integer): short
 "get"(arg0: integer): short
 "put"(arg0: integer, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: short): short
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: integer, arg1: short): short
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (T)>
 "andThenDouble"(arg0: $Short2DoubleFunction$Type): $Int2DoubleFunction
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2ShortFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2ShortFunction
 "andThenFloat"(arg0: $Short2FloatFunction$Type): $Int2FloatFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$Type): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2ShortFunction
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2ShortFunction
 "andThenInt"(arg0: $Short2IntFunction$Type): $Int2IntFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$Type): $Int2CharFunction
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2ShortFunction<(T)>
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$Type<(any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2ShortFunction<(T)>
 "andThenObject"<T>(arg0: $Short2ObjectFunction$Type<(any)>): $Int2ObjectFunction<(T)>
 "andThenByte"(arg0: $Short2ByteFunction$Type): $Int2ByteFunction
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "andThenShort"(arg0: $Short2ShortFunction$Type): $Int2ShortFunction
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2ShortFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: integer): short
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: integer): short
}

export namespace $Int2ShortFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2ShortFunction$Type = ($Int2ShortFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2ShortFunction_ = $Int2ShortFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongSortedSet" {
import {$LongStream, $LongStream$Type} from "packages/java/util/stream/$LongStream"
import {$LongSpliterator, $LongSpliterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSpliterator"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$LongSet, $LongSet$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSet"
import {$LongIterator, $LongIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIterator"
import {$LongPredicate, $LongPredicate$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongPredicate"
import {$LongBidirectionalIterator, $LongBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongBidirectionalIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LongPredicate as $LongPredicate$0, $LongPredicate$Type as $LongPredicate$0$Type} from "packages/java/util/function/$LongPredicate"
import {$SortedSet, $SortedSet$Type} from "packages/java/util/$SortedSet"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$LongBidirectionalIterable, $LongBidirectionalIterable$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongBidirectionalIterable"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$Type as $LongConsumer$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongConsumer"
import {$LongCollection, $LongCollection$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongCollection"

export interface $LongSortedSet extends $LongSet, $SortedSet<(long)>, $LongBidirectionalIterable {

 "iterator"(arg0: long): $LongBidirectionalIterator
/**
 * 
 * @deprecated
 */
 "first"(): long
 "subSet"(arg0: long, arg1: long): $LongSortedSet
/**
 * 
 * @deprecated
 */
 "subSet"(arg0: long, arg1: long): $LongSortedSet
 "headSet"(arg0: long): $LongSortedSet
/**
 * 
 * @deprecated
 */
 "headSet"(arg0: long): $LongSortedSet
/**
 * 
 * @deprecated
 */
 "tailSet"(arg0: long): $LongSortedSet
 "tailSet"(arg0: long): $LongSortedSet
 "lastLong"(): long
 "firstLong"(): long
/**
 * 
 * @deprecated
 */
 "add"(arg0: long): boolean
 "remove"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "rem"(arg0: long): boolean
 "add"(arg0: long): boolean
 "toArray"(arg0: (long)[]): (long)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(long)>
 "contains"(arg0: long): boolean
 "addAll"(arg0: $LongCollection$Type): boolean
 "removeIf"(arg0: $LongPredicate$0$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $LongPredicate$Type): boolean
 "removeAll"(arg0: $LongCollection$Type): boolean
 "retainAll"(arg0: $LongCollection$Type): boolean
 "containsAll"(arg0: $LongCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(long)>
 "longStream"(): $LongStream
 "toLongArray"(): (long)[]
/**
 * 
 * @deprecated
 */
 "toLongArray"(arg0: (long)[]): (long)[]
 "longIterator"(): $LongIterator
 "longParallelStream"(): $LongStream
 "longSpliterator"(): $LongSpliterator
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "forEach"(arg0: $LongConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $LongConsumer$0$Type): void
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
}

export namespace $LongSortedSet {
function of(arg0: long, arg1: long): $LongSet
function of(): $LongSet
function of(...arg0: (long)[]): $LongSet
function of(arg0: long): $LongSet
function of(arg0: long, arg1: long, arg2: long): $LongSet
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long): $Set<(long)>
function of<E>(arg0: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long, arg9: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long): $Set<(long)>
function of<E>(...arg0: (long)[]): $Set<(long)>
function of<E>(arg0: long, arg1: long, arg2: long): $Set<(long)>
function of<E>(arg0: long, arg1: long): $Set<(long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongSortedSet$Type = ($LongSortedSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongSortedSet_ = $LongSortedSet$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction" {
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Function, $Function$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$LongUnaryOperator, $LongUnaryOperator$Type} from "packages/java/util/function/$LongUnaryOperator"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"

export interface $Long2LongFunction extends $Function<(long), (long)>, $LongUnaryOperator {

 "remove"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): long
 "get"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: long): long
 "put"(arg0: long, arg1: long): long
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: long, arg1: long): long
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "applyAsLong"(arg0: long): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(long), (T)>
 "andThenDouble"(arg0: $Long2DoubleFunction$Type): $Long2DoubleFunction
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2LongFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$Type): $Long2FloatFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$Type): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2LongFunction
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2LongFunction
 "andThenInt"(arg0: $Long2IntFunction$Type): $Long2IntFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$Type): $Long2CharFunction
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2LongFunction<(T)>
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$Type<(any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2LongFunction<(T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$Type<(any)>): $Long2ObjectFunction<(T)>
 "andThenByte"(arg0: $Long2ByteFunction$Type): $Long2ByteFunction
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenShort"(arg0: $Long2ShortFunction$Type): $Long2ShortFunction
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2LongFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: long): long
 "compose"(arg0: $LongUnaryOperator$Type): $LongUnaryOperator
 "andThen"(arg0: $LongUnaryOperator$Type): $LongUnaryOperator

(arg0: long): long
}

export namespace $Long2LongFunction {
function identity(): $Long2LongFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2LongFunction$Type = ($Long2LongFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2LongFunction_ = $Long2LongFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$IntToLongFunction, $IntToLongFunction$Type} from "packages/java/util/function/$IntToLongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Char2LongFunction extends $Function$0<(character), (long)>, $IntToLongFunction {

 "remove"(arg0: character): long
 "get"(arg0: character): long
 "put"(arg0: character, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: long): long
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: character, arg1: long): long
/**
 * 
 * @deprecated
 */
 "applyAsLong"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(character), (T)>
 "andThenDouble"(arg0: $Long2DoubleFunction$Type): $Char2DoubleFunction
 "composeChar"(arg0: $Char2CharFunction$Type): $Char2LongFunction
 "composeShort"(arg0: $Short2CharFunction$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$Type): $Char2FloatFunction
 "composeFloat"(arg0: $Float2CharFunction$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$Type): $Char2LongFunction
 "composeLong"(arg0: $Long2CharFunction$Type): $Long2LongFunction
 "composeInt"(arg0: $Int2CharFunction$Type): $Int2LongFunction
 "andThenInt"(arg0: $Long2IntFunction$Type): $Char2IntFunction
 "composeDouble"(arg0: $Double2CharFunction$Type): $Double2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$Type): $Char2CharFunction
 "composeObject"<T>(arg0: $Object2CharFunction$Type<(any)>): $Object2LongFunction<(T)>
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$Type<(any)>): $Char2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2CharFunction$Type<(any)>): $Reference2LongFunction<(T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$Type<(any)>): $Char2ObjectFunction<(T)>
 "andThenByte"(arg0: $Long2ByteFunction$Type): $Char2ByteFunction
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenShort"(arg0: $Long2ShortFunction$Type): $Char2ShortFunction
 "composeByte"(arg0: $Byte2CharFunction$Type): $Byte2LongFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: character): long

(arg0: character): long
}

export namespace $Char2LongFunction {
function identity<T>(): $Function<(character), (character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2LongFunction$Type = ($Char2LongFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2LongFunction_ = $Char2LongFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction" {
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$IntPredicate, $IntPredicate$Type} from "packages/java/util/function/$IntPredicate"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Byte2BooleanFunction extends $Function$0<(byte), (boolean)>, $IntPredicate {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "remove"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: boolean): boolean
 "put"(arg0: byte, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
 "getOrDefault"(arg0: byte, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(byte), (T)>
 "andThenDouble"(arg0: $Boolean2DoubleFunction$Type): $Byte2DoubleFunction
 "composeChar"(arg0: $Char2ByteFunction$Type): $Char2BooleanFunction
 "composeShort"(arg0: $Short2ByteFunction$Type): $Short2BooleanFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$Type): $Byte2FloatFunction
 "composeFloat"(arg0: $Float2ByteFunction$Type): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$Type): $Byte2LongFunction
 "composeLong"(arg0: $Long2ByteFunction$Type): $Long2BooleanFunction
 "composeInt"(arg0: $Int2ByteFunction$Type): $Int2BooleanFunction
 "andThenInt"(arg0: $Boolean2IntFunction$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2ByteFunction$Type): $Double2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$Type): $Byte2CharFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$Type<(any)>): $Object2BooleanFunction<(T)>
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$Type<(any)>): $Byte2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ByteFunction$Type<(any)>): $Reference2BooleanFunction<(T)>
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$Type<(any)>): $Byte2ObjectFunction<(T)>
 "andThenByte"(arg0: $Boolean2ByteFunction$Type): $Byte2ByteFunction
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "andThenShort"(arg0: $Boolean2ShortFunction$Type): $Byte2ShortFunction
 "composeByte"(arg0: $Byte2ByteFunction$Type): $Byte2BooleanFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: byte): boolean
 "or"(arg0: $IntPredicate$Type): $IntPredicate
 "and"(arg0: $IntPredicate$Type): $IntPredicate
 "negate"(): $IntPredicate

(arg0: any): boolean
}

export namespace $Byte2BooleanFunction {
function identity<T>(): $Function<(byte), (byte)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2BooleanFunction$Type = ($Byte2BooleanFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2BooleanFunction_ = $Byte2BooleanFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Byte2ShortFunction extends $Function$0<(byte), (short)>, $IntUnaryOperator {

 "remove"(arg0: byte): short
 "get"(arg0: byte): short
 "put"(arg0: byte, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: short): short
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: byte, arg1: short): short
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(byte), (T)>
 "andThenDouble"(arg0: $Short2DoubleFunction$Type): $Byte2DoubleFunction
 "composeChar"(arg0: $Char2ByteFunction$Type): $Char2ShortFunction
 "composeShort"(arg0: $Short2ByteFunction$Type): $Short2ShortFunction
 "andThenFloat"(arg0: $Short2FloatFunction$Type): $Byte2FloatFunction
 "composeFloat"(arg0: $Float2ByteFunction$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$Type): $Byte2LongFunction
 "composeLong"(arg0: $Long2ByteFunction$Type): $Long2ShortFunction
 "composeInt"(arg0: $Int2ByteFunction$Type): $Int2ShortFunction
 "andThenInt"(arg0: $Short2IntFunction$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2ByteFunction$Type): $Double2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$Type): $Byte2CharFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$Type<(any)>): $Object2ShortFunction<(T)>
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$Type<(any)>): $Byte2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ByteFunction$Type<(any)>): $Reference2ShortFunction<(T)>
 "andThenObject"<T>(arg0: $Short2ObjectFunction$Type<(any)>): $Byte2ObjectFunction<(T)>
 "andThenByte"(arg0: $Short2ByteFunction$Type): $Byte2ByteFunction
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "andThenShort"(arg0: $Short2ShortFunction$Type): $Byte2ShortFunction
 "composeByte"(arg0: $Byte2ByteFunction$Type): $Byte2ShortFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: byte): short
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: byte): short
}

export namespace $Byte2ShortFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2ShortFunction$Type = ($Byte2ShortFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2ShortFunction_ = $Byte2ShortFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction" {
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Byte2ObjectFunction<V> extends $Function$0<(byte), (V)>, $IntFunction<(V)> {

 "remove"(arg0: byte): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: byte): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: V): V
 "put"(arg0: byte, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: byte, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Byte2DoubleFunction
 "composeChar"(arg0: $Char2ByteFunction$Type): $Char2ObjectFunction<(V)>
 "composeShort"(arg0: $Short2ByteFunction$Type): $Short2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Byte2FloatFunction
 "composeFloat"(arg0: $Float2ByteFunction$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Byte2LongFunction
 "composeLong"(arg0: $Long2ByteFunction$Type): $Long2ObjectFunction<(V)>
 "composeInt"(arg0: $Int2ByteFunction$Type): $Int2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Byte2IntFunction
 "composeDouble"(arg0: $Double2ByteFunction$Type): $Double2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Byte2CharFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Byte2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ByteFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Byte2ObjectFunction<(T)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Byte2ByteFunction
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Byte2ShortFunction
 "composeByte"(arg0: $Byte2ByteFunction$Type): $Byte2ObjectFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: byte): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(byte), (V)>

(arg0: byte): V
}

export namespace $Byte2ObjectFunction {
function identity<T>(): $Function<(byte), (byte)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2ObjectFunction$Type<V> = ($Byte2ObjectFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2ObjectFunction_<V> = $Byte2ObjectFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"
import {$DoublePredicate, $DoublePredicate$Type} from "packages/java/util/function/$DoublePredicate"

export interface $Double2BooleanFunction extends $Function$0<(double), (boolean)>, $DoublePredicate {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "remove"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: boolean): boolean
 "put"(arg0: double, arg1: boolean): boolean
 "test"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: double): boolean
 "getOrDefault"(arg0: double, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(double), (T)>
 "andThenDouble"(arg0: $Boolean2DoubleFunction$Type): $Double2DoubleFunction
 "composeChar"(arg0: $Char2DoubleFunction$Type): $Char2BooleanFunction
 "composeShort"(arg0: $Short2DoubleFunction$Type): $Short2BooleanFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2DoubleFunction$Type): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$Type): $Double2LongFunction
 "composeLong"(arg0: $Long2DoubleFunction$Type): $Long2BooleanFunction
 "composeInt"(arg0: $Int2DoubleFunction$Type): $Int2BooleanFunction
 "andThenInt"(arg0: $Boolean2IntFunction$Type): $Double2IntFunction
 "composeDouble"(arg0: $Double2DoubleFunction$Type): $Double2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$Type): $Double2CharFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$Type<(any)>): $Object2BooleanFunction<(T)>
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$Type<(any)>): $Double2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2DoubleFunction$Type<(any)>): $Reference2BooleanFunction<(T)>
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$Type<(any)>): $Double2ObjectFunction<(T)>
 "andThenByte"(arg0: $Boolean2ByteFunction$Type): $Double2ByteFunction
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "andThenShort"(arg0: $Boolean2ShortFunction$Type): $Double2ShortFunction
 "composeByte"(arg0: $Byte2DoubleFunction$Type): $Byte2BooleanFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: double): boolean
 "or"(arg0: $DoublePredicate$Type): $DoublePredicate
 "and"(arg0: $DoublePredicate$Type): $DoublePredicate
 "negate"(): $DoublePredicate

(arg0: any): boolean
}

export namespace $Double2BooleanFunction {
function identity<T>(): $Function<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2BooleanFunction$Type = ($Double2BooleanFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2BooleanFunction_ = $Double2BooleanFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2IntSortedMap" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Object2IntMap$Entry, $Object2IntMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntMap$Entry"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ObjectSortedSet, $ObjectSortedSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSortedSet"
import {$Object2IntSortedMap, $Object2IntSortedMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntSortedMap"
import {$AbstractObject2IntMap, $AbstractObject2IntMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2IntMap"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $AbstractObject2IntSortedMap<K> extends $AbstractObject2IntMap<(K)> implements $Object2IntSortedMap<(K)> {


public "comparator"(): $Comparator<(any)>
public "object2IntEntrySet"(): $ObjectSortedSet<($Object2IntMap$Entry<(K)>)>
public "defaultReturnValue"(arg0: integer): void
public "defaultReturnValue"(): integer
public "firstKey"(): K
public "lastKey"(): K
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer): $Map<(K), (integer)>
public static "of"<K, V>(): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer, arg18: K, arg19: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer, arg16: K, arg17: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer, arg14: K, arg15: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer, arg12: K, arg13: integer): $Map<(K), (integer)>
public static "of"<K, V>(arg0: K, arg1: integer, arg2: K, arg3: integer, arg4: K, arg5: integer, arg6: K, arg7: integer, arg8: K, arg9: integer, arg10: K, arg11: integer): $Map<(K), (integer)>
public static "entry"<K, V>(arg0: K, arg1: integer): $Map$Entry<(K), (integer)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (integer)>
public static "identity"<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractObject2IntSortedMap$Type<K> = ($AbstractObject2IntSortedMap<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractObject2IntSortedMap_<K> = $AbstractObject2IntSortedMap$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Object2FloatFunction<K> extends $Function$0<(K), (float)>, $ToDoubleFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): float
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): float
 "put"(arg0: K, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: float): float
 "getFloat"(arg0: any): float
 "getOrDefault"(arg0: any, arg1: float): float
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeFloat"(arg0: any): float
 "andThenDouble"(arg0: $Float2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2FloatFunction
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2FloatFunction
 "andThenFloat"(arg0: $Float2FloatFunction$Type): $Object2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2FloatFunction
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2FloatFunction
 "andThenInt"(arg0: $Float2IntFunction$Type): $Object2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$Type): $Object2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2FloatFunction<(T)>
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2FloatFunction<(T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Float2ByteFunction$Type): $Object2ByteFunction<(K)>
 "defaultReturnValue"(): float
 "defaultReturnValue"(arg0: float): void
 "andThenShort"(arg0: $Float2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2FloatFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): float
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (float)>

(arg0: any): float
}

export namespace $Object2FloatFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2FloatFunction$Type<K> = ($Object2FloatFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2FloatFunction_<K> = $Object2FloatFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ObjectSpliterator" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Spliterator, $Spliterator$Type} from "packages/java/util/$Spliterator"

export interface $ObjectSpliterator<K> extends $Spliterator<(K)> {

 "skip"(arg0: long): long
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "characteristics"(): integer
 "tryAdvance"(arg0: $Consumer$Type<(any)>): boolean
 "estimateSize"(): long
 "getExactSizeIfKnown"(): long
 "hasCharacteristics"(arg0: integer): boolean
 "getComparator"(): $Comparator<(any)>
}

export namespace $ObjectSpliterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectSpliterator$Type<K> = ($ObjectSpliterator<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectSpliterator_<K> = $ObjectSpliterator$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$Type} from "packages/java/util/function/$IntToDoubleFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Byte2FloatFunction extends $Function$0<(byte), (float)>, $IntToDoubleFunction {

 "remove"(arg0: byte): float
 "get"(arg0: byte): float
 "put"(arg0: byte, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: byte, arg1: float): float
 "containsKey"(arg0: byte): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: byte, arg1: float): float
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(byte), (T)>
 "andThenDouble"(arg0: $Float2DoubleFunction$Type): $Byte2DoubleFunction
 "composeChar"(arg0: $Char2ByteFunction$Type): $Char2FloatFunction
 "composeShort"(arg0: $Short2ByteFunction$Type): $Short2FloatFunction
 "andThenFloat"(arg0: $Float2FloatFunction$Type): $Byte2FloatFunction
 "composeFloat"(arg0: $Float2ByteFunction$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$Type): $Byte2LongFunction
 "composeLong"(arg0: $Long2ByteFunction$Type): $Long2FloatFunction
 "composeInt"(arg0: $Int2ByteFunction$Type): $Int2FloatFunction
 "andThenInt"(arg0: $Float2IntFunction$Type): $Byte2IntFunction
 "composeDouble"(arg0: $Double2ByteFunction$Type): $Double2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$Type): $Byte2CharFunction
 "composeObject"<T>(arg0: $Object2ByteFunction$Type<(any)>): $Object2FloatFunction<(T)>
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$Type<(any)>): $Byte2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ByteFunction$Type<(any)>): $Reference2FloatFunction<(T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$Type<(any)>): $Byte2ObjectFunction<(T)>
 "andThenByte"(arg0: $Float2ByteFunction$Type): $Byte2ByteFunction
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "andThenShort"(arg0: $Float2ShortFunction$Type): $Byte2ShortFunction
 "composeByte"(arg0: $Byte2ByteFunction$Type): $Byte2FloatFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: byte): float

(arg0: byte): float
}

export namespace $Byte2FloatFunction {
function identity<T>(): $Function<(byte), (byte)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Byte2FloatFunction$Type = ($Byte2FloatFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Byte2FloatFunction_ = $Byte2FloatFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoubleIterable" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleConsumer"
import {$DoubleSpliterator, $DoubleSpliterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleSpliterator"
import {$DoubleIterator, $DoubleIterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleIterator"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$Type as $DoubleConsumer$0$Type} from "packages/java/util/function/$DoubleConsumer"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export interface $DoubleIterable extends $Iterable<(double)> {

 "forEach"(arg0: $DoubleConsumer$0$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $DoubleConsumer$Type): void
 "doubleSpliterator"(): $DoubleSpliterator
 "doubleIterator"(): $DoubleIterator
}

export namespace $DoubleIterable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleIterable$Type = ($DoubleIterable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleIterable_ = $DoubleIterable$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$IntPredicate, $IntPredicate$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntPredicate"
import {$IntComparator, $IntComparator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntComparator"
import {$IntListIterator, $IntListIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntListIterator"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntUnaryOperator"
import {$IntUnaryOperator as $IntUnaryOperator$0, $IntUnaryOperator$Type as $IntUnaryOperator$0$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$IntCollection, $IntCollection$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntCollection"
import {$IntPredicate as $IntPredicate$0, $IntPredicate$Type as $IntPredicate$0$Type} from "packages/java/util/function/$IntPredicate"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$IntConsumer, $IntConsumer$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntConsumer"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$Type as $IntConsumer$0$Type} from "packages/java/util/function/$IntConsumer"

export interface $IntList extends $List<(integer)>, $Comparable<($List<(any)>)>, $IntCollection {

 "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: integer): void
 "add"(arg0: integer, arg1: integer): void
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: integer): integer
 "indexOf"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "indexOf"(arg0: any): integer
 "getInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "lastIndexOf"(arg0: any): integer
 "lastIndexOf"(arg0: integer): integer
 "replaceAll"(arg0: $IntUnaryOperator$Type): void
 "replaceAll"(arg0: $IntUnaryOperator$0$Type): void
/**
 * 
 * @deprecated
 */
 "replaceAll"(arg0: $UnaryOperator$Type<(integer)>): void
 "size"(arg0: integer): void
 "subList"(arg0: integer, arg1: integer): $IntList
 "iterator"(): $IntListIterator
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "addAll"(arg0: integer, arg1: $IntCollection$Type): boolean
 "addAll"(arg0: $IntList$Type): boolean
 "addAll"(arg0: integer, arg1: $IntList$Type): boolean
 "set"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: integer): integer
 "sort"(arg0: $IntComparator$Type): void
/**
 * 
 * @deprecated
 */
 "sort"(arg0: $Comparator$Type<(any)>): void
 "unstableSort"(arg0: $IntComparator$Type): void
/**
 * 
 * @deprecated
 */
 "unstableSort"(arg0: $Comparator$Type<(any)>): void
 "addElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
 "addElements"(arg0: integer, arg1: (integer)[]): void
 "removeElements"(arg0: integer, arg1: integer): void
 "getElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (integer)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (integer)[]): void
 "setElements"(arg0: (integer)[]): void
 "removeInt"(arg0: integer): integer
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "compareTo"(arg0: $List$Type<(any)>): integer
 "toArray"(arg0: (integer)[]): (integer)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(integer)>
 "intStream"(): $IntStream
 "contains"(arg0: integer): boolean
 "addAll"(arg0: $IntCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $IntPredicate$0$Type): boolean
 "removeIf"(arg0: $IntPredicate$Type): boolean
 "removeAll"(arg0: $IntCollection$Type): boolean
 "retainAll"(arg0: $IntCollection$Type): boolean
 "containsAll"(arg0: $IntCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(integer)>
 "rem"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "toIntArray"(arg0: (integer)[]): (integer)[]
 "toIntArray"(): (integer)[]
 "intParallelStream"(): $IntStream
 "intSpliterator"(): $IntSpliterator
 "intIterator"(): $IntIterator
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "forEach"(arg0: $IntConsumer$0$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $IntConsumer$Type): void
}

export namespace $IntList {
function of(...arg0: (integer)[]): $IntList
function of(): $IntList
function of(arg0: integer, arg1: integer): $IntList
function of(arg0: integer): $IntList
function of(arg0: integer, arg1: integer, arg2: integer): $IntList
function copyOf<E>(arg0: $Collection$Type<(any)>): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer): $List<(integer)>
function of<E>(arg0: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): $List<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer): $List<(integer)>
function of<E>(...arg0: (integer)[]): $List<(integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntList$Type = ($IntList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntList_ = $IntList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ReferenceSet" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ReferenceCollection, $ReferenceCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ReferenceCollection"

export interface $ReferenceSet<K> extends $ReferenceCollection<(K)>, $Set<(K)> {

 "add"(arg0: K): boolean
 "remove"(arg0: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(K)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $ReferenceSet {
function of<K>(arg0: K, arg1: K): $ReferenceSet<(K)>
function of<K>(...arg0: (K)[]): $ReferenceSet<(K)>
function of<K>(arg0: K, arg1: K, arg2: K): $ReferenceSet<(K)>
function of<K>(): $ReferenceSet<(K)>
function of<K>(arg0: K): $ReferenceSet<(K)>
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K, arg9: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K): $Set<(K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ReferenceSet$Type<K> = ($ReferenceSet<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ReferenceSet_<K> = $ReferenceSet$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$DoubleToIntFunction, $DoubleToIntFunction$Type} from "packages/java/util/function/$DoubleToIntFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Double2ShortFunction extends $Function$0<(double), (short)>, $DoubleToIntFunction {

 "remove"(arg0: double): short
 "get"(arg0: double): short
 "put"(arg0: double, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: double, arg1: short): short
 "containsKey"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: double, arg1: short): short
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(double), (T)>
 "andThenDouble"(arg0: $Short2DoubleFunction$Type): $Double2DoubleFunction
 "composeChar"(arg0: $Char2DoubleFunction$Type): $Char2ShortFunction
 "composeShort"(arg0: $Short2DoubleFunction$Type): $Short2ShortFunction
 "andThenFloat"(arg0: $Short2FloatFunction$Type): $Double2FloatFunction
 "composeFloat"(arg0: $Float2DoubleFunction$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$Type): $Double2LongFunction
 "composeLong"(arg0: $Long2DoubleFunction$Type): $Long2ShortFunction
 "composeInt"(arg0: $Int2DoubleFunction$Type): $Int2ShortFunction
 "andThenInt"(arg0: $Short2IntFunction$Type): $Double2IntFunction
 "composeDouble"(arg0: $Double2DoubleFunction$Type): $Double2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$Type): $Double2CharFunction
 "composeObject"<T>(arg0: $Object2DoubleFunction$Type<(any)>): $Object2ShortFunction<(T)>
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$Type<(any)>): $Double2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2DoubleFunction$Type<(any)>): $Reference2ShortFunction<(T)>
 "andThenObject"<T>(arg0: $Short2ObjectFunction$Type<(any)>): $Double2ObjectFunction<(T)>
 "andThenByte"(arg0: $Short2ByteFunction$Type): $Double2ByteFunction
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "andThenShort"(arg0: $Short2ShortFunction$Type): $Double2ShortFunction
 "composeByte"(arg0: $Byte2DoubleFunction$Type): $Byte2ShortFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: double): short

(arg0: double): short
}

export namespace $Double2ShortFunction {
function identity<T>(): $Function<(double), (double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Double2ShortFunction$Type = ($Double2ShortFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Double2ShortFunction_ = $Double2ShortFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction" {
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$ToIntFunction, $ToIntFunction$Type} from "packages/java/util/function/$ToIntFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Object2ByteFunction<K> extends $Function$0<(K), (byte)>, $ToIntFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): byte
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): byte
 "put"(arg0: K, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: byte): byte
 "getByte"(arg0: any): byte
 "getOrDefault"(arg0: any, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "applyAsInt"(arg0: K): integer
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeByte"(arg0: any): byte
 "andThenDouble"(arg0: $Byte2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2ByteFunction
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2ByteFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$Type): $Object2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2ByteFunction
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2ByteFunction
 "andThenInt"(arg0: $Byte2IntFunction$Type): $Object2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$Type): $Object2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ByteFunction<(T)>
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2ByteFunction<(T)>
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Byte2ByteFunction$Type): $Object2ByteFunction<(K)>
 "defaultReturnValue"(): byte
 "defaultReturnValue"(arg0: byte): void
 "andThenShort"(arg0: $Byte2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2ByteFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): byte
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (byte)>

(arg0: any): byte
}

export namespace $Object2ByteFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ByteFunction$Type<K> = ($Object2ByteFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ByteFunction_<K> = $Object2ByteFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoublePredicate" {
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$DoublePredicate as $DoublePredicate$0, $DoublePredicate$Type as $DoublePredicate$0$Type} from "packages/java/util/function/$DoublePredicate"

export interface $DoublePredicate extends $Predicate<(double)>, $DoublePredicate$0 {

/**
 * 
 * @deprecated
 */
 "test"(arg0: double): boolean
 "or"(arg0: $DoublePredicate$0$Type): $DoublePredicate
/**
 * 
 * @deprecated
 */
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(double)>
 "or"(arg0: $DoublePredicate$Type): $DoublePredicate
 "and"(arg0: $DoublePredicate$0$Type): $DoublePredicate
 "and"(arg0: $DoublePredicate$Type): $DoublePredicate
/**
 * 
 * @deprecated
 */
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(double)>
 "test"(arg0: double): boolean

(arg0: double): boolean
}

export namespace $DoublePredicate {
function isEqual<T>(arg0: any): $Predicate<(double)>
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoublePredicate$Type = ($DoublePredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoublePredicate_ = $DoublePredicate$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2FloatMap$FastEntrySet" {
import {$Object2FloatMap$Entry, $Object2FloatMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatMap$Entry"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ObjectIterator, $ObjectIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectIterator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"

export interface $Object2FloatMap$FastEntrySet<K> extends $ObjectSet<($Object2FloatMap$Entry<(K)>)> {

 "fastForEach"(arg0: $Consumer$Type<(any)>): void
 "fastIterator"(): $ObjectIterator<($Object2FloatMap$Entry<(K)>)>
 "add"(arg0: $Object2FloatMap$Entry$Type<(K)>): boolean
 "remove"(arg0: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<($Object2FloatMap$Entry<(K)>)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<($Object2FloatMap$Entry<(K)>)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $Object2FloatMap$FastEntrySet {
function of<K>(arg0: $Object2FloatMap$Entry$Type<(K)>, arg1: $Object2FloatMap$Entry$Type<(K)>): $ObjectSet<($Object2FloatMap$Entry<(K)>)>
function of<K>(...arg0: ($Object2FloatMap$Entry$Type<(K)>)[]): $ObjectSet<($Object2FloatMap$Entry<(K)>)>
function of<K>(arg0: $Object2FloatMap$Entry$Type<(K)>, arg1: $Object2FloatMap$Entry$Type<(K)>, arg2: $Object2FloatMap$Entry$Type<(K)>): $ObjectSet<($Object2FloatMap$Entry<(K)>)>
function of<K>(): $ObjectSet<($Object2FloatMap$Entry<(K)>)>
function of<K>(arg0: $Object2FloatMap$Entry$Type<(K)>): $ObjectSet<($Object2FloatMap$Entry<(K)>)>
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<($Object2FloatMap$Entry<(K)>)>
function of<E>(arg0: $Object2FloatMap$Entry$Type<(K)>, arg1: $Object2FloatMap$Entry$Type<(K)>, arg2: $Object2FloatMap$Entry$Type<(K)>, arg3: $Object2FloatMap$Entry$Type<(K)>, arg4: $Object2FloatMap$Entry$Type<(K)>, arg5: $Object2FloatMap$Entry$Type<(K)>): $Set<($Object2FloatMap$Entry<(K)>)>
function of<E>(arg0: $Object2FloatMap$Entry$Type<(K)>, arg1: $Object2FloatMap$Entry$Type<(K)>, arg2: $Object2FloatMap$Entry$Type<(K)>, arg3: $Object2FloatMap$Entry$Type<(K)>, arg4: $Object2FloatMap$Entry$Type<(K)>): $Set<($Object2FloatMap$Entry<(K)>)>
function of<E>(arg0: $Object2FloatMap$Entry$Type<(K)>, arg1: $Object2FloatMap$Entry$Type<(K)>, arg2: $Object2FloatMap$Entry$Type<(K)>, arg3: $Object2FloatMap$Entry$Type<(K)>): $Set<($Object2FloatMap$Entry<(K)>)>
function of<E>(arg0: $Object2FloatMap$Entry$Type<(K)>, arg1: $Object2FloatMap$Entry$Type<(K)>, arg2: $Object2FloatMap$Entry$Type<(K)>, arg3: $Object2FloatMap$Entry$Type<(K)>, arg4: $Object2FloatMap$Entry$Type<(K)>, arg5: $Object2FloatMap$Entry$Type<(K)>, arg6: $Object2FloatMap$Entry$Type<(K)>, arg7: $Object2FloatMap$Entry$Type<(K)>, arg8: $Object2FloatMap$Entry$Type<(K)>, arg9: $Object2FloatMap$Entry$Type<(K)>): $Set<($Object2FloatMap$Entry<(K)>)>
function of<E>(arg0: $Object2FloatMap$Entry$Type<(K)>, arg1: $Object2FloatMap$Entry$Type<(K)>, arg2: $Object2FloatMap$Entry$Type<(K)>, arg3: $Object2FloatMap$Entry$Type<(K)>, arg4: $Object2FloatMap$Entry$Type<(K)>, arg5: $Object2FloatMap$Entry$Type<(K)>, arg6: $Object2FloatMap$Entry$Type<(K)>, arg7: $Object2FloatMap$Entry$Type<(K)>, arg8: $Object2FloatMap$Entry$Type<(K)>): $Set<($Object2FloatMap$Entry<(K)>)>
function of<E>(arg0: $Object2FloatMap$Entry$Type<(K)>, arg1: $Object2FloatMap$Entry$Type<(K)>, arg2: $Object2FloatMap$Entry$Type<(K)>, arg3: $Object2FloatMap$Entry$Type<(K)>, arg4: $Object2FloatMap$Entry$Type<(K)>, arg5: $Object2FloatMap$Entry$Type<(K)>, arg6: $Object2FloatMap$Entry$Type<(K)>, arg7: $Object2FloatMap$Entry$Type<(K)>): $Set<($Object2FloatMap$Entry<(K)>)>
function of<E>(arg0: $Object2FloatMap$Entry$Type<(K)>, arg1: $Object2FloatMap$Entry$Type<(K)>, arg2: $Object2FloatMap$Entry$Type<(K)>, arg3: $Object2FloatMap$Entry$Type<(K)>, arg4: $Object2FloatMap$Entry$Type<(K)>, arg5: $Object2FloatMap$Entry$Type<(K)>, arg6: $Object2FloatMap$Entry$Type<(K)>): $Set<($Object2FloatMap$Entry<(K)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2FloatMap$FastEntrySet$Type<K> = ($Object2FloatMap$FastEntrySet<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2FloatMap$FastEntrySet_<K> = $Object2FloatMap$FastEntrySet$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongList" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$LongStream, $LongStream$Type} from "packages/java/util/stream/$LongStream"
import {$LongSpliterator, $LongSpliterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongSpliterator"
import {$LongConsumer, $LongConsumer$Type} from "packages/java/util/function/$LongConsumer"
import {$LongComparator, $LongComparator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongComparator"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$LongUnaryOperator, $LongUnaryOperator$Type} from "packages/java/util/function/$LongUnaryOperator"
import {$LongIterator, $LongIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongIterator"
import {$LongPredicate, $LongPredicate$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongPredicate"
import {$LongUnaryOperator as $LongUnaryOperator$0, $LongUnaryOperator$Type as $LongUnaryOperator$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongUnaryOperator"
import {$LongListIterator, $LongListIterator$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongListIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$LongPredicate as $LongPredicate$0, $LongPredicate$Type as $LongPredicate$0$Type} from "packages/java/util/function/$LongPredicate"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$LongConsumer as $LongConsumer$0, $LongConsumer$Type as $LongConsumer$0$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongConsumer"
import {$LongCollection, $LongCollection$Type} from "packages/it/unimi/dsi/fastutil/longs/$LongCollection"

export interface $LongList extends $List<(long)>, $Comparable<($List<(any)>)>, $LongCollection {

 "add"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: long): void
 "add"(arg0: integer, arg1: long): void
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: integer): long
 "indexOf"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "indexOf"(arg0: any): integer
 "getLong"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "lastIndexOf"(arg0: any): integer
 "lastIndexOf"(arg0: long): integer
 "replaceAll"(arg0: $LongUnaryOperator$0$Type): void
 "replaceAll"(arg0: $LongUnaryOperator$Type): void
/**
 * 
 * @deprecated
 */
 "replaceAll"(arg0: $UnaryOperator$Type<(long)>): void
 "size"(arg0: integer): void
 "subList"(arg0: integer, arg1: integer): $LongList
 "iterator"(): $LongListIterator
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "addAll"(arg0: integer, arg1: $LongCollection$Type): boolean
 "addAll"(arg0: $LongList$Type): boolean
 "addAll"(arg0: integer, arg1: $LongList$Type): boolean
 "set"(arg0: integer, arg1: long): long
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: long): long
 "sort"(arg0: $LongComparator$Type): void
/**
 * 
 * @deprecated
 */
 "sort"(arg0: $Comparator$Type<(any)>): void
 "unstableSort"(arg0: $LongComparator$Type): void
/**
 * 
 * @deprecated
 */
 "unstableSort"(arg0: $Comparator$Type<(any)>): void
 "addElements"(arg0: integer, arg1: (long)[], arg2: integer, arg3: integer): void
 "addElements"(arg0: integer, arg1: (long)[]): void
 "removeElements"(arg0: integer, arg1: integer): void
 "getElements"(arg0: integer, arg1: (long)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (long)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (long)[]): void
 "setElements"(arg0: (long)[]): void
 "removeLong"(arg0: integer): long
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "compareTo"(arg0: $List$Type<(any)>): integer
 "toArray"(arg0: (long)[]): (long)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(long)>
 "contains"(arg0: long): boolean
 "addAll"(arg0: $LongCollection$Type): boolean
 "removeIf"(arg0: $LongPredicate$0$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $LongPredicate$Type): boolean
 "removeAll"(arg0: $LongCollection$Type): boolean
 "retainAll"(arg0: $LongCollection$Type): boolean
 "containsAll"(arg0: $LongCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(long)>
 "rem"(arg0: long): boolean
 "longStream"(): $LongStream
 "toLongArray"(): (long)[]
/**
 * 
 * @deprecated
 */
 "toLongArray"(arg0: (long)[]): (long)[]
 "longIterator"(): $LongIterator
 "longParallelStream"(): $LongStream
 "longSpliterator"(): $LongSpliterator
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "forEach"(arg0: $LongConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $LongConsumer$0$Type): void
}

export namespace $LongList {
function of(...arg0: (long)[]): $LongList
function of(): $LongList
function of(arg0: long, arg1: long): $LongList
function of(arg0: long): $LongList
function of(arg0: long, arg1: long, arg2: long): $LongList
function copyOf<E>(arg0: $Collection$Type<(any)>): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long): $List<(long)>
function of<E>(arg0: long, arg1: long): $List<(long)>
function of<E>(arg0: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long, arg9: long): $List<(long)>
function of<E>(arg0: long, arg1: long, arg2: long, arg3: long, arg4: long, arg5: long, arg6: long, arg7: long, arg8: long): $List<(long)>
function of<E>(...arg0: (long)[]): $List<(long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongList$Type = ($LongList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongList_ = $LongList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoubleBidirectionalIterator" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleConsumer"
import {$DoubleIterator, $DoubleIterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleIterator"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$Type as $DoubleConsumer$0$Type} from "packages/java/util/function/$DoubleConsumer"
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterator"

export interface $DoubleBidirectionalIterator extends $DoubleIterator, $ObjectBidirectionalIterator<(double)> {

 "skip"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "previous"(): double
 "back"(arg0: integer): integer
 "previousDouble"(): double
 "nextDouble"(): double
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $DoubleConsumer$Type): void
/**
 * 
 * @deprecated
 */
 "next"(): double
 "forEachRemaining"(arg0: $DoubleConsumer$0$Type): void
 "hasPrevious"(): boolean
 "remove"(): void
 "hasNext"(): boolean
}

export namespace $DoubleBidirectionalIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleBidirectionalIterator$Type = ($DoubleBidirectionalIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleBidirectionalIterator_ = $DoubleBidirectionalIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Char2ObjectFunction<V> extends $Function$0<(character), (V)>, $IntFunction<(V)> {

 "remove"(arg0: character): V
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): V
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): V
 "get"(arg0: character): V
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: V): V
 "put"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): V
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: V): V
 "getOrDefault"(arg0: character, arg1: V): V
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (V)>
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Char2DoubleFunction
 "composeChar"(arg0: $Char2CharFunction$Type): $Char2ObjectFunction<(V)>
 "composeShort"(arg0: $Short2CharFunction$Type): $Short2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Char2FloatFunction
 "composeFloat"(arg0: $Float2CharFunction$Type): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Char2LongFunction
 "composeLong"(arg0: $Long2CharFunction$Type): $Long2ObjectFunction<(V)>
 "composeInt"(arg0: $Int2CharFunction$Type): $Int2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Char2IntFunction
 "composeDouble"(arg0: $Double2CharFunction$Type): $Double2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Char2CharFunction
 "composeObject"<T>(arg0: $Object2CharFunction$Type<(any)>): $Object2ObjectFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Char2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2CharFunction$Type<(any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Char2ObjectFunction<(T)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Char2ByteFunction
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Char2ShortFunction
 "composeByte"(arg0: $Byte2CharFunction$Type): $Byte2ObjectFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: character): V
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(character), (V)>

(arg0: character): V
}

export namespace $Char2ObjectFunction {
function identity<T>(): $Function<(character), (character)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2ObjectFunction$Type<V> = ($Char2ObjectFunction<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2ObjectFunction_<V> = $Char2ObjectFunction$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$IntToLongFunction, $IntToLongFunction$Type} from "packages/java/util/function/$IntToLongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Short2LongFunction extends $Function$0<(short), (long)>, $IntToLongFunction {

 "remove"(arg0: short): long
 "get"(arg0: short): long
 "put"(arg0: short, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: short, arg1: long): long
 "containsKey"(arg0: short): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "getOrDefault"(arg0: short, arg1: long): long
/**
 * 
 * @deprecated
 */
 "applyAsLong"(arg0: integer): long
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (long)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(short), (T)>
 "andThenDouble"(arg0: $Long2DoubleFunction$Type): $Short2DoubleFunction
 "composeChar"(arg0: $Char2ShortFunction$Type): $Char2LongFunction
 "composeShort"(arg0: $Short2ShortFunction$Type): $Short2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$Type): $Short2FloatFunction
 "composeFloat"(arg0: $Float2ShortFunction$Type): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$Type): $Short2LongFunction
 "composeLong"(arg0: $Long2ShortFunction$Type): $Long2LongFunction
 "composeInt"(arg0: $Int2ShortFunction$Type): $Int2LongFunction
 "andThenInt"(arg0: $Long2IntFunction$Type): $Short2IntFunction
 "composeDouble"(arg0: $Double2ShortFunction$Type): $Double2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$Type): $Short2CharFunction
 "composeObject"<T>(arg0: $Object2ShortFunction$Type<(any)>): $Object2LongFunction<(T)>
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$Type<(any)>): $Short2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2ShortFunction$Type<(any)>): $Reference2LongFunction<(T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$Type<(any)>): $Short2ObjectFunction<(T)>
 "andThenByte"(arg0: $Long2ByteFunction$Type): $Short2ByteFunction
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenShort"(arg0: $Long2ShortFunction$Type): $Short2ShortFunction
 "composeByte"(arg0: $Byte2ShortFunction$Type): $Byte2LongFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: short): long

(arg0: short): long
}

export namespace $Short2LongFunction {
function identity<T>(): $Function<(short), (short)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Short2LongFunction$Type = ($Short2LongFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Short2LongFunction_ = $Short2LongFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Object2ReferenceFunction<K, V> extends $Function$0<(K), (V)> {

 "remove"(arg0: any): V
 "get"(arg0: any): V
 "put"(arg0: K, arg1: V): V
 "getOrDefault"(arg0: any, arg1: V): V
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Object2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2ReferenceFunction<(V)>
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Object2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2ReferenceFunction<(V)>
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Object2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Object2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Object2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Object2ByteFunction<(K)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Object2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2ReferenceFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): V
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (V)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(K), (V)>

(arg0: any): V
}

export namespace $Object2ReferenceFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ReferenceFunction$Type<K, V> = ($Object2ReferenceFunction<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ReferenceFunction_<K, V> = $Object2ReferenceFunction$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$DoubleUnaryOperator, $DoubleUnaryOperator$Type} from "packages/java/util/function/$DoubleUnaryOperator"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"

export interface $Float2DoubleFunction extends $Function$0<(float), (double)>, $DoubleUnaryOperator {

 "remove"(arg0: float): double
 "get"(arg0: float): double
 "put"(arg0: float, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: double): double
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "getOrDefault"(arg0: float, arg1: double): double
/**
 * 
 * @deprecated
 */
 "applyAsDouble"(arg0: double): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (double)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(float), (T)>
 "andThenDouble"(arg0: $Double2DoubleFunction$Type): $Float2DoubleFunction
 "composeChar"(arg0: $Char2FloatFunction$Type): $Char2DoubleFunction
 "composeShort"(arg0: $Short2FloatFunction$Type): $Short2DoubleFunction
 "andThenFloat"(arg0: $Double2FloatFunction$Type): $Float2FloatFunction
 "composeFloat"(arg0: $Float2FloatFunction$Type): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$Type): $Float2LongFunction
 "composeLong"(arg0: $Long2FloatFunction$Type): $Long2DoubleFunction
 "composeInt"(arg0: $Int2FloatFunction$Type): $Int2DoubleFunction
 "andThenInt"(arg0: $Double2IntFunction$Type): $Float2IntFunction
 "composeDouble"(arg0: $Double2FloatFunction$Type): $Double2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$Type): $Float2CharFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$Type<(any)>): $Object2DoubleFunction<(T)>
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$Type<(any)>): $Float2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2FloatFunction$Type<(any)>): $Reference2DoubleFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$Type<(any)>): $Float2ObjectFunction<(T)>
 "andThenByte"(arg0: $Double2ByteFunction$Type): $Float2ByteFunction
 "defaultReturnValue"(arg0: double): void
 "defaultReturnValue"(): double
 "andThenShort"(arg0: $Double2ShortFunction$Type): $Float2ShortFunction
 "composeByte"(arg0: $Byte2FloatFunction$Type): $Byte2DoubleFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: float): double
 "compose"(arg0: $DoubleUnaryOperator$Type): $DoubleUnaryOperator
 "andThen"(arg0: $DoubleUnaryOperator$Type): $DoubleUnaryOperator

(arg0: float): double
}

export namespace $Float2DoubleFunction {
function identity(): $DoubleUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2DoubleFunction$Type = ($Float2DoubleFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2DoubleFunction_ = $Float2DoubleFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$DoubleToIntFunction, $DoubleToIntFunction$Type} from "packages/java/util/function/$DoubleToIntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"

export interface $Float2IntFunction extends $Function$0<(float), (integer)>, $DoubleToIntFunction {

 "remove"(arg0: float): integer
 "get"(arg0: float): integer
 "put"(arg0: float, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: integer): integer
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "getOrDefault"(arg0: float, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(float), (T)>
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Float2DoubleFunction
 "composeChar"(arg0: $Char2FloatFunction$Type): $Char2IntFunction
 "composeShort"(arg0: $Short2FloatFunction$Type): $Short2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Float2FloatFunction
 "composeFloat"(arg0: $Float2FloatFunction$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$Type): $Float2LongFunction
 "composeLong"(arg0: $Long2FloatFunction$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2FloatFunction$Type): $Int2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Float2IntFunction
 "composeDouble"(arg0: $Double2FloatFunction$Type): $Double2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$Type): $Float2CharFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$Type<(any)>): $Object2IntFunction<(T)>
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Float2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2FloatFunction$Type<(any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Float2ObjectFunction<(T)>
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Float2ByteFunction
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Float2ShortFunction
 "composeByte"(arg0: $Byte2FloatFunction$Type): $Byte2IntFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: float): integer

(arg0: float): integer
}

export namespace $Float2IntFunction {
function identity<T>(): $Function<(float), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2IntFunction$Type = ($Float2IntFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2IntFunction_ = $Float2IntFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Double2DoubleFunction, $Double2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2DoubleFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$ToDoubleFunction, $ToDoubleFunction$Type} from "packages/java/util/function/$ToDoubleFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Reference2DoubleFunction<K> extends $Function$0<(K), (double)>, $ToDoubleFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): double
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): double
 "put"(arg0: K, arg1: double): double
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: double): double
 "getDouble"(arg0: any): double
 "getOrDefault"(arg0: any, arg1: double): double
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: double): double
 "applyAsDouble"(arg0: K): double
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "removeDouble"(arg0: any): double
 "andThenDouble"(arg0: $Double2DoubleFunction$Type): $Reference2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2DoubleFunction
 "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2DoubleFunction
 "andThenFloat"(arg0: $Double2FloatFunction$Type): $Reference2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2DoubleFunction
 "andThenLong"(arg0: $Double2LongFunction$Type): $Reference2LongFunction<(K)>
 "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2DoubleFunction
 "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2DoubleFunction
 "andThenInt"(arg0: $Double2IntFunction$Type): $Reference2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2DoubleFunction
 "andThenChar"(arg0: $Double2CharFunction$Type): $Reference2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2DoubleFunction<(T)>
 "andThenReference"<T>(arg0: $Double2ReferenceFunction$Type<(any)>): $Reference2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2DoubleFunction<(T)>
 "andThenObject"<T>(arg0: $Double2ObjectFunction$Type<(any)>): $Reference2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Double2ByteFunction$Type): $Reference2ByteFunction<(K)>
 "defaultReturnValue"(): double
 "defaultReturnValue"(arg0: double): void
 "andThenShort"(arg0: $Double2ShortFunction$Type): $Reference2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2DoubleFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): double
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (double)>

(arg0: any): double
}

export namespace $Reference2DoubleFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2DoubleFunction$Type<K> = ($Reference2DoubleFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2DoubleFunction_<K> = $Reference2DoubleFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectSortedMap" {
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$ObjectSortedSet, $ObjectSortedSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSortedSet"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Object2ObjectMap$Entry, $Object2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap$Entry"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectMap, $Object2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$SortedMap, $SortedMap$Type} from "packages/java/util/$SortedMap"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Object2ObjectSortedMap<K, V> extends $Object2ObjectMap<(K), (V)>, $SortedMap<(K), (V)> {

 "comparator"(): $Comparator<(any)>
 "object2ObjectEntrySet"(): $ObjectSortedSet<($Object2ObjectMap$Entry<(K), (V)>)>
 "remove"(arg0: any): V
 "remove"(arg0: any, arg1: any): boolean
 "put"(arg0: K, arg1: V): V
 "clear"(): void
 "replace"(arg0: K, arg1: V, arg2: V): boolean
 "replace"(arg0: K, arg1: V): V
 "size"(): integer
 "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
 "putIfAbsent"(arg0: K, arg1: V): V
 "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
 "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
 "containsKey"(arg0: any): boolean
 "computeIfAbsent"(arg0: K, arg1: $Object2ObjectFunction$Type<(any), (any)>): V
 "getOrDefault"(arg0: any, arg1: V): V
 "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
/**
 * 
 * @deprecated
 */
 "computeObjectIfAbsentPartial"(arg0: K, arg1: $Object2ObjectFunction$Type<(any), (any)>): V
 "defaultReturnValue"(arg0: V): void
 "defaultReturnValue"(): V
 "firstKey"(): K
 "lastKey"(): K
 "get"(arg0: any): V
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Object2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2ObjectFunction<(V)>
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Object2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2ObjectFunction<(V)>
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Object2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Object2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ObjectFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Object2ByteFunction<(K)>
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Object2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2ObjectFunction<(V)>
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "isEmpty"(): boolean
 "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
 "putAll"(arg0: $Map$Type<(any), (any)>): void
 "computeIfAbsent"(arg0: K, arg1: $Function$Type<(any), (any)>): V
 "containsValue"(arg0: any): boolean
 "apply"(arg0: K): V
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (V)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(K), (V)>
}

export namespace $Object2ObjectSortedMap {
function copyOf<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
function of<K, V>(): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
function of<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
function entry<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
function ofEntries<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ObjectSortedMap$Type<K, V> = ($Object2ObjectSortedMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ObjectSortedMap_<K, V> = $Object2ObjectSortedMap$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"
import {$DoublePredicate, $DoublePredicate$Type} from "packages/java/util/function/$DoublePredicate"

export interface $Float2BooleanFunction extends $Function$0<(float), (boolean)>, $DoublePredicate {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
 "remove"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
 "get"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: boolean): boolean
 "put"(arg0: float, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "test"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "containsKey"(arg0: float): boolean
 "getOrDefault"(arg0: float, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (boolean)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(float), (T)>
 "andThenDouble"(arg0: $Boolean2DoubleFunction$Type): $Float2DoubleFunction
 "composeChar"(arg0: $Char2FloatFunction$Type): $Char2BooleanFunction
 "composeShort"(arg0: $Short2FloatFunction$Type): $Short2BooleanFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$Type): $Float2FloatFunction
 "composeFloat"(arg0: $Float2FloatFunction$Type): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$Type): $Float2LongFunction
 "composeLong"(arg0: $Long2FloatFunction$Type): $Long2BooleanFunction
 "composeInt"(arg0: $Int2FloatFunction$Type): $Int2BooleanFunction
 "andThenInt"(arg0: $Boolean2IntFunction$Type): $Float2IntFunction
 "composeDouble"(arg0: $Double2FloatFunction$Type): $Double2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$Type): $Float2CharFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$Type<(any)>): $Object2BooleanFunction<(T)>
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$Type<(any)>): $Float2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2FloatFunction$Type<(any)>): $Reference2BooleanFunction<(T)>
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$Type<(any)>): $Float2ObjectFunction<(T)>
 "andThenByte"(arg0: $Boolean2ByteFunction$Type): $Float2ByteFunction
 "defaultReturnValue"(arg0: boolean): void
 "defaultReturnValue"(): boolean
 "andThenShort"(arg0: $Boolean2ShortFunction$Type): $Float2ShortFunction
 "composeByte"(arg0: $Byte2FloatFunction$Type): $Byte2BooleanFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: float): boolean
 "or"(arg0: $DoublePredicate$Type): $DoublePredicate
 "and"(arg0: $DoublePredicate$Type): $DoublePredicate
 "negate"(): $DoublePredicate

(arg0: any): boolean
}

export namespace $Float2BooleanFunction {
function identity<T>(): $Function<(float), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2BooleanFunction$Type = ($Float2BooleanFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2BooleanFunction_ = $Float2BooleanFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction" {
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$DoubleToIntFunction, $DoubleToIntFunction$Type} from "packages/java/util/function/$DoubleToIntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Double2ByteFunction, $Double2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ByteFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Byte2DoubleFunction, $Byte2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2DoubleFunction"
import {$Byte2ByteFunction, $Byte2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ByteFunction"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Float2ByteFunction extends $Function$0<(float), (byte)>, $DoubleToIntFunction {

 "remove"(arg0: float): byte
 "get"(arg0: float): byte
 "put"(arg0: float, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "put"(arg0: float, arg1: byte): byte
 "containsKey"(arg0: float): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: byte): byte
 "getOrDefault"(arg0: float, arg1: byte): byte
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (byte)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(float), (T)>
 "andThenDouble"(arg0: $Byte2DoubleFunction$Type): $Float2DoubleFunction
 "composeChar"(arg0: $Char2FloatFunction$Type): $Char2ByteFunction
 "composeShort"(arg0: $Short2FloatFunction$Type): $Short2ByteFunction
 "andThenFloat"(arg0: $Byte2FloatFunction$Type): $Float2FloatFunction
 "composeFloat"(arg0: $Float2FloatFunction$Type): $Float2ByteFunction
 "andThenLong"(arg0: $Byte2LongFunction$Type): $Float2LongFunction
 "composeLong"(arg0: $Long2FloatFunction$Type): $Long2ByteFunction
 "composeInt"(arg0: $Int2FloatFunction$Type): $Int2ByteFunction
 "andThenInt"(arg0: $Byte2IntFunction$Type): $Float2IntFunction
 "composeDouble"(arg0: $Double2FloatFunction$Type): $Double2ByteFunction
 "andThenChar"(arg0: $Byte2CharFunction$Type): $Float2CharFunction
 "composeObject"<T>(arg0: $Object2FloatFunction$Type<(any)>): $Object2ByteFunction<(T)>
 "andThenReference"<T>(arg0: $Byte2ReferenceFunction$Type<(any)>): $Float2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2FloatFunction$Type<(any)>): $Reference2ByteFunction<(T)>
 "andThenObject"<T>(arg0: $Byte2ObjectFunction$Type<(any)>): $Float2ObjectFunction<(T)>
 "andThenByte"(arg0: $Byte2ByteFunction$Type): $Float2ByteFunction
 "defaultReturnValue"(arg0: byte): void
 "defaultReturnValue"(): byte
 "andThenShort"(arg0: $Byte2ShortFunction$Type): $Float2ShortFunction
 "composeByte"(arg0: $Byte2FloatFunction$Type): $Byte2ByteFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: float): byte

(arg0: float): byte
}

export namespace $Float2ByteFunction {
function identity<T>(): $Function<(float), (float)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Float2ByteFunction$Type = ($Float2ByteFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Float2ByteFunction_ = $Float2ByteFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$AbstractLong2ObjectMap" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$AbstractLong2ObjectFunction, $AbstractLong2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$AbstractLong2ObjectFunction"
import {$LongFunction, $LongFunction$Type} from "packages/java/util/function/$LongFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$BiConsumer, $BiConsumer$Type} from "packages/java/util/function/$BiConsumer"
import {$Long2ObjectMap, $Long2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$ObjectCollection, $ObjectCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectCollection"
import {$Long2ObjectMap$Entry, $Long2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap$Entry"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $AbstractLong2ObjectMap<V> extends $AbstractLong2ObjectFunction<(V)> implements $Long2ObjectMap<(V)>, $Serializable {


public "equals"(arg0: any): boolean
public "toString"(): string
public "values"(): $ObjectCollection<(V)>
public "hashCode"(): integer
public "isEmpty"(): boolean
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "containsKey"(arg0: long): boolean
public "containsValue"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
public "remove"(arg0: any): V
public "remove"(arg0: long, arg1: any): boolean
/**
 * 
 * @deprecated
 */
public "get"(arg0: any): V
/**
 * 
 * @deprecated
 */
public "put"(arg0: long, arg1: V): V
public "clear"(): void
public "replace"(arg0: long, arg1: V, arg2: V): boolean
public "replace"(arg0: long, arg1: V): V
public "size"(): integer
public "merge"(arg0: long, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
/**
 * 
 * @deprecated
 */
public "entrySet"(): $ObjectSet<($Map$Entry<(long), (V)>)>
public "putIfAbsent"(arg0: long, arg1: V): V
public "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "forEach"(arg0: $BiConsumer$Type<(any), (any)>): void
/**
 * 
 * @deprecated
 */
public "containsKey"(arg0: any): boolean
public "computeIfAbsent"(arg0: long, arg1: $Long2ObjectFunction$Type<(any)>): V
public "computeIfAbsent"(arg0: long, arg1: $LongFunction$Type<(any)>): V
public "getOrDefault"(arg0: long, arg1: V): V
/**
 * 
 * @deprecated
 */
public "getOrDefault"(arg0: any, arg1: V): V
public "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "long2ObjectEntrySet"(): $ObjectSet<($Long2ObjectMap$Entry<(V)>)>
/**
 * 
 * @deprecated
 */
public "computeIfAbsentPartial"(arg0: long, arg1: $Long2ObjectFunction$Type<(any)>): V
public "defaultReturnValue"(): V
public "defaultReturnValue"(arg0: V): void
public "remove"(arg0: any, arg1: any): boolean
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(long), (V)>
public "replace"(arg0: long, arg1: V): V
public "replace"(arg0: long, arg1: V, arg2: V): boolean
public "replaceAll"(arg0: $BiFunction$Type<(any), (any), (any)>): void
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V): $Map<(long), (V)>
public static "of"<K, V>(): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V, arg18: long, arg19: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V, arg16: long, arg17: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V, arg14: long, arg15: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V, arg12: long, arg13: V): $Map<(long), (V)>
public static "of"<K, V>(arg0: long, arg1: V, arg2: long, arg3: V, arg4: long, arg5: V, arg6: long, arg7: V, arg8: long, arg9: V, arg10: long, arg11: V): $Map<(long), (V)>
public "merge"(arg0: long, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "putIfAbsent"(arg0: long, arg1: V): V
public "compute"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
public static "entry"<K, V>(arg0: long, arg1: V): $Map$Entry<(long), (V)>
public "computeIfAbsent"(arg0: long, arg1: $Function$Type<(any), (any)>): V
public "computeIfPresent"(arg0: long, arg1: $BiFunction$Type<(any), (any), (any)>): V
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(long), (V)>
public static "identity"<T>(): $Function<(long), (long)>
[index: string | number]: V
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractLong2ObjectMap$Type<V> = ($AbstractLong2ObjectMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractLong2ObjectMap_<V> = $AbstractLong2ObjectMap$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectOpenHashMap" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Hash, $Hash$Type} from "packages/it/unimi/dsi/fastutil/$Hash"
import {$Int2ObjectMap, $Int2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectMap"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$AbstractInt2ObjectMap, $AbstractInt2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/ints/$AbstractInt2ObjectMap"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$IntSet, $IntSet$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSet"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $Int2ObjectOpenHashMap<V> extends $AbstractInt2ObjectMap<(V)> implements $Serializable, $Cloneable, $Hash {

constructor(arg0: $Map$Type<(any), (any)>)
constructor(arg0: $Int2ObjectMap$Type<(V)>, arg1: float)
constructor(arg0: $Int2ObjectMap$Type<(V)>)
constructor(arg0: (integer)[], arg1: (V)[], arg2: float)
constructor(arg0: (integer)[], arg1: (V)[])
constructor(arg0: integer, arg1: float)
constructor(arg0: integer)
constructor()
constructor(arg0: $Map$Type<(any), (any)>, arg1: float)

public "remove"(arg0: integer, arg1: any): boolean
public "remove"(arg0: integer): V
public "get"(arg0: integer): V
public "put"(arg0: integer, arg1: V): V
public "hashCode"(): integer
public "clear"(): void
public "isEmpty"(): boolean
public "replace"(arg0: integer, arg1: V, arg2: V): boolean
public "replace"(arg0: integer, arg1: V): V
public "size"(): integer
public "trim"(): boolean
public "trim"(arg0: integer): boolean
public "merge"(arg0: integer, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "putIfAbsent"(arg0: integer, arg1: V): V
public "compute"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "containsKey"(arg0: integer): boolean
public "computeIfAbsent"(arg0: integer, arg1: $IntFunction$Type<(any)>): V
public "computeIfAbsent"(arg0: integer, arg1: $Int2ObjectFunction$Type<(any)>): V
public "keySet"(): $IntSet
public "containsValue"(arg0: any): boolean
public "getOrDefault"(arg0: integer, arg1: V): V
public "computeIfPresent"(arg0: integer, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2ObjectOpenHashMap$Type<V> = ($Int2ObjectOpenHashMap<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2ObjectOpenHashMap_<V> = $Int2ObjectOpenHashMap$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoubleList" {
import {$DoubleListIterator, $DoubleListIterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleListIterator"
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$DoubleComparator, $DoubleComparator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleComparator"
import {$DoublePredicate, $DoublePredicate$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoublePredicate"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleConsumer"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$DoubleSpliterator, $DoubleSpliterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleSpliterator"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$Type as $DoubleConsumer$0$Type} from "packages/java/util/function/$DoubleConsumer"
import {$DoubleUnaryOperator, $DoubleUnaryOperator$Type} from "packages/java/util/function/$DoubleUnaryOperator"
import {$DoubleCollection, $DoubleCollection$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleCollection"
import {$DoubleStream, $DoubleStream$Type} from "packages/java/util/stream/$DoubleStream"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$List, $List$Type} from "packages/java/util/$List"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$DoubleIterator, $DoubleIterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleIterator"
import {$DoubleUnaryOperator as $DoubleUnaryOperator$0, $DoubleUnaryOperator$Type as $DoubleUnaryOperator$0$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleUnaryOperator"
import {$DoublePredicate as $DoublePredicate$0, $DoublePredicate$Type as $DoublePredicate$0$Type} from "packages/java/util/function/$DoublePredicate"

export interface $DoubleList extends $List<(double)>, $Comparable<($List<(any)>)>, $DoubleCollection {

 "add"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: double): boolean
/**
 * 
 * @deprecated
 */
 "add"(arg0: integer, arg1: double): void
 "add"(arg0: integer, arg1: double): void
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: integer): double
 "indexOf"(arg0: double): integer
/**
 * 
 * @deprecated
 */
 "indexOf"(arg0: any): integer
 "getDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "lastIndexOf"(arg0: any): integer
 "lastIndexOf"(arg0: double): integer
 "replaceAll"(arg0: $DoubleUnaryOperator$0$Type): void
 "replaceAll"(arg0: $DoubleUnaryOperator$Type): void
/**
 * 
 * @deprecated
 */
 "replaceAll"(arg0: $UnaryOperator$Type<(double)>): void
 "size"(arg0: integer): void
 "subList"(arg0: integer, arg1: integer): $DoubleList
 "iterator"(): $DoubleListIterator
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "addAll"(arg0: integer, arg1: $DoubleCollection$Type): boolean
 "addAll"(arg0: $DoubleList$Type): boolean
 "addAll"(arg0: integer, arg1: $DoubleList$Type): boolean
 "set"(arg0: integer, arg1: double): double
/**
 * 
 * @deprecated
 */
 "set"(arg0: integer, arg1: double): double
 "sort"(arg0: $DoubleComparator$Type): void
/**
 * 
 * @deprecated
 */
 "sort"(arg0: $Comparator$Type<(any)>): void
 "unstableSort"(arg0: $DoubleComparator$Type): void
/**
 * 
 * @deprecated
 */
 "unstableSort"(arg0: $Comparator$Type<(any)>): void
 "addElements"(arg0: integer, arg1: (double)[], arg2: integer, arg3: integer): void
 "addElements"(arg0: integer, arg1: (double)[]): void
 "removeElements"(arg0: integer, arg1: integer): void
 "removeDouble"(arg0: integer): double
 "getElements"(arg0: integer, arg1: (double)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: integer, arg1: (double)[]): void
 "setElements"(arg0: integer, arg1: (double)[], arg2: integer, arg3: integer): void
 "setElements"(arg0: (double)[]): void
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"(): (any)[]
 "toArray"<T>(arg0: (T)[]): (T)[]
 "addAll"(arg0: integer, arg1: $Collection$Type<(any)>): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "compareTo"(arg0: $List$Type<(any)>): integer
 "toArray"(arg0: (double)[]): (double)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(double)>
 "contains"(arg0: double): boolean
 "addAll"(arg0: $DoubleCollection$Type): boolean
 "removeIf"(arg0: $DoublePredicate$0$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $DoublePredicate$Type): boolean
 "removeAll"(arg0: $DoubleCollection$Type): boolean
 "retainAll"(arg0: $DoubleCollection$Type): boolean
 "containsAll"(arg0: $DoubleCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(double)>
 "rem"(arg0: double): boolean
 "doubleStream"(): $DoubleStream
 "doubleSpliterator"(): $DoubleSpliterator
 "doubleIterator"(): $DoubleIterator
/**
 * 
 * @deprecated
 */
 "toDoubleArray"(arg0: (double)[]): (double)[]
 "toDoubleArray"(): (double)[]
 "doubleParallelStream"(): $DoubleStream
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "forEach"(arg0: $DoubleConsumer$0$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $DoubleConsumer$Type): void
}

export namespace $DoubleList {
function of(...arg0: (double)[]): $DoubleList
function of(): $DoubleList
function of(arg0: double, arg1: double): $DoubleList
function of(arg0: double): $DoubleList
function of(arg0: double, arg1: double, arg2: double): $DoubleList
function copyOf<E>(arg0: $Collection$Type<(any)>): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double): $List<(double)>
function of<E>(arg0: double, arg1: double): $List<(double)>
function of<E>(arg0: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double, arg9: double): $List<(double)>
function of<E>(arg0: double, arg1: double, arg2: double, arg3: double, arg4: double, arg5: double, arg6: double, arg7: double, arg8: double): $List<(double)>
function of<E>(...arg0: (double)[]): $List<(double)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleList$Type = ($DoubleList);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleList_ = $DoubleList$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectArrayMap" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$ObjectCollection, $ObjectCollection$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectCollection"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$Object2ObjectMap, $Object2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap"
import {$AbstractObject2ObjectMap, $AbstractObject2ObjectMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2ObjectMap"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $Object2ObjectArrayMap<K, V> extends $AbstractObject2ObjectMap<(K), (V)> implements $Serializable, $Cloneable {

constructor(arg0: (any)[], arg1: (any)[], arg2: integer)
constructor(arg0: $Map$Type<(any), (any)>)
constructor(arg0: $Object2ObjectMap$Type<(K), (V)>)
constructor(arg0: (any)[], arg1: (any)[])
constructor()
constructor(arg0: integer)

public "remove"(arg0: any): V
public "get"(arg0: any): V
public "put"(arg0: K, arg1: V): V
public "values"(): $ObjectCollection<(V)>
public "clone"(): $Object2ObjectArrayMap<(K), (V)>
public "clear"(): void
public "isEmpty"(): boolean
public "size"(): integer
public "containsKey"(arg0: any): boolean
public "containsValue"(arg0: any): boolean
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ObjectArrayMap$Type<K, V> = ($Object2ObjectArrayMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ObjectArrayMap_<K, V> = $Object2ObjectArrayMap$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Char2ShortFunction extends $Function$0<(character), (short)>, $IntUnaryOperator {

 "remove"(arg0: character): short
 "get"(arg0: character): short
 "put"(arg0: character, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: character, arg1: short): short
 "containsKey"(arg0: character): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: character, arg1: short): short
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(character), (T)>
 "andThenDouble"(arg0: $Short2DoubleFunction$Type): $Char2DoubleFunction
 "composeChar"(arg0: $Char2CharFunction$Type): $Char2ShortFunction
 "composeShort"(arg0: $Short2CharFunction$Type): $Short2ShortFunction
 "andThenFloat"(arg0: $Short2FloatFunction$Type): $Char2FloatFunction
 "composeFloat"(arg0: $Float2CharFunction$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$Type): $Char2LongFunction
 "composeLong"(arg0: $Long2CharFunction$Type): $Long2ShortFunction
 "composeInt"(arg0: $Int2CharFunction$Type): $Int2ShortFunction
 "andThenInt"(arg0: $Short2IntFunction$Type): $Char2IntFunction
 "composeDouble"(arg0: $Double2CharFunction$Type): $Double2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$Type): $Char2CharFunction
 "composeObject"<T>(arg0: $Object2CharFunction$Type<(any)>): $Object2ShortFunction<(T)>
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$Type<(any)>): $Char2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2CharFunction$Type<(any)>): $Reference2ShortFunction<(T)>
 "andThenObject"<T>(arg0: $Short2ObjectFunction$Type<(any)>): $Char2ObjectFunction<(T)>
 "andThenByte"(arg0: $Short2ByteFunction$Type): $Char2ByteFunction
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "andThenShort"(arg0: $Short2ShortFunction$Type): $Char2ShortFunction
 "composeByte"(arg0: $Byte2CharFunction$Type): $Byte2ShortFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: character): short
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: character): short
}

export namespace $Char2ShortFunction {
function identity(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Char2ShortFunction$Type = ($Char2ShortFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Char2ShortFunction_ = $Char2ShortFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction" {
import {$Function, $Function$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/java/util/function/$Function"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"

export interface $Object2ObjectFunction<K, V> extends $Function<(K), (V)> {

 "remove"(arg0: any): V
 "get"(arg0: any): V
 "put"(arg0: K, arg1: V): V
 "getOrDefault"(arg0: any, arg1: V): V
 "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Object2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2ObjectFunction<(V)>
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2ObjectFunction<(V)>
 "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Object2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2ObjectFunction<(V)>
 "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2ObjectFunction<(V)>
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2ObjectFunction<(V)>
 "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Object2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2ObjectFunction<(V)>
 "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Object2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ObjectFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2ObjectFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Object2ByteFunction<(K)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Object2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2ObjectFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): V
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(V), (V)>
 "andThen"<V>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(K), (V)>

(arg0: any): V
}

export namespace $Object2ObjectFunction {
function identity<T>(): $Function$0<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ObjectFunction$Type<K, V> = ($Object2ObjectFunction<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ObjectFunction_<K, V> = $Object2ObjectFunction$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Float2DoubleFunction, $Float2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Byte2FloatFunction, $Byte2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2FloatFunction"
import {$Float2ByteFunction, $Float2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ByteFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Float2FloatFunction, $Float2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2FloatFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Int2IntFunction, $Int2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction"
import {$IntToDoubleFunction, $IntToDoubleFunction$Type} from "packages/java/util/function/$IntToDoubleFunction"
import {$Double2FloatFunction, $Double2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2FloatFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"

export interface $Int2FloatFunction extends $Function$0<(integer), (float)>, $IntToDoubleFunction {

 "remove"(arg0: integer): float
 "get"(arg0: integer): float
 "put"(arg0: integer, arg1: float): float
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: float): float
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: float): float
 "getOrDefault"(arg0: integer, arg1: float): float
 "applyAsDouble"(arg0: integer): double
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (float)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (T)>
 "andThenDouble"(arg0: $Float2DoubleFunction$Type): $Int2DoubleFunction
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2FloatFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2FloatFunction
 "andThenFloat"(arg0: $Float2FloatFunction$Type): $Int2FloatFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2FloatFunction
 "andThenLong"(arg0: $Float2LongFunction$Type): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2FloatFunction
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2FloatFunction
 "andThenInt"(arg0: $Float2IntFunction$Type): $Int2IntFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2FloatFunction
 "andThenChar"(arg0: $Float2CharFunction$Type): $Int2CharFunction
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2FloatFunction<(T)>
 "andThenReference"<T>(arg0: $Float2ReferenceFunction$Type<(any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2FloatFunction<(T)>
 "andThenObject"<T>(arg0: $Float2ObjectFunction$Type<(any)>): $Int2ObjectFunction<(T)>
 "andThenByte"(arg0: $Float2ByteFunction$Type): $Int2ByteFunction
 "defaultReturnValue"(arg0: float): void
 "defaultReturnValue"(): float
 "andThenShort"(arg0: $Float2ShortFunction$Type): $Int2ShortFunction
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2FloatFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: integer): float

(arg0: integer): float
}

export namespace $Int2FloatFunction {
function identity<T>(): $Function<(integer), (integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2FloatFunction$Type = ($Int2FloatFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2FloatFunction_ = $Int2FloatFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntSet" {
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$IntStream, $IntStream$Type} from "packages/java/util/stream/$IntStream"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntPredicate, $IntPredicate$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntPredicate"
import {$IntCollection, $IntCollection$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntCollection"
import {$IntPredicate as $IntPredicate$0, $IntPredicate$Type as $IntPredicate$0$Type} from "packages/java/util/function/$IntPredicate"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$IntConsumer, $IntConsumer$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntConsumer"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$Type as $IntConsumer$0$Type} from "packages/java/util/function/$IntConsumer"

export interface $IntSet extends $IntCollection, $Set<(integer)> {

/**
 * 
 * @deprecated
 */
 "add"(arg0: integer): boolean
 "remove"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "contains"(arg0: any): boolean
 "spliterator"(): $IntSpliterator
/**
 * 
 * @deprecated
 */
 "rem"(arg0: integer): boolean
 "add"(arg0: integer): boolean
 "toArray"(arg0: (integer)[]): (integer)[]
/**
 * 
 * @deprecated
 */
 "stream"(): $Stream<(integer)>
 "intStream"(): $IntStream
 "contains"(arg0: integer): boolean
 "addAll"(arg0: $IntCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "removeIf"(arg0: $IntPredicate$0$Type): boolean
 "removeIf"(arg0: $IntPredicate$Type): boolean
 "removeAll"(arg0: $IntCollection$Type): boolean
 "retainAll"(arg0: $IntCollection$Type): boolean
 "containsAll"(arg0: $IntCollection$Type): boolean
/**
 * 
 * @deprecated
 */
 "parallelStream"(): $Stream<(integer)>
/**
 * 
 * @deprecated
 */
 "toIntArray"(arg0: (integer)[]): (integer)[]
 "toIntArray"(): (integer)[]
 "intParallelStream"(): $IntStream
 "intSpliterator"(): $IntSpliterator
 "intIterator"(): $IntIterator
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "forEach"(arg0: $IntConsumer$0$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $IntConsumer$Type): void
}

export namespace $IntSet {
function of(arg0: integer, arg1: integer): $IntSet
function of(): $IntSet
function of(...arg0: (integer)[]): $IntSet
function of(arg0: integer): $IntSet
function of(arg0: integer, arg1: integer, arg2: integer): $IntSet
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer): $Set<(integer)>
function of<E>(arg0: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer, arg9: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer, arg8: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer, arg7: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer, arg3: integer, arg4: integer, arg5: integer, arg6: integer): $Set<(integer)>
function of<E>(...arg0: (integer)[]): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer, arg2: integer): $Set<(integer)>
function of<E>(arg0: integer, arg1: integer): $Set<(integer)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntSet$Type = ($IntSet);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntSet_ = $IntSet$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Float2CharFunction, $Float2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2CharFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Char2FloatFunction, $Char2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2FloatFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Char2ByteFunction, $Char2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ByteFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Char2CharFunction, $Char2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2CharFunction"
import {$Double2CharFunction, $Double2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2CharFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Char2DoubleFunction, $Char2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"
import {$Reference2BooleanFunction, $Reference2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction"
import {$Byte2CharFunction, $Byte2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2CharFunction"

export interface $Boolean2CharFunction extends $Function$0<(boolean), (character)> {

 "remove"(arg0: boolean): character
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): character
 "get"(arg0: boolean): character
 "put"(arg0: boolean, arg1: character): character
/**
 * 
 * @deprecated
 */
 "put"(arg0: boolean, arg1: character): character
 "containsKey"(arg0: boolean): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: boolean, arg1: character): character
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: character): character
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (character)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(boolean), (T)>
 "andThenDouble"(arg0: $Char2DoubleFunction$Type): $Boolean2DoubleFunction
 "composeChar"(arg0: $Char2BooleanFunction$Type): $Char2CharFunction
 "composeShort"(arg0: $Short2BooleanFunction$Type): $Short2CharFunction
 "andThenFloat"(arg0: $Char2FloatFunction$Type): $Boolean2FloatFunction
 "composeFloat"(arg0: $Float2BooleanFunction$Type): $Float2CharFunction
 "andThenLong"(arg0: $Char2LongFunction$Type): $Boolean2LongFunction
 "composeLong"(arg0: $Long2BooleanFunction$Type): $Long2CharFunction
 "composeInt"(arg0: $Int2BooleanFunction$Type): $Int2CharFunction
 "andThenInt"(arg0: $Char2IntFunction$Type): $Boolean2IntFunction
 "composeDouble"(arg0: $Double2BooleanFunction$Type): $Double2CharFunction
 "andThenChar"(arg0: $Char2CharFunction$Type): $Boolean2CharFunction
 "composeObject"<T>(arg0: $Object2BooleanFunction$Type<(any)>): $Object2CharFunction<(T)>
 "andThenReference"<T>(arg0: $Char2ReferenceFunction$Type<(any)>): $Boolean2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2BooleanFunction$Type<(any)>): $Reference2CharFunction<(T)>
 "andThenObject"<T>(arg0: $Char2ObjectFunction$Type<(any)>): $Boolean2ObjectFunction<(T)>
 "andThenByte"(arg0: $Char2ByteFunction$Type): $Boolean2ByteFunction
 "defaultReturnValue"(arg0: character): void
 "defaultReturnValue"(): character
 "andThenShort"(arg0: $Char2ShortFunction$Type): $Boolean2ShortFunction
 "composeByte"(arg0: $Byte2BooleanFunction$Type): $Byte2CharFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: boolean): character

(arg0: boolean): character
}

export namespace $Boolean2CharFunction {
function identity<T>(): $Function<(boolean), (boolean)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Boolean2CharFunction$Type = ($Boolean2CharFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Boolean2CharFunction_ = $Boolean2CharFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$LongPredicate" {
import {$LongPredicate as $LongPredicate$0, $LongPredicate$Type as $LongPredicate$0$Type} from "packages/java/util/function/$LongPredicate"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"

export interface $LongPredicate extends $Predicate<(long)>, $LongPredicate$0 {

/**
 * 
 * @deprecated
 */
 "test"(arg0: long): boolean
 "or"(arg0: $LongPredicate$0$Type): $LongPredicate
/**
 * 
 * @deprecated
 */
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(long)>
 "or"(arg0: $LongPredicate$Type): $LongPredicate
 "and"(arg0: $LongPredicate$0$Type): $LongPredicate
 "and"(arg0: $LongPredicate$Type): $LongPredicate
/**
 * 
 * @deprecated
 */
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(long)>
 "test"(arg0: long): boolean

(arg0: long): boolean
}

export namespace $LongPredicate {
function isEqual<T>(arg0: any): $Predicate<(long)>
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $LongPredicate$Type = ($LongPredicate);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $LongPredicate_ = $LongPredicate$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap$FastEntrySet" {
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$ObjectIterator, $ObjectIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectIterator"
import {$Long2ObjectMap$Entry, $Long2ObjectMap$Entry$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectMap$Entry"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"

export interface $Long2ObjectMap$FastEntrySet<V> extends $ObjectSet<($Long2ObjectMap$Entry<(V)>)> {

 "fastForEach"(arg0: $Consumer$Type<(any)>): void
 "fastIterator"(): $ObjectIterator<($Long2ObjectMap$Entry<(V)>)>
 "add"(arg0: $Long2ObjectMap$Entry$Type<(V)>): boolean
 "remove"(arg0: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<($Long2ObjectMap$Entry<(V)>)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<($Long2ObjectMap$Entry<(V)>)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $Long2ObjectMap$FastEntrySet {
function of<K>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>): $ObjectSet<($Long2ObjectMap$Entry<(V)>)>
function of<K>(...arg0: ($Long2ObjectMap$Entry$Type<(V)>)[]): $ObjectSet<($Long2ObjectMap$Entry<(V)>)>
function of<K>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>): $ObjectSet<($Long2ObjectMap$Entry<(V)>)>
function of<K>(): $ObjectSet<($Long2ObjectMap$Entry<(V)>)>
function of<K>(arg0: $Long2ObjectMap$Entry$Type<(V)>): $ObjectSet<($Long2ObjectMap$Entry<(V)>)>
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<($Long2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>, arg3: $Long2ObjectMap$Entry$Type<(V)>, arg4: $Long2ObjectMap$Entry$Type<(V)>, arg5: $Long2ObjectMap$Entry$Type<(V)>): $Set<($Long2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>, arg3: $Long2ObjectMap$Entry$Type<(V)>, arg4: $Long2ObjectMap$Entry$Type<(V)>): $Set<($Long2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>, arg3: $Long2ObjectMap$Entry$Type<(V)>): $Set<($Long2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>, arg3: $Long2ObjectMap$Entry$Type<(V)>, arg4: $Long2ObjectMap$Entry$Type<(V)>, arg5: $Long2ObjectMap$Entry$Type<(V)>, arg6: $Long2ObjectMap$Entry$Type<(V)>, arg7: $Long2ObjectMap$Entry$Type<(V)>, arg8: $Long2ObjectMap$Entry$Type<(V)>, arg9: $Long2ObjectMap$Entry$Type<(V)>): $Set<($Long2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>, arg3: $Long2ObjectMap$Entry$Type<(V)>, arg4: $Long2ObjectMap$Entry$Type<(V)>, arg5: $Long2ObjectMap$Entry$Type<(V)>, arg6: $Long2ObjectMap$Entry$Type<(V)>, arg7: $Long2ObjectMap$Entry$Type<(V)>, arg8: $Long2ObjectMap$Entry$Type<(V)>): $Set<($Long2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>, arg3: $Long2ObjectMap$Entry$Type<(V)>, arg4: $Long2ObjectMap$Entry$Type<(V)>, arg5: $Long2ObjectMap$Entry$Type<(V)>, arg6: $Long2ObjectMap$Entry$Type<(V)>, arg7: $Long2ObjectMap$Entry$Type<(V)>): $Set<($Long2ObjectMap$Entry<(V)>)>
function of<E>(arg0: $Long2ObjectMap$Entry$Type<(V)>, arg1: $Long2ObjectMap$Entry$Type<(V)>, arg2: $Long2ObjectMap$Entry$Type<(V)>, arg3: $Long2ObjectMap$Entry$Type<(V)>, arg4: $Long2ObjectMap$Entry$Type<(V)>, arg5: $Long2ObjectMap$Entry$Type<(V)>, arg6: $Long2ObjectMap$Entry$Type<(V)>): $Set<($Long2ObjectMap$Entry<(V)>)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ObjectMap$FastEntrySet$Type<V> = ($Long2ObjectMap$FastEntrySet<(V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ObjectMap$FastEntrySet_<V> = $Long2ObjectMap$FastEntrySet$Type<(V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntIterable" {
import {$IntSpliterator, $IntSpliterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntSpliterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$IntIterator, $IntIterator$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntIterator"
import {$IntConsumer, $IntConsumer$Type} from "packages/it/unimi/dsi/fastutil/ints/$IntConsumer"
import {$IntConsumer as $IntConsumer$0, $IntConsumer$Type as $IntConsumer$0$Type} from "packages/java/util/function/$IntConsumer"
import {$Iterable, $Iterable$Type} from "packages/java/lang/$Iterable"

export interface $IntIterable extends $Iterable<(integer)> {

 "forEach"(arg0: $IntConsumer$0$Type): void
/**
 * 
 * @deprecated
 */
 "forEach"(arg0: $Consumer$Type<(any)>): void
 "forEach"(arg0: $IntConsumer$Type): void
 "intSpliterator"(): $IntSpliterator
 "intIterator"(): $IntIterator
}

export namespace $IntIterable {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntIterable$Type = ($IntIterable);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntIterable_ = $IntIterable$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2BooleanFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Boolean2IntFunction, $Boolean2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2IntFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Boolean2FloatFunction, $Boolean2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2FloatFunction"
import {$Boolean2CharFunction, $Boolean2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2CharFunction"
import {$Short2BooleanFunction, $Short2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2BooleanFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Double2BooleanFunction, $Double2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2BooleanFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2BooleanFunction, $Float2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2BooleanFunction"
import {$Int2BooleanFunction, $Int2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2BooleanFunction"
import {$Boolean2DoubleFunction, $Boolean2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2DoubleFunction"
import {$Char2BooleanFunction, $Char2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2BooleanFunction"
import {$Boolean2LongFunction, $Boolean2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2LongFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"
import {$Boolean2ByteFunction, $Boolean2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ByteFunction"
import {$Object2BooleanFunction, $Object2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2BooleanFunction"
import {$Byte2BooleanFunction, $Byte2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2BooleanFunction"
import {$Boolean2ObjectFunction, $Boolean2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ObjectFunction"
import {$Long2BooleanFunction, $Long2BooleanFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2BooleanFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Boolean2ShortFunction, $Boolean2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ShortFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Boolean2ReferenceFunction, $Boolean2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/booleans/$Boolean2ReferenceFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2ReferenceFunction, $Reference2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction"

export interface $Reference2BooleanFunction<K> extends $Function$0<(K), (boolean)>, $Predicate<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: boolean): boolean
 "put"(arg0: K, arg1: boolean): boolean
 "getBoolean"(arg0: any): boolean
 "test"(arg0: K): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: boolean): boolean
 "getOrDefault"(arg0: any, arg1: boolean): boolean
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "andThenDouble"(arg0: $Boolean2DoubleFunction$Type): $Reference2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2BooleanFunction
 "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2BooleanFunction
 "andThenFloat"(arg0: $Boolean2FloatFunction$Type): $Reference2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2BooleanFunction
 "andThenLong"(arg0: $Boolean2LongFunction$Type): $Reference2LongFunction<(K)>
 "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2BooleanFunction
 "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2BooleanFunction
 "andThenInt"(arg0: $Boolean2IntFunction$Type): $Reference2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2BooleanFunction
 "andThenChar"(arg0: $Boolean2CharFunction$Type): $Reference2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2BooleanFunction<(T)>
 "andThenReference"<T>(arg0: $Boolean2ReferenceFunction$Type<(any)>): $Reference2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2BooleanFunction<(T)>
 "andThenObject"<T>(arg0: $Boolean2ObjectFunction$Type<(any)>): $Reference2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Boolean2ByteFunction$Type): $Reference2ByteFunction<(K)>
 "defaultReturnValue"(): boolean
 "defaultReturnValue"(arg0: boolean): void
 "removeBoolean"(arg0: any): boolean
 "andThenShort"(arg0: $Boolean2ShortFunction$Type): $Reference2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2BooleanFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): boolean
 "containsKey"(arg0: any): boolean
 "or"(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
 "and"(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
 "negate"(): $Predicate<(K)>
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (boolean)>

(arg0: any): boolean
}

export namespace $Reference2BooleanFunction {
function isEqual<T>(arg0: any): $Predicate<(K)>
function not<T>(arg0: $Predicate$Type<(any)>): $Predicate<(K)>
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2BooleanFunction$Type<K> = ($Reference2BooleanFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2BooleanFunction_<K> = $Reference2BooleanFunction$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$ObjectSortedSet" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$SortedSet, $SortedSet$Type} from "packages/java/util/$SortedSet"
import {$Set, $Set$Type} from "packages/java/util/$Set"
import {$Collection, $Collection$Type} from "packages/java/util/$Collection"
import {$IntFunction, $IntFunction$Type} from "packages/java/util/function/$IntFunction"
import {$Predicate, $Predicate$Type} from "packages/java/util/function/$Predicate"
import {$Stream, $Stream$Type} from "packages/java/util/stream/$Stream"
import {$ObjectBidirectionalIterator, $ObjectBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterator"
import {$ObjectBidirectionalIterable, $ObjectBidirectionalIterable$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectBidirectionalIterable"

export interface $ObjectSortedSet<K> extends $ObjectSet<(K)>, $SortedSet<(K)>, $ObjectBidirectionalIterable<(K)> {

 "iterator"(arg0: K): $ObjectBidirectionalIterator<(K)>
 "last"(): K
 "first"(): K
 "comparator"(): $Comparator<(any)>
 "add"(arg0: K): boolean
 "remove"(arg0: any): boolean
 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "clear"(): void
 "isEmpty"(): boolean
 "size"(): integer
 "toArray"<T>(arg0: (T)[]): (T)[]
 "toArray"(): (any)[]
 "contains"(arg0: any): boolean
 "addAll"(arg0: $Collection$Type<(any)>): boolean
 "removeAll"(arg0: $Collection$Type<(any)>): boolean
 "retainAll"(arg0: $Collection$Type<(any)>): boolean
 "containsAll"(arg0: $Collection$Type<(any)>): boolean
 "toArray"<T>(arg0: $IntFunction$Type<((T)[])>): (T)[]
 "stream"(): $Stream<(K)>
 "removeIf"(arg0: $Predicate$Type<(any)>): boolean
 "parallelStream"(): $Stream<(K)>
 "forEach"(arg0: $Consumer$Type<(any)>): void
}

export namespace $ObjectSortedSet {
function of<K>(arg0: K, arg1: K): $ObjectSet<(K)>
function of<K>(...arg0: (K)[]): $ObjectSet<(K)>
function of<K>(arg0: K, arg1: K, arg2: K): $ObjectSet<(K)>
function of<K>(): $ObjectSet<(K)>
function of<K>(arg0: K): $ObjectSet<(K)>
function copyOf<E>(arg0: $Collection$Type<(any)>): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K, arg9: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K, arg8: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K, arg7: K): $Set<(K)>
function of<E>(arg0: K, arg1: K, arg2: K, arg3: K, arg4: K, arg5: K, arg6: K): $Set<(K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $ObjectSortedSet$Type<K> = ($ObjectSortedSet<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $ObjectSortedSet_<K> = $ObjectSortedSet$Type<(K)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2ObjectFunction" {
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"

export class $AbstractObject2ObjectFunction<K, V> implements $Object2ObjectFunction<(K), (V)>, $Serializable {


public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public "remove"(arg0: any): V
public "get"(arg0: any): V
public "put"(arg0: K, arg1: V): V
public "getOrDefault"(arg0: any, arg1: V): V
public "andThenDouble"(arg0: $Object2DoubleFunction$Type<(V)>): $Object2DoubleFunction<(K)>
public "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2ObjectFunction<(V)>
public "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2ObjectFunction<(V)>
public "andThenFloat"(arg0: $Object2FloatFunction$Type<(V)>): $Object2FloatFunction<(K)>
public "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2ObjectFunction<(V)>
public "andThenLong"(arg0: $Object2LongFunction$Type<(V)>): $Object2LongFunction<(K)>
public "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2ObjectFunction<(V)>
public "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2ObjectFunction<(V)>
public "andThenInt"(arg0: $Object2IntFunction$Type<(V)>): $Object2IntFunction<(K)>
public "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2ObjectFunction<(V)>
public "andThenChar"(arg0: $Object2CharFunction$Type<(V)>): $Object2CharFunction<(K)>
public "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ObjectFunction<(T), (V)>
public "andThenReference"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2ReferenceFunction<(K), (T)>
public "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2ObjectFunction<(T), (V)>
public "andThenObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2ObjectFunction<(K), (T)>
public "andThenByte"(arg0: $Object2ByteFunction$Type<(V)>): $Object2ByteFunction<(K)>
public "andThenShort"(arg0: $Object2ShortFunction$Type<(V)>): $Object2ShortFunction<(K)>
public "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2ObjectFunction<(V)>
public "clear"(): void
public "size"(): integer
public "apply"(arg0: K): V
public "containsKey"(arg0: any): boolean
public static "identity"<T>(): $Function<(K), (K)>
public "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (V)>
public "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $AbstractObject2ObjectFunction$Type<K, V> = ($AbstractObject2ObjectFunction<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $AbstractObject2ObjectFunction_<K, V> = $AbstractObject2ObjectFunction$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction" {
import {$Short2CharFunction, $Short2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2CharFunction"
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Short2DoubleFunction, $Short2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2DoubleFunction"
import {$Short2ByteFunction, $Short2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ByteFunction"
import {$Float2ShortFunction, $Float2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ShortFunction"
import {$LongToIntFunction, $LongToIntFunction$Type} from "packages/java/util/function/$LongToIntFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Double2ShortFunction, $Double2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ShortFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2LongFunction, $Object2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Short2FloatFunction, $Short2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2FloatFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Char2ShortFunction, $Char2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ShortFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Byte2ShortFunction, $Byte2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ShortFunction"
import {$Short2ShortFunction, $Short2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ShortFunction"

export interface $Long2ShortFunction extends $Function$0<(long), (short)>, $LongToIntFunction {

 "remove"(arg0: long): short
 "get"(arg0: long): short
 "put"(arg0: long, arg1: short): short
/**
 * 
 * @deprecated
 */
 "put"(arg0: long, arg1: short): short
 "containsKey"(arg0: long): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: short): short
 "getOrDefault"(arg0: long, arg1: short): short
 "applyAsInt"(arg0: long): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$Type<(any), (any)>): $Function<(T), (short)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(long), (T)>
 "andThenDouble"(arg0: $Short2DoubleFunction$Type): $Long2DoubleFunction
 "composeChar"(arg0: $Char2LongFunction$Type): $Char2ShortFunction
 "composeShort"(arg0: $Short2LongFunction$Type): $Short2ShortFunction
 "andThenFloat"(arg0: $Short2FloatFunction$Type): $Long2FloatFunction
 "composeFloat"(arg0: $Float2LongFunction$Type): $Float2ShortFunction
 "andThenLong"(arg0: $Short2LongFunction$Type): $Long2LongFunction
 "composeLong"(arg0: $Long2LongFunction$Type): $Long2ShortFunction
 "composeInt"(arg0: $Int2LongFunction$Type): $Int2ShortFunction
 "andThenInt"(arg0: $Short2IntFunction$Type): $Long2IntFunction
 "composeDouble"(arg0: $Double2LongFunction$Type): $Double2ShortFunction
 "andThenChar"(arg0: $Short2CharFunction$Type): $Long2CharFunction
 "composeObject"<T>(arg0: $Object2LongFunction$Type<(any)>): $Object2ShortFunction<(T)>
 "andThenReference"<T>(arg0: $Short2ReferenceFunction$Type<(any)>): $Long2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2LongFunction$Type<(any)>): $Reference2ShortFunction<(T)>
 "andThenObject"<T>(arg0: $Short2ObjectFunction$Type<(any)>): $Long2ObjectFunction<(T)>
 "andThenByte"(arg0: $Short2ByteFunction$Type): $Long2ByteFunction
 "defaultReturnValue"(arg0: short): void
 "defaultReturnValue"(): short
 "andThenShort"(arg0: $Short2ShortFunction$Type): $Long2ShortFunction
 "composeByte"(arg0: $Byte2LongFunction$Type): $Byte2ShortFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: long): short

(arg0: long): short
}

export namespace $Long2ShortFunction {
function identity<T>(): $Function<(long), (long)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Long2ShortFunction$Type = ($Long2ShortFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Long2ShortFunction_ = $Long2ShortFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/doubles/$DoubleListIterator" {
import {$DoubleBidirectionalIterator, $DoubleBidirectionalIterator$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleBidirectionalIterator"
import {$Consumer, $Consumer$Type} from "packages/java/util/function/$Consumer"
import {$DoubleConsumer, $DoubleConsumer$Type} from "packages/it/unimi/dsi/fastutil/doubles/$DoubleConsumer"
import {$DoubleConsumer as $DoubleConsumer$0, $DoubleConsumer$Type as $DoubleConsumer$0$Type} from "packages/java/util/function/$DoubleConsumer"
import {$ListIterator, $ListIterator$Type} from "packages/java/util/$ListIterator"

export interface $DoubleListIterator extends $DoubleBidirectionalIterator, $ListIterator<(double)> {

/**
 * 
 * @deprecated
 */
 "add"(arg0: double): void
 "add"(arg0: double): void
 "remove"(): void
/**
 * 
 * @deprecated
 */
 "set"(arg0: double): void
 "set"(arg0: double): void
 "skip"(arg0: integer): integer
 "back"(arg0: integer): integer
 "previousDouble"(): double
 "hasNext"(): boolean
 "nextIndex"(): integer
 "previousIndex"(): integer
 "hasPrevious"(): boolean
 "nextDouble"(): double
/**
 * 
 * @deprecated
 */
 "forEachRemaining"(arg0: $Consumer$Type<(any)>): void
 "forEachRemaining"(arg0: $DoubleConsumer$Type): void
 "forEachRemaining"(arg0: $DoubleConsumer$0$Type): void
}

export namespace $DoubleListIterator {
const probejs$$marker: never
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $DoubleListIterator$Type = ($DoubleListIterator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $DoubleListIterator_ = $DoubleListIterator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceOpenHashMap" {
import {$AbstractObject2ReferenceMap, $AbstractObject2ReferenceMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$AbstractObject2ReferenceMap"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Serializable, $Serializable$Type} from "packages/java/io/$Serializable"
import {$Object2ReferenceMap, $Object2ReferenceMap$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceMap"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$ObjectSet, $ObjectSet$Type} from "packages/it/unimi/dsi/fastutil/objects/$ObjectSet"
import {$Hash, $Hash$Type} from "packages/it/unimi/dsi/fastutil/$Hash"
import {$Cloneable, $Cloneable$Type} from "packages/java/lang/$Cloneable"
import {$BiFunction, $BiFunction$Type} from "packages/java/util/function/$BiFunction"
import {$Map, $Map$Type} from "packages/java/util/$Map"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export class $Object2ReferenceOpenHashMap<K, V> extends $AbstractObject2ReferenceMap<(K), (V)> implements $Serializable, $Cloneable, $Hash {

constructor(arg0: $Map$Type<(any), (any)>)
constructor(arg0: $Object2ReferenceMap$Type<(K), (V)>, arg1: float)
constructor(arg0: $Object2ReferenceMap$Type<(K), (V)>)
constructor(arg0: (K)[], arg1: (V)[], arg2: float)
constructor(arg0: (K)[], arg1: (V)[])
constructor(arg0: integer, arg1: float)
constructor(arg0: integer)
constructor()
constructor(arg0: $Map$Type<(any), (any)>, arg1: float)

public "remove"(arg0: any, arg1: any): boolean
public "remove"(arg0: any): V
public "get"(arg0: any): V
public "put"(arg0: K, arg1: V): V
public "hashCode"(): integer
public "clear"(): void
public "isEmpty"(): boolean
public "replace"(arg0: K, arg1: V, arg2: V): boolean
public "replace"(arg0: K, arg1: V): V
public "size"(): integer
public "trim"(): boolean
public "trim"(arg0: integer): boolean
public "merge"(arg0: K, arg1: V, arg2: $BiFunction$Type<(any), (any), (any)>): V
public "putAll"(arg0: $Map$Type<(any), (any)>): void
public "putIfAbsent"(arg0: K, arg1: V): V
public "compute"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "containsKey"(arg0: any): boolean
public "computeIfAbsent"(arg0: K, arg1: $Object2ReferenceFunction$Type<(any), (any)>): V
public "keySet"(): $ObjectSet<(K)>
public "containsValue"(arg0: any): boolean
public "getOrDefault"(arg0: any, arg1: V): V
public "computeIfPresent"(arg0: K, arg1: $BiFunction$Type<(any), (any), (any)>): V
public "defaultReturnValue"(arg0: V): void
public "defaultReturnValue"(): V
public static "copyOf"<K, V>(arg0: $Map$Type<(any), (any)>): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V): $Map<(K), (V)>
public static "of"<K, V>(): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V, arg18: K, arg19: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V, arg16: K, arg17: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V, arg14: K, arg15: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V, arg12: K, arg13: V): $Map<(K), (V)>
public static "of"<K, V>(arg0: K, arg1: V, arg2: K, arg3: V, arg4: K, arg5: V, arg6: K, arg7: V, arg8: K, arg9: V, arg10: K, arg11: V): $Map<(K), (V)>
public static "entry"<K, V>(arg0: K, arg1: V): $Map$Entry<(K), (V)>
public static "ofEntries"<K, V>(...arg0: ($Map$Entry$Type<(any), (any)>)[]): $Map<(K), (V)>
public static "identity"<T>(): $Function<(T), (T)>
get "empty"(): boolean
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ReferenceOpenHashMap$Type<K, V> = ($Object2ReferenceOpenHashMap<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ReferenceOpenHashMap_<K, V> = $Object2ReferenceOpenHashMap$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Reference2ReferenceFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Function, $Function$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2DoubleFunction, $Reference2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2DoubleFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Reference2CharFunction, $Reference2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2CharFunction"
import {$Double2ReferenceFunction, $Double2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ReferenceFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Char2ReferenceFunction, $Char2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ReferenceFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Float2ReferenceFunction, $Float2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ReferenceFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$Short2ReferenceFunction, $Short2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ReferenceFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/java/util/function/$Function"
import {$Reference2ShortFunction, $Reference2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ShortFunction"
import {$Reference2ByteFunction, $Reference2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ByteFunction"
import {$Byte2ReferenceFunction, $Byte2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ReferenceFunction"
import {$Reference2FloatFunction, $Reference2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2FloatFunction"

export interface $Reference2ReferenceFunction<K, V> extends $Function<(K), (V)> {

 "remove"(arg0: any): V
 "get"(arg0: any): V
 "put"(arg0: K, arg1: V): V
 "getOrDefault"(arg0: any, arg1: V): V
 "andThenDouble"(arg0: $Reference2DoubleFunction$Type<(V)>): $Reference2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ReferenceFunction$Type<(K)>): $Char2ReferenceFunction<(V)>
 "composeShort"(arg0: $Short2ReferenceFunction$Type<(K)>): $Short2ReferenceFunction<(V)>
 "andThenFloat"(arg0: $Reference2FloatFunction$Type<(V)>): $Reference2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ReferenceFunction$Type<(K)>): $Float2ReferenceFunction<(V)>
 "andThenLong"(arg0: $Reference2LongFunction$Type<(V)>): $Reference2LongFunction<(K)>
 "composeLong"(arg0: $Long2ReferenceFunction$Type<(K)>): $Long2ReferenceFunction<(V)>
 "composeInt"(arg0: $Int2ReferenceFunction$Type<(K)>): $Int2ReferenceFunction<(V)>
 "andThenInt"(arg0: $Reference2IntFunction$Type<(V)>): $Reference2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ReferenceFunction$Type<(K)>): $Double2ReferenceFunction<(V)>
 "andThenChar"(arg0: $Reference2CharFunction$Type<(V)>): $Reference2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ReferenceFunction$Type<(any), (any)>): $Object2ReferenceFunction<(T), (V)>
 "andThenReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ReferenceFunction$Type<(any), (any)>): $Reference2ReferenceFunction<(T), (V)>
 "andThenObject"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2ObjectFunction<(K), (T)>
 "andThenByte"(arg0: $Reference2ByteFunction$Type<(V)>): $Reference2ByteFunction<(K)>
 "defaultReturnValue"(): V
 "defaultReturnValue"(arg0: V): void
 "andThenShort"(arg0: $Reference2ShortFunction$Type<(V)>): $Reference2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ReferenceFunction$Type<(K)>): $Byte2ReferenceFunction<(V)>
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): V
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(V), (V)>
 "andThen"<V>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(K), (V)>

(arg0: any): V
}

export namespace $Reference2ReferenceFunction {
function identity<T>(): $Function$0<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Reference2ReferenceFunction$Type<K, V> = ($Reference2ReferenceFunction<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Reference2ReferenceFunction_<K, V> = $Reference2ReferenceFunction$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$IntUnaryOperator" {
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$UnaryOperator, $UnaryOperator$Type} from "packages/java/util/function/$UnaryOperator"
import {$IntUnaryOperator as $IntUnaryOperator$0, $IntUnaryOperator$Type as $IntUnaryOperator$0$Type} from "packages/java/util/function/$IntUnaryOperator"

export interface $IntUnaryOperator extends $UnaryOperator<(integer)>, $IntUnaryOperator$0 {

/**
 * 
 * @deprecated
 */
 "apply"(arg0: integer): integer
 "apply"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "applyAsInt"(arg0: integer): integer
 "compose"(arg0: $IntUnaryOperator$0$Type): $IntUnaryOperator$0
 "andThen"(arg0: $IntUnaryOperator$0$Type): $IntUnaryOperator$0
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (integer)>
 "andThen"<V>(arg0: $Function$Type<(any), (any)>): $Function<(integer), (V)>

(arg0: integer): integer
}

export namespace $IntUnaryOperator {
function identity(): $IntUnaryOperator
function negation(): $IntUnaryOperator
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $IntUnaryOperator$Type = ($IntUnaryOperator);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $IntUnaryOperator_ = $IntUnaryOperator$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/ints/$Int2IntFunction" {
import {$Int2ReferenceFunction, $Int2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ReferenceFunction"
import {$Function, $Function$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Double2IntFunction, $Double2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2IntFunction"
import {$Float2IntFunction, $Float2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2IntFunction"
import {$Byte2IntFunction, $Byte2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2IntFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Reference2IntFunction, $Reference2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2IntFunction"
import {$IntUnaryOperator, $IntUnaryOperator$Type} from "packages/java/util/function/$IntUnaryOperator"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Int2CharFunction, $Int2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2CharFunction"
import {$Short2IntFunction, $Short2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2IntFunction"
import {$Int2ShortFunction, $Int2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/java/util/function/$Function"
import {$Int2FloatFunction, $Int2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2FloatFunction"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Int2ByteFunction, $Int2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ByteFunction"
import {$Int2DoubleFunction, $Int2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2DoubleFunction"
import {$Char2IntFunction, $Char2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2IntFunction"

export interface $Int2IntFunction extends $Function<(integer), (integer)>, $IntUnaryOperator {

 "remove"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "get"(arg0: any): integer
 "get"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "put"(arg0: integer, arg1: integer): integer
 "put"(arg0: integer, arg1: integer): integer
 "containsKey"(arg0: integer): boolean
/**
 * 
 * @deprecated
 */
 "containsKey"(arg0: any): boolean
 "getOrDefault"(arg0: integer, arg1: integer): integer
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: integer): integer
 "applyAsInt"(arg0: integer): integer
/**
 * 
 * @deprecated
 */
 "compose"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(T), (integer)>
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$0$Type<(any), (any)>): $Function$0<(integer), (T)>
 "andThenDouble"(arg0: $Int2DoubleFunction$Type): $Int2DoubleFunction
 "composeChar"(arg0: $Char2IntFunction$Type): $Char2IntFunction
 "composeShort"(arg0: $Short2IntFunction$Type): $Short2IntFunction
 "andThenFloat"(arg0: $Int2FloatFunction$Type): $Int2FloatFunction
 "composeFloat"(arg0: $Float2IntFunction$Type): $Float2IntFunction
 "andThenLong"(arg0: $Int2LongFunction$Type): $Int2LongFunction
 "composeLong"(arg0: $Long2IntFunction$Type): $Long2IntFunction
 "composeInt"(arg0: $Int2IntFunction$Type): $Int2IntFunction
 "andThenInt"(arg0: $Int2IntFunction$Type): $Int2IntFunction
 "composeDouble"(arg0: $Double2IntFunction$Type): $Double2IntFunction
 "andThenChar"(arg0: $Int2CharFunction$Type): $Int2CharFunction
 "composeObject"<T>(arg0: $Object2IntFunction$Type<(any)>): $Object2IntFunction<(T)>
 "andThenReference"<T>(arg0: $Int2ReferenceFunction$Type<(any)>): $Int2ReferenceFunction<(T)>
 "composeReference"<T>(arg0: $Reference2IntFunction$Type<(any)>): $Reference2IntFunction<(T)>
 "andThenObject"<T>(arg0: $Int2ObjectFunction$Type<(any)>): $Int2ObjectFunction<(T)>
 "andThenByte"(arg0: $Int2ByteFunction$Type): $Int2ByteFunction
 "defaultReturnValue"(arg0: integer): void
 "defaultReturnValue"(): integer
 "andThenShort"(arg0: $Int2ShortFunction$Type): $Int2ShortFunction
 "composeByte"(arg0: $Byte2IntFunction$Type): $Byte2IntFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: integer): integer
 "compose"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator
 "andThen"(arg0: $IntUnaryOperator$Type): $IntUnaryOperator

(arg0: integer): integer
}

export namespace $Int2IntFunction {
function identity(): $Int2IntFunction
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Int2IntFunction$Type = ($Int2IntFunction);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Int2IntFunction_ = $Int2IntFunction$Type;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectMap$Entry" {
import {$Comparator, $Comparator$Type} from "packages/java/util/$Comparator"
import {$Comparable, $Comparable$Type} from "packages/java/lang/$Comparable"
import {$Map$Entry, $Map$Entry$Type} from "packages/java/util/$Map$Entry"

export interface $Object2ObjectMap$Entry<K, V> extends $Map$Entry<(K), (V)> {

 "equals"(arg0: any): boolean
 "hashCode"(): integer
 "getValue"(): V
 "getKey"(): K
 "setValue"(arg0: V): V
}

export namespace $Object2ObjectMap$Entry {
function comparingByKey<K, V>(): $Comparator<($Map$Entry<(K), (V)>)>
function comparingByKey<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (V)>)>
function comparingByValue<K, V>(): $Comparator<($Map$Entry<(K), (V)>)>
function comparingByValue<K, V>(arg0: $Comparator$Type<(any)>): $Comparator<($Map$Entry<(K), (V)>)>
function copyOf<K, V>(arg0: $Map$Entry$Type<(any), (any)>): $Map$Entry<(K), (V)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2ObjectMap$Entry$Type<K, V> = ($Object2ObjectMap$Entry<(K), (V)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2ObjectMap$Entry_<K, V> = $Object2ObjectMap$Entry$Type<(K), (V)>;
}}
declare module "packages/it/unimi/dsi/fastutil/objects/$Object2LongFunction" {
import {$Long2DoubleFunction, $Long2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2DoubleFunction"
import {$Long2FloatFunction, $Long2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2FloatFunction"
import {$Object2DoubleFunction, $Object2DoubleFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2DoubleFunction"
import {$Int2ObjectFunction, $Int2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2ObjectFunction"
import {$Reference2ObjectFunction, $Reference2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2ObjectFunction"
import {$Double2ObjectFunction, $Double2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2ObjectFunction"
import {$Long2IntFunction, $Long2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2IntFunction"
import {$Byte2LongFunction, $Byte2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2LongFunction"
import {$Object2ByteFunction, $Object2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ByteFunction"
import {$Function, $Function$Type} from "packages/java/util/function/$Function"
import {$Object2IntFunction, $Object2IntFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2IntFunction"
import {$Float2LongFunction, $Float2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2LongFunction"
import {$Object2CharFunction, $Object2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2CharFunction"
import {$Char2LongFunction, $Char2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2LongFunction"
import {$ToLongFunction, $ToLongFunction$Type} from "packages/java/util/function/$ToLongFunction"
import {$Object2ObjectFunction, $Object2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ObjectFunction"
import {$Short2LongFunction, $Short2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2LongFunction"
import {$Long2ObjectFunction, $Long2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ObjectFunction"
import {$Double2LongFunction, $Double2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/doubles/$Double2LongFunction"
import {$Object2ShortFunction, $Object2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ShortFunction"
import {$Long2ShortFunction, $Long2ShortFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ShortFunction"
import {$Function as $Function$0, $Function$Type as $Function$0$Type} from "packages/it/unimi/dsi/fastutil/$Function"
import {$Object2ReferenceFunction, $Object2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2ReferenceFunction"
import {$Reference2LongFunction, $Reference2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Reference2LongFunction"
import {$Long2ReferenceFunction, $Long2ReferenceFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ReferenceFunction"
import {$Short2ObjectFunction, $Short2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/shorts/$Short2ObjectFunction"
import {$Int2LongFunction, $Int2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/ints/$Int2LongFunction"
import {$Object2FloatFunction, $Object2FloatFunction$Type} from "packages/it/unimi/dsi/fastutil/objects/$Object2FloatFunction"
import {$Float2ObjectFunction, $Float2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/floats/$Float2ObjectFunction"
import {$Long2ByteFunction, $Long2ByteFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2ByteFunction"
import {$Char2ObjectFunction, $Char2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/chars/$Char2ObjectFunction"
import {$Long2CharFunction, $Long2CharFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2CharFunction"
import {$Long2LongFunction, $Long2LongFunction$Type} from "packages/it/unimi/dsi/fastutil/longs/$Long2LongFunction"
import {$Byte2ObjectFunction, $Byte2ObjectFunction$Type} from "packages/it/unimi/dsi/fastutil/bytes/$Byte2ObjectFunction"

export interface $Object2LongFunction<K> extends $Function$0<(K), (long)>, $ToLongFunction<(K)> {

/**
 * 
 * @deprecated
 */
 "remove"(arg0: any): long
 "put"(arg0: K, arg1: long): long
/**
 * 
 * @deprecated
 */
 "put"(arg0: K, arg1: long): long
 "getLong"(arg0: any): long
 "getOrDefault"(arg0: any, arg1: long): long
/**
 * 
 * @deprecated
 */
 "getOrDefault"(arg0: any, arg1: long): long
 "applyAsLong"(arg0: K): long
/**
 * 
 * @deprecated
 */
 "andThen"<T>(arg0: $Function$Type<(any), (any)>): $Function<(K), (T)>
 "andThenDouble"(arg0: $Long2DoubleFunction$Type): $Object2DoubleFunction<(K)>
 "composeChar"(arg0: $Char2ObjectFunction$Type<(K)>): $Char2LongFunction
 "composeShort"(arg0: $Short2ObjectFunction$Type<(K)>): $Short2LongFunction
 "andThenFloat"(arg0: $Long2FloatFunction$Type): $Object2FloatFunction<(K)>
 "composeFloat"(arg0: $Float2ObjectFunction$Type<(K)>): $Float2LongFunction
 "andThenLong"(arg0: $Long2LongFunction$Type): $Object2LongFunction<(K)>
 "composeLong"(arg0: $Long2ObjectFunction$Type<(K)>): $Long2LongFunction
 "composeInt"(arg0: $Int2ObjectFunction$Type<(K)>): $Int2LongFunction
 "andThenInt"(arg0: $Long2IntFunction$Type): $Object2IntFunction<(K)>
 "composeDouble"(arg0: $Double2ObjectFunction$Type<(K)>): $Double2LongFunction
 "andThenChar"(arg0: $Long2CharFunction$Type): $Object2CharFunction<(K)>
 "composeObject"<T>(arg0: $Object2ObjectFunction$Type<(any), (any)>): $Object2LongFunction<(T)>
 "andThenReference"<T>(arg0: $Long2ReferenceFunction$Type<(any)>): $Object2ReferenceFunction<(K), (T)>
 "composeReference"<T>(arg0: $Reference2ObjectFunction$Type<(any), (any)>): $Reference2LongFunction<(T)>
 "andThenObject"<T>(arg0: $Long2ObjectFunction$Type<(any)>): $Object2ObjectFunction<(K), (T)>
 "removeLong"(arg0: any): long
 "andThenByte"(arg0: $Long2ByteFunction$Type): $Object2ByteFunction<(K)>
 "defaultReturnValue"(arg0: long): void
 "defaultReturnValue"(): long
 "andThenShort"(arg0: $Long2ShortFunction$Type): $Object2ShortFunction<(K)>
 "composeByte"(arg0: $Byte2ObjectFunction$Type<(K)>): $Byte2LongFunction
 "clear"(): void
 "size"(): integer
 "apply"(arg0: K): long
 "containsKey"(arg0: any): boolean
 "compose"<V>(arg0: $Function$Type<(any), (any)>): $Function<(V), (long)>

(arg0: any): long
}

export namespace $Object2LongFunction {
function identity<T>(): $Function<(K), (K)>
}
/**
 * Class-specific type exported by ProbeJS, use global Type_
 * types for convenience unless there's a naming conflict.
 */
export type $Object2LongFunction$Type<K> = ($Object2LongFunction<(K)>);
/**
 * Global type exported for convenience, use class-specific
 * types if there's a naming conflict.
 */
declare global {
export type $Object2LongFunction_<K> = $Object2LongFunction$Type<(K)>;
}}
